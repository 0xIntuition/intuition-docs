name: Generate LLMs.txt Files

on:
  push:
    branches: [main]
    paths:
      - 'docs/**/*.md'
      - 'docs/**/*.mdx'
      - 'src/**/*.mdx'
  workflow_dispatch: # Allow manual trigger

jobs:
  generate-llms-txt:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Generate llms.txt (essential docs)
        run: |
          cat > llms.txt << 'EOF'
          # Intuition

          > Intuition is a permissionless protocol for creating verifiable, tokenized attestations. It enables developers to build context-aware applications using semantic triples (subject-predicate-object relationships) backed by economic incentives through bonding curves.

          ## Introduction

          - [Overview](https://docs.intuition.systems/guides/introduction/overview): Intuition at a glance and core value proposition
          - [Why Intuition](https://docs.intuition.systems/guides/introduction/why-intuition): The problem Intuition solves and Information Finance

          ## Primitives

          - [Primitives Overview](https://docs.intuition.systems/guides/primitives/overview): Understanding Intuition's core building blocks
          - [Atoms](https://docs.intuition.systems/guides/primitives/atoms): Individual claims and pieces of information stored on-chain
          - [Triples](https://docs.intuition.systems/guides/primitives/triples): Subject-predicate-object relationships connecting atoms
          - [Signals](https://docs.intuition.systems/guides/primitives/signals): Economic mechanisms for agreement and disagreement

          ## Getting Started

          - [Quickstart Guide](https://docs.intuition.systems/guides/quickstart): Get up and running with Intuition

          ## Economics

          - [Economic Primitives](https://docs.intuition.systems/guides/economics): Understanding the protocol's economic mechanisms
          - [Bonding Curves](https://docs.intuition.systems/guides/economics/bonding-curves): How dynamic pricing works in Intuition
          - [Fees & Rewards](https://docs.intuition.systems/guides/economics/fees-rewards): Protocol fee structure and reward distribution

          ## Developer Tools

          - [SDK Overview](https://docs.intuition.systems/guides/developer-tools/sdks/overview): TypeScript/JavaScript SDKs for protocol interaction
          - [GraphQL API](https://docs.intuition.systems/guides/developer-tools/graphql-api/overview): Query the Intuition knowledge graph
          - [Smart Contracts](https://docs.intuition.systems/guides/developer-tools/contracts/overview): Core protocol contracts and architecture
          - [Contract Deployments](https://docs.intuition.systems/guides/developer-tools/contracts/deployments): Contract addresses across networks
          - [Audit Reports](https://docs.intuition.systems/guides/developer-tools/audit-reports): Security audit reports for smart contracts

          ## Network & Infrastructure

          - [Testnet Overview](https://docs.intuition.systems/guides/network/testnet): Getting started with the Intuition testnet
          - [RPC Endpoints](https://docs.intuition.systems/guides/network/testnet/rpc): Connect to Intuition network
          - [Explorer](https://docs.intuition.systems/guides/network/testnet/explorer): Browse on-chain data and transactions
          - [Bridge](https://docs.intuition.systems/guides/network/testnet/bridge): Transfer assets to Intuition network

          ## Intuition AI

          - [AI Overview](https://docs.intuition.systems/guides/intuition-ai): AI-powered features and integrations
          - [MCP Server](https://docs.intuition.systems/guides/intuition-ai/mcp-server): Model Context Protocol integration

          ## Intuition Node

          - [Node Overview](https://docs.intuition.systems/guides/intuition-node): Run your own Intuition node
          - [Setup Guide](https://docs.intuition.systems/guides/intuition-node/setup): Installation and configuration

          ## Use Cases

          - [Example Applications](https://docs.intuition.systems/guides/use-cases): Real-world applications built with Intuition
          - [Build a Portal](https://docs.intuition.systems/guides/use-cases/build-a-portal): Create custom Intuition portals

          ## Resources

          - [FAQ](https://docs.intuition.systems/guides/resources/faq): Frequently asked questions
          - [Key Terms](https://docs.intuition.systems/guides/resources/key-terms): Essential terminology and concepts
          - [Community & Support](https://docs.intuition.systems/guides/resources/community-and-support): Get help and connect with the community

          ## Contributing

          - [Contribution Guidelines](https://docs.intuition.systems/guides/contribute/contribution-guidelines): How to contribute to Intuition
          EOF

      - name: Generate llms-full.txt (comprehensive docs)
        run: |
          cat > llms-full.txt << 'EOF'
          # Intuition Protocol - Complete Documentation

          > This file contains comprehensive documentation for the Intuition protocol, including all guides, API references, and technical documentation.

          Intuition is a permissionless protocol that enables users to create attestations (atoms), make connections between concepts (triples), and signal agreement or disagreement through economic mechanisms. It creates a decentralized knowledge graph of validated information.

          EOF

          echo "" >> llms-full.txt

          # Function to convert file path to URL
          file_to_url() {
            local file="$1"
            # Remove docs/ prefix and file extension
            local path="${file#docs/}"
            path="${path%.md}"
            path="${path%.mdx}"
            # Remove index from path
            path="${path%/index}"
            echo "https://docs.intuition.systems/$path"
          }

          # Function to extract title from front matter or filename
          get_title() {
            local file="$1"
            # Try to extract title from front matter
            local title=$(awk '/^---$/,/^---$/{if($1=="title:"){$1="";print;exit}}' "$file" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
            # If no title found, use filename
            if [ -z "$title" ]; then
              title=$(basename "$file" .md .mdx | sed 's/-/ /g;s/\bindex\b//g' | awk '{for(i=1;i<=NF;i++) $i=toupper(substr($i,1,1)) tolower(substr($i,2));}1')
            fi
            echo "$title"
          }

          # Function to strip front matter and clean content
          clean_content() {
            local file="$1"
            # Two-pass approach: first remove JSX blocks, then clean line-by-line

            # Pass 1: Remove JSX comment blocks and style objects
            perl -0777 -pe '
              # Remove JSX comments {/* ... */}
              s/\{\s*\/\*.*?\*\/\s*\}//gs;

              # Remove multi-line style={{ ... }} blocks
              s/style=\{\{[^}]*?\}\}//gs;

              # Remove standalone style blocks (just the object)
              s/\{\s*\n\s*[a-zA-Z]+:\s*[^}]+\}\}>//gs;
            ' "$file" | \

            # Pass 2: Line-by-line cleaning with AWK
            awk '
            BEGIN { in_frontmatter=0; past_frontmatter=0; in_jsx_block=0; brace_count=0 }

            # Handle front matter
            /^---$/ && NR==1 { in_frontmatter=1; next }
            /^---$/ && in_frontmatter { in_frontmatter=0; past_frontmatter=1; next }
            in_frontmatter { next }

            past_frontmatter || NR>1 {
              # Skip import/export statements
              if (/^(import|export) /) next

              # Skip JSX comments
              if (/\{\/\*/ || /\*\/\}/) next

              # Detect start of JSX style blocks or fragments
              if (/^\s*(style=\{\{|[a-zA-Z]+:\s*["\x27]|backgroundColor:|padding:|margin:|border:|fontSize:|fontWeight:|display:|alignItems:|justifyContent:|flexDirection:|gap:|cursor:|overflow:|borderRadius:)/) {
                in_jsx_block=1
                next
              }

              # Track closing of JSX blocks
              if (in_jsx_block) {
                if (/\}\}>/ || /^\s*\}\}$/ || /^\s*\)$/) {
                  in_jsx_block=0
                  next
                }
                next
              }

              # Skip lines with Docusaurus CSS variables
              if (/var\(--ifm/) next

              # Skip lines that are clearly JSX
              if (/className=/ || /^<[A-Za-z]/ || /onClick=/ || /onChange=/) next
              if (/<div|<\/div|<p[> ]|<\/p>|<span|<\/span|<button|<\/button/) next

              # Skip closing JSX fragments
              if (/^\s*\}\}>?\s*$/ || /^\s*\)\s*$/) next

              # Remove any remaining inline HTML tags
              gsub(/<[^>]+>/, "")

              # Skip lines that became empty after cleanup
              if (/^[[:space:]]*$/ && prev_empty) next
              prev_empty = /^[[:space:]]*$/

              print
            }
            '
          }

          # Process all documentation files
          find docs -type f \( -name "*.md" -o -name "*.mdx" \) | sort | while read file; do
            # Skip hidden files, partials, and files starting with underscore
            if [[ "$file" == *"/_hidden/"* ]] || [[ "$file" == *"/partials/"* ]] || [[ "$(basename "$file")" == _* ]]; then
              continue
            fi

            # Check if file has actual content (not just front matter)
            content_lines=$(clean_content "$file" | grep -v '^[[:space:]]*$' | wc -l)
            if [ "$content_lines" -lt 3 ]; then
              continue
            fi

            title=$(get_title "$file")
            url=$(file_to_url "$file")

            echo "# $title" >> llms-full.txt
            echo "" >> llms-full.txt
            echo "Source: $url" >> llms-full.txt
            echo "" >> llms-full.txt
            clean_content "$file" >> llms-full.txt
            echo "" >> llms-full.txt
            echo "---" >> llms-full.txt
            echo "" >> llms-full.txt
          done

      - name: Check for changes
        id: check-changes
        run: |
          git add llms.txt llms-full.txt
          if git diff --staged --quiet; then
            echo "changes=false" >> $GITHUB_OUTPUT
          else
            echo "changes=true" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push if changed
        if: steps.check-changes.outputs.changes == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git commit -m "ðŸ¤– Auto-update llms.txt files

          Generated from documentation changes in commit ${{ github.sha }}

          Co-authored-by: GitHub Actions <action@github.com>"
          git push
