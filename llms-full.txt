# Intuition Protocol - Complete Documentation

This file contains comprehensive documentation for the Intuition protocol, including all guides, API references, and technical documentation.

## About Intuition

Intuition is a permissionless protocol that enables users to create attestations (atoms), make connections between concepts (triples), and signal agreement or disagreement through economic mechanisms. It creates a decentralized knowledge graph of validated information.


## Complete Documentation

### File: docs/docs/partials/_product-section.mdx


---

### File: docs/guides/contribute/contribution-guidelines.md


# Contribution Guidelines

Thanks for your interest in contributing to 0xIntuition! We're excited to have you join our community of builders working on the trust protocol for the internet.

Please take a moment to review this document before submitting your first pull request. We also strongly recommend that you check for open issues and pull requests to see if someone else is working on something similar.

If you need any help, feel free to reach out to [@0xintuition](https://twitter.com/0xintuition).

## General Guidelines

These guidelines apply across all Intuition repositories. Each repository may have additional specific requirements, so be sure to check the repository-specific sections below.

### Code of Conduct

By participating in this project, you agree to abide by our community standards. We expect all contributors to be respectful, inclusive, and constructive in their interactions.

### Getting Started

1. **Fork the repository** you want to contribute to
2. **Clone your fork** locally
3. **Create a new branch** for your feature or fix: `git checkout -b feature/my-new-feature`
4. **Make your changes** following the repository's coding standards
5. **Test your changes** thoroughly
6. **Commit your changes** with a descriptive message
7. **Push to your fork** and **submit a pull request**

### Commit Message Guidelines

We largely follow conventional commit format across all repositories:
- `feat: Description` - for new features
- `fix: Description` - for bug fixes
- `docs: Description` - for documentation updates
- `refactor: Description` - for code refactoring
- `test: Description` - for adding or updating tests

### Pull Request Process

Our PR process is consistent across repositories:
- Provide a clear description of what your PR does
- Reference any related issues
- Ensure all tests pass
- Be responsive to feedback during code review
- Keep PRs focused and atomic when possible

### Versioning

We follow [Semantic Versioning](https://semver.org/) (SemVer) across all our repositories:
- **MAJOR** version for incompatible API changes
- **MINOR** version for backwards-compatible functionality additions
- **PATCH** version for backwards-compatible bug fixes

## Repository-Specific Guidelines

While we maintain consistent practices across all repositories, each has specific setup requirements and workflows. **Always check the individual repository's README and CONTRIBUTING.md (if present) for detailed, repo-specific instructions.**

### intuition-ts

**Description**: TypeScript monorepo containing our SDK, UI components, API interactions, and core applications.

**What's included**:
- SDK packages for protocol and API interactions
- 1ui component library with Storybook
- Core applications and utilities

**Contributing**: This repository has comprehensive contribution guidelines. Please read the [CONTRIBUTING.md](https://github.com/0xIntuition/intuition-ts/blob/main/CONTRIBUTING.md) file for detailed instructions on:
- Monorepo structure and workspace commands
- Development setup with pnpm and Nx
- Testing requirements and changesets workflow
- Component development guidelines

### intuition-rs

**Description**: Rust workspace containing the backend infrastructure, indexing services, and data processing pipeline.

**What's included**:
- CLI tools and TUI client
- Event consumers (raw, decoded, resolver)
- Indexing services (envio-indexer, substreams-sink)
- Database models and RPC proxy
- Docker and Kubernetes deployment configurations

**Contributing**:
- Install [Rust](https://rustup.rs/) and [cargo-make](https://github.com/sagiegurari/cargo-make)
- Follow the setup instructions in the [README](https://github.com/0xIntuition/intuition-rs/blob/main/README.md)
- Run tests with `cargo nextest run`
- Use `cargo make` commands for common development tasks
- Note: This repository follows Rust-specific conventions for code style and testing

### intuition-mcp-server

**Description**: Model Context Protocol server for interacting with the Intuition knowledge graph, enabling powerful AI integrations.

**What's included**:
- HTTP stream server with MCP protocol support
- Tools for extracting triples and searching entities
- Account and relationship management APIs
- Client SDK and examples

**Contributing**:
- Requires Node.js 14+ and pnpm
- Follow setup instructions in the [README](https://github.com/0xIntuition/intuition-mcp-server/blob/main/README.md)
- Test locally with `pnpm run start:http`
- See the Contributing section in the README for MCP-specific development guidelines

### intuition-contracts-v2

**Description**: Smart contracts for Intuition V2 protocol built with Foundry, handling core protocol logic and token economics.

**What's included**:
- Core protocol smart contracts
- Deployment and migration scripts
- Comprehensive test suite
- Gas optimization and security features

**Contributing**:
- Install [Foundry](https://book.getfoundry.sh/getting-started/installation)
- Install [Bun](https://bun.sh/) for Node.js package management
- Follow setup instructions in the [README](https://github.com/0xIntuition/intuition-contracts-v2/blob/main/README.md)
- Run tests with `forge test`
- Use `forge fmt` for code formatting and `bun run lint` for linting
- Follow Solidity best practices and security guidelines for smart contract development

## Getting Help

- **GitHub Issues**: Use the Issues tab in the relevant repository for bug reports and feature requests
- **Twitter**: Follow [@0xintuition](https://twitter.com/0xintuition) for updates
- **Documentation**: Visit our [docs site](https://docs.intuition.systems) for comprehensive guides

## What to Contribute

We welcome contributions of all kinds:

- **Bug fixes** - Help us identify and resolve issues
- **Feature development** - Build new capabilities for the protocol
- **Documentation** - Improve guides, examples, and API documentation
- **Testing** - Add test coverage and improve quality assurance
- **Examples** - Create tutorials and sample applications
- **Performance** - Optimize existing code and infrastructure

Thank you for contributing to the future of decentralized trust! üöÄ

---

### File: docs/guides/developer-tools/audit-reports.mdx


# Audit Reports

## Overview

This page contains security audit reports for Intuition smart contracts. All contracts undergo rigorous security assessments before deployment.

## Latest Audit

### Security Assessment (Summary Report) - March 28, 2024

**Audit Scope**: The smart contracts audited can be found on the main branch in the repository: `intuition-tob-audit`

{/* **Audit File**: [Intuition Smart Contracts Summary Report.pdf](Intuition-_Smart_Contracts-_Summary_Report.pdf) */}

## Summary of Findings and Fixes

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="high" label="High Severity" default>

**No high severity issues found** ‚úÖ

</TabItem>

<TabItem value="medium" label="Medium Severity">

| Issue | Status | Fix |
|-------|--------|-----|
| Protocol deposit fees unaccounted for in createAtom | ‚úÖ Fixed | commit#edc4584 |
| Triple identifiers can contain hash collisions | ‚úÖ Fixed | PR#33 |
| Atom equity should be calculated on raw asset amounts | ‚úÖ Fixed | commit#028748d |
| Distributing atom equity should not include protocol fees | ‚úÖ Fixed | commit#028748d |
| Asset accounting should not be reduced by minShare | ‚úÖ Fixed | PR#36 |

</TabItem>

<TabItem value="low" label="Low Severity">

| Issue | Status | Fix |
|-------|--------|-----|
| createAtomCompressed allows creating duplicate atoms with the same URI | ‚úÖ Fixed | commit#4d0b2ba from PR#30 |
| Upgrade could lead to mismatch in atom wallet address prediction | ‚úÖ Fixed | PR#38 |
| createAtom mints sharesForZeroAddress twice | ‚úÖ Fixed | commit#edc4584 |
| EthMultiVault should not receive ether donations | ‚úÖ Fixed | PR#24 |
| Atom wallets can be created before the atom is created | ‚úÖ Fixed | PR#29 |
| Atom URI data is unbounded | ‚úÖ Fixed | PR#32 |

</TabItem>

<TabItem value="informational" label="Informational Issues">

| Issue | Status | Fix |
|-------|--------|-----|
| Salt contains superfluous address(this) | ‚úÖ Fixed | PR#27 |
| Unbound storage reads in getVaultStates | ‚úÖ Fixed | PR#25 |
| EthMultiVault is missing ERC-4626 functionality | üìù Addressed in comments | - |
| Redundant and ineffective reinitialization check | ‚úÖ Fixed | PR#28 |
| Impossible condition | ‚úÖ Fixed | PR#26 |
| Distributing atom equity should not mint new shares to receiver | ‚úÖ Fixed | PR#39 |
| getVaultStates does not retrieve counter vaults | ‚úÖ Fixed | PR#25 |
| Excessive duplicate code | ‚úÖ Fixed | PR#30 |
| Admin can bypass fee setter limits | ‚úÖ Fixed | PR#34 |
| Minting ghost shares is unnecessary to prevent share inflation attacks | üóëÔ∏è Removed from report | - |
| Code Quality | ‚úÖ Fixed | PR#40 and PR#41 |
| [Weak Maturity] Decentralization | ‚úÖ Fixed | PR#42 and PR#45 |
| [Weak Maturity] Arithmetic | üìù Addressed in comments | - |

</TabItem>
</Tabs>

---

### File: docs/guides/developer-tools/contracts/configuration.mdx


# Configurations & Fees

The Intuition protocol smart contracts utilize a configuration system that allows for dynamic adjustment of various parameters effecting the behavior of the protocol. This document outlines the key configuration parameters and fees associated with the **mainnet Intuition protocol** deployment.

The smart contract configurations and parameters can be adjusted by governance through onchain proposals, allowing for flexibility and adaptability as the protocol evolves.

## MultiVault

### Atom & Triple Creation Fees

The following fixed fees are applied when creating atoms and triples within the MultiVault:

- **Atom Creation Fee:** 0.1 TRUST <span className='text-xs'>(1e17)</span>
- **Triple Creation Fee:** 0.1 TRUST <span className='text-xs'>(1e17)</span>

### Deposit & Withdrawal Fees & Minimums

When depositing into an atom or triple, a minimum amount of TRUST is required:   

- **Minimum Deposit:** 0.01 TRUST <span className='text-xs'>(1e16)</span>

The percentage-based fees are applied to the total TRUST being deposited/withdrawn after accounting for fixed costs:

- **Entry Fee:** 50  <span className='text-xs'>(0.5% of deposit)</span>
- **Exit Fee:** 75  <span className='text-xs'>(0.75% of deposit)</span>
- **Protocol Fee:** 125  <span className='text-xs'>(1.25% of deposit)</span>
- **Atom Deposit Fraction Fee:**  90 <span className='text-xs'>(0.9% of deposit into atom from triple)</span>*

\* <span class='text-xs'>*This fee is only applied when depositing into a triple, and a portion of the deposit is allocated to the underlying atoms.*</span>

**The percentage fees are calculated using a denominator of 10,000.**

For example, if a user deposits 100 TRUST into an atom, the entry fee would be calculated as follows:

- ```Entry Fee = (50 / 10,000) * 100 TRUST = 0.5 TRUST```
- ```Protocol Fee = (125 / 10,000) * 100 TRUST = 1.25 TRUST```

The total fees for 100 TRUST deposit would be 0.5 TRUST (entry fee) + 1.25 TRUST (protocol fee) = 1.75 TRUST.

### Low-Level Configuration Parameters

The Intuition Smart Contracts also include several low-level configuration parameters that can be adjusted by governance to fine-tune the protocol's behavior. These parameters include:

- **Fee Denominator:** 10000
- **Minimum Shares** : 1e6 <span className='text-xs'>(1,000,000 WEI)</span>
- **Atom Data Max Length:** 1000


## TrustBonding & EmissionsController

The TrustBonding, BaseEmissionsController and SatelliteEmissionsController all share the same configuration parameters for emissions. This allows for a consistent emission schedule across the protocol, even though new TRUST tokens are minted on the Base (8453) network and released on the Intuition (1155) network.

- **Emissions Per Epoch:** 2,884,615.3846 <span className='text-xs'>(approx 2.88 million TRUST every two weeks for the first year)</span>
- **Emissions Start Timestamp:** 1762268400 <span className='text-xs'>(Tues November 4, 2025 10:00:00 EST)</span>
- **Emissions Length:** 1209600 <span className='text-xs'>(Two Weeks)</span>
- **Emissions Reduction Points:** 1000 <span className='text-xs'>(10%)</span>
- **Emissions Reduction Cliff:** 26 <span className='text-xs'>(1 year i.e. two weeks x 26)</span>\*

\* <span class='text-xs'> *The emissions reduction cliff indicates that after every 26 emission periods (i.e. every year), the emissions will reduce by the specified reduction points (10%). For example, if the initial emissions are 1000 TRUST per period, after one year (26 periods), the emissions will reduce to 900 TRUST per period.* </span>

## OffsetProgressiveCurve

The Offset Progressive Curve is used to calculate the amount of shares minted when a user deposits. The curve is defined by the following parameters:

- **Offset:** 1e17
- **Slope:** 3e19 

The OffsetProgressiveCurve parameters are fixed and cannot be changed by governance.

---

### File: docs/guides/developer-tools/contracts/contract-migration.mdx


# Migrating from 2.0 to 2.1 Smart Contracts

## MultiVault

### Last Active Epoch is now User Epoch History

The `lastActiveEpoch` mapping in the `MultiVault` contract has been replaced with a more comprehensive `userEpochHistory` mapping. This new mapping tracks up 3 epochs in which each user has been active.

**Previous:**
```solidity
mapping(address => uint256) public lastActiveEpoch;
```


**Current:**
```solidity
mapping(address => uint256[3]) public userEpochHistory;
```

To get the last active epoch of a user, you can now use the following function:

```solidity
function getUserLastActiveEpoch(address user) external view returns (uint256) {
    return userEpochHistory[user][0];
}
```

### MultiVault Config

The `GeneralConfig` struct has been updated to include a new parameter `feeThreshold` and remove the `decimalPrecision` parameter.

```solidity
struct GeneralConfig {
    address admin;
    address protocolMultisig;
    uint256 feeDenominator;
    address trustBonding;
    uint256 minDeposit;
    uint256 minShare;
    uint256 atomDataMaxLength;
    uint256 feeThreshold;
}
```

Previously the `GeneralConfig` struct contained the `decimalPrecision` parameter that has been removed in this version.

```solidity
struct GeneralConfig {
    address admin;
    address protocolMultisig;
    uint256 feeDenominator;
    address trustBonding;
    uint256 minDeposit;
    uint256 minShare;
    uint256 atomDataMaxLength;
    uint256 decimalPrecision;
}
```

The `getGeneralConfig` function now reflects the updated `GeneralConfig` struct:

```solidity
function getGeneralConfig() external view returns (GeneralConfig memory);
```

### Triple Config

The `tripleConfig` struct has been updated to include only two parameters: `tripleCreationProtocolFee` and `atomDepositFractionForTriple`.

```solidity
struct TripleConfig {
    uint256 tripleCreationProtocolFee;
    uint256 atomDepositFractionForTriple;
}
```

Previously the `tripleConfig` struct contained `totalAtomDepositsOnTripleCreation` parameters that have been removed in this version.

```solidity
struct TripleConfig {
    uint256 tripleCreationProtocolFee;
    uint256 totalAtomDepositsOnTripleCreation;
    uint256 atomDepositFractionForTriple;
}
```

The `getTripleConfig` return value now reflects the updated `TripleConfig` struct:

```solidity
getTripleConfig() external view returns (TripleConfig memory);
```

# Bonding Curves

## Offset Progressive Curve

The `OffsetProgressiveCurve.sol` contract no longer auto-scales the `slope` parameter during initialization. The `slope` parameter should now be provided in its scaled form.

**Previous:**
```solidity
SLOPE=2;
```

**Current:**
```solidity
SLOPE=2e18;
```

---

### File: docs/guides/developer-tools/contracts/deployments.mdx


# Contract Deployments

The Intuition protocol contracts are deployed on both the Base Mainnet and the Intuition Layer 3 network, as well as their respective testnets. Below are the details of the deployed contracts, including their addresses and network configurations.

## Mainnet

### Base Mainnet

| Contract      | Address                                    |
|---------------|--------------------------------------------|
| Trust (ERC20) | 0x6cd905dF2Ed214b22e0d48FF17CD4200C1C6d8A3 |

### Intuition Mainnet (L3)

| Contract Name                 | Address                                    |
|-------------------------------|--------------------------------------------|
| WrappedTrust                  | 0x81cFb09cb44f7184Ad934C09F82000701A4bF672 |
| Upgrades TimelockController   | 0x321e5d4b20158648dFd1f360A79CAFc97190bAd1 |
| Parameters TimelockController | 0x71b0F1ABebC2DaA0b7B5C3f9b72FAa1cd9F35FEA |
| MultiVault                    | 0x6E35cF57A41fA15eA0EaE9C33e751b01A784Fe7e |
| AtomWalletFactory             | 0x33827373a7D1c7C78a01094071C2f6CE74253B9B |
| AtomWalletBeacon              | 0xC23cD55CF924b3FE4b97deAA0EAF222a5082A1FF |
| AtomWarden                    | 0x98C9BCecf318d0D1409Bf81Ea3551b629fAEC165 |
| SatelliteEmissionsController  | 0x73B8819f9b157BE42172E3866fB0Ba0d5fA0A5c6 |
| TrustBonding                  | 0x635bBD1367B66E7B16a21D6E5A63C812fFC00617 |
| BondingCurveRegistry          | 0xd0E488Fb32130232527eedEB72f8cE2BFC0F9930 |
| LinearCurve                   | 0xc3eFD5471dc63d74639725f381f9686e3F264366 |
| OffsetProgressiveCurve        | 0x23afF95153aa88D28B9B97Ba97629E05D5fD335d |
| Multicall3                    | 0xcA11bde05977b3631167028862bE2a173976CA11 |
| EntryPoint                    | 0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108 |
| SafeSingletonFactory          | 0x914d7Fec6aaC8cd542e72Bca78B30650d45643d7 |

## Testnet

### Base Sepolia Testnet

| Contract Name               | Address                                    |
|-----------------------------|--------------------------------------------|
| TestTrust                   | 0xA54b4E6e356b963Ee00d1C947f478d9194a1a210 |
| Upgrades TimelockController | 0x9099BC9fd63B01F94528B60CEEB336C679eb6d52 |
| BaseEmissionsController     | 0xC14773Aae24aA60CB8F261995405C28f6D742DCf |

### Intuition Testnet (L3)

| Contract Name                 | Address                                    |
|-------------------------------|--------------------------------------------|
| WrappedTrust                  | 0xDE80b6EE63f7D809427CA350e30093F436A0fe35 |
| Upgrades TimelockController   | 0x59B7EaB1cFA47F8E61606aDf79a6b7B5bBF1aF26 |
| Parameters TimelockController | 0xcCB113bfFf493d80F32Fb799Dca23686a04302A7 |
| MultiVault                    | 0x2Ece8D4dEdcB9918A398528f3fa4688b1d2CAB91 |
| AtomWalletFactory             | 0xa4e96c6dB8Dd3314c64bF9d0E845A4905a8705d4 |
| AtomWalletBeacon              | 0x4B0aC884843576dBA0B0fda925f202aB8b546E33 |
| AtomWarden                    | 0x040B7760EFDEd7e933CFf419224b57DFB9Eb4488 |
| SatelliteEmissionsController  | 0xD3be4d1E56866b98f30Ae6C326F14EF9c6ffBBDF |
| TrustBonding                  | 0x75dD32b522c89566265eA32ecb50b4Fc4d00ADc7 |
| BondingCurveRegistry          | 0x2AFC4949Dd3664219AA2c20133771658E93892A1 |
| LinearCurve                   | 0x6df5eecd9B14E31C98A027b8634876E4805F71B0 |
| OffsetProgressiveCurve        | 0xE65EcaAF5964aC0d94459A66A59A8B9eBCE42CbB |
| Multicall3                    | 0xcA11bde05977b3631167028862bE2a173976CA11 |
| EntryPoint                    | 0x4337084D9E255Ff0702461CF8895CE9E3b5Ff108 |

## Network Details

### Intuition Mainnet Configuration
- **Chain ID**: 1155
- **RPC URL**: `https://rpc.intuition.systems`
- **WebSocket**: `wss://rpc.intuition.systems`
- **Explorer**: `https://explorer.intuition.systems/`
- **Native Token**: $TRUST

### Intuition Testnet Configuration
- **Chain ID**: 13579
- **RPC URL**: `https://testnet.rpc.intuition.systems`
- **WebSocket**: `wss://testnet.rpc.intuition.systems`
- **Explorer**: `https://testnet.explorer.intuition.systems/`
- **Native Token**: $tTRUST

### Base Sepolia Configuration
- **Chain ID**: 84532
- **RPC URL**: `https://sepolia.base.org`
- **Explorer**: `https://sepolia.basescan.org`
- **Native Token**: ETH

### Base Sepolia Configuration
- **Chain ID**: 8453
- **RPC URL**: `https://mainnet.base.org`
- **Explorer**: `https://basescan.org`
- **Native Token**: ETH

## Verified Contracts

All deployed contracts are verified on their respective block explorers. You can view the source code and interact with the contracts directly through the explorer interfaces.

## Contract ABIs

Contract ABIs can be found in the following locations:
- **npm package**: `@0xintuition/protocol`
- **GitHub**: [0xIntuition/intuition-contracts-v2](https://github.com/0xIntuition/intuition-contracts-v2)
- **Block Explorer**: Available on verified contract pages

---

### File: docs/guides/developer-tools/contracts/multivault.mdx


# MultiVault.sol

The MultiVault contract is the core economic engine of the Intuition protocol, managing deposits, redemptions, and creation of atoms and triples. It implements a sophisticated vault system that supports multiple bonding curves and provides the foundation for the protocol's economic incentives.

The MultiVault is the primary interface for users to interact with the economic aspects of atoms and triples:


### Atom IDs
Atom IDs are generated using a hash function that hashes the Atom's data.

```solidity
function calculateAtomId(bytes memory data) public pure returns (bytes32 id) {
    return keccak256(abi.encodePacked(data));
}
```

### Triple IDs
Triple IDs are generated using a hash function that hashes the subject, predicate, and object Atom IDs.

```solidity
function calculateTripleId(
    bytes32 subjectId,
    bytes32 predicateId,
    bytes32 objectId
) public pure returns (bytes32 id) {
    return keccak256(abi.encodePacked(subjectId, predicateId, objectId));
}
```

## Smart Contract Writes
The MultiVault contract allows users to create new terms, plus deposit and redeem assets.

### Creating Atoms
An Atom represents an entity within the Intuition ecosystem and is identified by a unique `bytes32` identifier. Atoms can represent objects, individuals, organizations, or any other entity type. Atom data is stored onchain and also emitted for caching/indexing using the `AtomCreated` event.

Any user can create an Atom by calling the `createAtoms` function on the MultiVault contract.

```solidity
function createAtoms(
        bytes[] calldata data,
        uint256[] calldata assets
    )
        external
        payable
        returns (bytes32[] memory)
    {
    // Atom creation logic
}
```
The function accepts an array of Atom data and an array of asset amounts, allowing for the creation of multiple Atoms in a single transaction.

Creating an Atom requires a fee payment, which is paid in the native blockchain currency (e.g., TRUST on the Intuition Network). In addition to the fee, users can also deposit TRUST tokens when creating an Atom. This deposit acts as a signal, ensuring that users have a vested interest in the integrity of the Atom they are creating.


### Creating Triples
A Triple represents a claim or statement. A triple is structured using a **subject-predicate-object** relationship. For example, in the triple "Alice is a friend of Bob", "Alice" is the subject, "is a friend of" is the predicate, and "Bob" is the object.

```solidity
function createTriples(
    bytes32[] calldata subjectIds,
    bytes32[] calldata predicateIds,
    bytes32[] calldata objectIds,
    uint256[] calldata assets
)
    external
    payable
    whenNotPaused
    nonReentrant
    returns (bytes32[] memory)
{
    // Triple creation logic
}
```

### Deposit
Deposits are made in the native blockchain currency (e.g., TRUST). Users can also batch multiple deposits or redemptions into a single transaction for efficiency.

The `deposit` function allows users to deposit assets into a specific term and bonding curve. The user specifies the receiver address, term ID, curve ID, and minimum shares they expect to receive.

The `msg.value` sent with the transaction represents the amount of assets being deposited.

```solidity
function deposit(
    address receiver,
    bytes32 termId,
    uint256 curveId,
    uint256 minShares
)
    external
    payable
    whenNotPaused
    nonReentrant
    returns (uint256)
{
    /// Deposit logic
}
```

### Batch Deposit
The `depositBatch` function allows users to make multiple deposits in a single transaction. The user provides arrays of receiver addresses, term IDs, curve IDs, and minimum shares for each deposit.

The `msg.value` sent with the transaction represents the total amount of assets being deposited across all specified deposits. The sum of `assets` must equal `msg.value`.

```solidity
function depositBatch(
    address receiver,
    bytes32[] calldata termIds,
    uint256[] calldata curveIds,
    uint256[] calldata assets,
    uint256[] calldata minShares
)
    external
    payable
    whenNotPaused
    nonReentrant
    returns (uint256[] memory shares)
{
    /// Batch deposit logic
}
```

### Redeem

The `redeem` function allows users to redeem their shares for the underlying assets. The user specifies the receiver address, term ID, curve ID, and the number of shares they want to redeem.

```solidity
function redeem(
    address receiver,
    bytes32 termId,
    uint256 curveId,
    uint256 shares,
    uint256 minAssets
)
    external
    whenNotPaused
    nonReentrant
    returns (uint256)
{
    /// Redemption logic
}
```

### Batch Redeem

The `redeemBatch` function allows users to redeem shares from multiple terms and curves in a single transaction. The user provides arrays of term IDs, curve IDs, shares to redeem, and minimum assets they expect to receive for each redemption.

```
function redeemBatch(
    address receiver,
    bytes32[] calldata termIds,
    uint256[] calldata curveIds,
    uint256[] calldata shares,
    uint256[] calldata minAssets
)
    external
    whenNotPaused
    nonReentrant
    returns (uint256[] memory received)
{
    /// Batch redemption logic
}
```

## Smart Contract Reads

### Is Term Created

The `isTermCreated` function checks if a specific term has been created in the MultiVault.

```solidity
function isTermCreated(bytes32 termId) external view returns (bool) {
    // Term existence logic
}
```

### Current Share Price
The `currentSharePrice` function returns the current share price for a given term and bonding curve.

```solidity
function currentSharePrice(bytes32 termId, uint256 curveId) external view returns (uint256) {
    // Share price calculation logic
}
```

### Preview Atom Create
The `previewAtomCreate` function allows users to preview the cost of creating an Atom with a given set of data.

```solidity
function previewAtomCreate(
    bytes32 termId,
    uint256 curveId,
    uint256 assets
)
    external
    view
    returns (uint256 shares, uint256 assetsAfterFixedFees, uint256 assetsAfterFees)
{
    // Atom creation cost preview logic
}
```

### Preview Triple Create
The `previewTripleCreate` function allows users to preview the cost of creating a Triple with given subject, predicate, and object IDs.

```solidity
function previewTripleCreate(
    bytes32 termId,
    uint256 curveId,
    uint256 assets
)
    external
    view
    returns (uint256 shares, uint256 assetsAfterFixedFees, uint256 assetsAfterFees)
{
    // Triple creation cost preview logic
}
```

### Preview Deposit
The `previewDeposit` function allows users to preview the number of shares they would receive for a deposit of a given amount of assets into a specific term and bonding curve.

```solidity
function previewDeposit(
    bytes32 termId,
    uint256 curveId,
    uint256 assets
)
    public
    view
    returns (uint256 shares, uint256 assetsAfterFees)
{
    // Deposit preview logic
}
```

### Preview Redeem
The `previewRedeem` function allows users to preview the amount of assets they would receive for redeeming a given number of shares from a specific term and bonding curve.

```solidity
function previewRedeem(
    bytes32 termId,
    uint256 curveId,
    uint256 shares
)
    public
    view
    returns (uint256 assetsAfterFees, uint256 sharesUsed)
{
    // Redemption preview logic
}
```

## Events
The MultiVault contract emits a number of different events to track key actions:

- `AtomCreated`: Emitted when a new Atom is created.
- `TripleCreated`: Emitted when a new Triple is created.
- `Deposited`: Emitted when a deposit is made.
- `Redeemed`: Emitted when shares are redeemed for assets.
- `SharePriceChanged`: Emitted when the share price for a term and curve changes.

### AtomCreated
```solidity
event AtomCreated(
    address indexed creator,
    bytes32 indexed termId,
    bytes data
);
```

### TripleCreated
```solidity
event TripleCreated(
    address indexed creator,
    bytes32 indexed tripleId,
    bytes32 subjectId,
    bytes32 predicateId,
    bytes32 objectId
);
```

### Deposited
```solidity
event Deposited(
    address indexed sender,
    address indexed receiver,
    bytes32 indexed termId,
    uint256 curveId,
    uint256 assets,
    uint256 assetsAfterFees,
    uint256 shares,
    uint256 totalShares,
    VaultType vaultType
);
```

### Redeemed
```solidity
event Redeemed(
    address indexed sender,
    address indexed receiver,
    bytes32 indexed termId,
    uint256 curveId,
    uint256 shares,
    uint256 totalShares,
    uint256 assets,
    uint256 fees,
    VaultType vaultType
);
```

### SharePriceChanged
```solidity
event SharePriceChanged(
    bytes32 indexed termId,
    uint256 indexed curveId,
    uint256 sharePrice,
    uint256 totalAssets,
    uint256 totalShares,
    VaultType vaultType
);
```

## Additional Resources

For more detailed information on the MultiVault contract and its functions, please refer to the [Intuition Smart Contract V2 repository](https://github.com/0xIntuition/intuition-contracts-v2).

---

### File: docs/guides/developer-tools/contracts/overview.mdx


# Contract Architecture Overview

Intuition's smart contracts are central to the user experience, handling critical onchain activities such as the creation of Atoms (also known as Identities) and Triples (also known as Claims), as well as the staking and rewards.

# MultiVault

The MultiVault contract is the core component of Intuition's architecture, responsible for managing the creation of Atoms/Triples and handling deposits, redemptions, and share distributions. It supports multiple bonding curve implementations through a registry system.

- **Creation**: Users can create Atoms and Triples
- **Deposits**: Users can deposit ETH to receive shares in atoms/triples
- **Redemptions**: Users can redeem shares for ETH
- **Multi-Vault**: Supports multiple bonding curve implementations
- **Share Distribution**: Manages the minting and burning of shares
- **Fee Collection**: Collects small fees to maintain the system

# Trust Token
The Trust Token contract is an ERC-20 compliant token that serves as the native utility token within the Intuition ecosystem. It is used for deposits, staking, governance, and accessing various features of the platform. 

- **ERC-20 Compliance**: Fully compliant with the ERC-20 standard
- **Minting and Burning**: Controlled minting and burning of tokens
- **Transfers**: Standard token transfer functionality

The Trust Token contract is **deployed on Base** and is the **native gas token on the Intuition Network L3 chain**.

# Wrapped Trust
The Wrapped Trust contract is an ERC-20 compliant token that lives on the Intuition Network L3 chain. After users bridge their Trust tokens from Base to the Intuition Network L3 chain, they can receive Wrapped Trust tokens by depositing Trust tokens into the Wrapped Trust contract.

**Wrapped Trust tokens can be used for staking in the Trust Bonding contract.**


# Trust Bonding
The Trust Bonding contract is a smart contract introduced in V2. Inheriting from the Curve VotingEscrow contract, it enables staking of Wrapped Trust to earn rewards and participate in governance. Key features include:

- **Staking**: Users can stake Wrapped Trust to earn rewards
- **Locking**: Users can lock their stake for a specified duration to increase voting power
- **Rewards**: Users earn rewards based on their stake and lock duration
- **Governance**: Stakers can participate in governance decisions

# Bonding Curve Registry
The Bonding Curve Registry contract is a registry for bonding curve implementations. It allows the MultiVault contract to look up and use different bonding curve implementations. Key features include:

- **Registration**: Developers can register new bonding curve implementations
- **Lookup**: The MultiVault contract can look up bonding curve implementations by ID
- **Management**: The registry can be managed by the contract owner

# BaseEmissionsController
The BaseEmissionsController contract is responsible for managing the emissions of Trust tokens. It controls the rate at which new Trust tokens are minted and distributed to stakers in the Trust Bonding contract. Key features include:

- **Emission Rate**: Controls the rate of Trust token emissions
- **Distribution**: Distributes newly minted Trust tokens to the SatelliteEmissionsController
- **Bridging**: Uses the Caldera MetaLayer protocol to bridge emissions to the Intuition Network L3 chain

# SatelliteEmissionsController
The SatelliteEmissionsController contract is responsible for managing the emissions of Trust tokens on the Intuition Network L3 chain. It receives emissions from the BaseEmissionsController and distributes them to stakers via the Trust Bonding contract. Key features include:

- **Receiving Emissions**: Receives Trust token emissions from the BaseEmissionsController
- **Distribution**: Distributes Trust tokens to stakers via the Trust Bonding contract
- **Bridging/Burning**: Uses the Caldera MetaLayer protocol to bridge/burn emissions back to Base

---

### File: docs/guides/developer-tools/contracts/trust-bonding.mdx


# TrustBonding.sol

The TrustBonding contract is the primary smart contract for bonding/staking of TRUST tokens within the Intuition protocol. Responsible for managing emissions of new TRUST tokens for various stakeholders, including atom creators, triple creators, and other participants in the ecosystem.

### Wrapped Trust (wTRUST)
The TrustBonding contract requires users to wrap their TRUST tokens into Wrapped TRUST (wTRUST) before locking them in the voting escrow. This wrapping process is handled by the `WrappedTrust` contract, which allows users to deposit TRUST tokens and receive an equivalent amount of wTRUST tokens.


### Voting Escrow (veTRUST)
The TrustBonding contract inherits from the popular Voting Escrow mechanism, allowing users to lock their TRUST tokens for a specified period in exchange for veTRUST tokens. These veTRUST tokens represent voting power and can be used to influence governance decisions within the Intuition protocol.

The voting escrow mechanism is implemented using the `VotingEscrow` contract, which provides functions for creating locks, increasing lock amounts, and extending lock durations.

Originated from Curve Finance's veCRV model, originally written in Vyper, the Voting Escrow contract has been adapted to Solidity for use in the Intuition protocol and forked from the Stargate DAO's [implementation](https://github.com/stargate-protocol/stargate-dao/blob/main/contracts/VotingEscrow.sol).

## Smart Contract Writes

### Creating Locks
Users can create a new lock by calling the `create_lock` function, specifying the amount of Wrapped TRUST tokens to lock and the duration of the lock.

```solidity
function create_lock(uint256 _value, uint256 _unlock_time) external nonReentrant onlyUserOrWhitelist notUnlocked {
    // Lock creation logic
}
```

### Increasing Lock Amount
Users can increase the amount of Wrapped TRUST tokens in an existing lock by calling the `increase_amount` function.

```solidity
function increase_amount(uint256 _value) external nonReentrant onlyUserOrWhitelist notUnlocked {
    // Lock amount increase logic
}
```

### Increasing Lock Duration
Users can extend the duration of an existing lock by calling the `increase_unlock_time` function.

```solidity
function increase_unlock_time(uint256 _unlock_time) external nonReentrant onlyUserOrWhitelist notUnlocked {
    // Lock duration extension logic
}
```

### Increase Amount and Duration
Users can simultaneously increase the amount of Wrapped TRUST tokens and extend the duration of an existing lock by calling the `increase_amount_and_duration` function.

```solidity
function increase_amount_and_duration(uint256 _value, uint256 _unlock_time) external nonRentrant onlyUserOrWhitelist notUnlocked {
    // Lock amount and duration increase logic
}
```

### Withdraw
Once the lock period has expired, users can withdraw their locked Wrapped TRUST tokens by calling the `withdraw` function.

```solidity
function withdraw() external nonReentrant onlyUserOrWhitelist {
    // Withdrawal logic
}
```

## Smart Contract Reads

### Balance Of
The `balanceOf` function returns the voting power of a specific address at a given timestamp.

```solidity
function balanceOf(address _addr) external view returns (uint256) {
    // Balance calculation logic
}
```

### Balance Of At Timestamp
The `balanceOfAtT` function returns the voting power of a specific address at a given timestamp.

```solidity
function balanceOfAt(address _addr, uint256 _t) external view returns (uint256) {
    // Balance calculation logic
}
```

### Total Supply
The `totalSupply` function returns the total voting power in the system at a given timestamp.

```solidity
function totalSupply() external view returns (uint256) {
    // Total supply calculation logic
}
```

### Total Supply At Timestamp
The `totalSupplyAtT` function returns the total voting power in the system at a given timestamp.

```solidity
function totalSupplyAtT(uint256 t) external view returns (uint256) {
    // Total supply calculation logic
}
```

## Events

### Rewards Claimed
The `RewardsClaimed` event is emitted when a user claims their rewards.

```solidity
event RewardsClaimed(address indexed user, address indexed recipient, uint256 amount);
``` 

## Additional Resources

For more detailed information on the MultiVault contract and its functions, please refer to the [Intuition Smart Contract V2 repository](https://github.com/0xIntuition/intuition-contracts-v2).

---

### File: docs/guides/developer-tools/deep-dive/architecture.mdx


# Technical Architecture

Intuition's architecture consists of three tightly integrated layers that work together to create a high-performance, decentralized knowledge graph. This document provides a technical deep-dive into each layer and how they interconnect.

## Architecture Overview

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-100)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem',
  margin: '2rem 0',
  borderLeft: '4px solid var(--ifm-color-primary)'
}}>

![Intuition System Overview](/img/intuition-intro.png)

Intuition's architecture is designed for **speed**, **scale**, and **interoperability**. By separating concerns across three specialized layers, we achieve optimal performance while maintaining decentralization and cross-chain compatibility.

</div>

```mermaid
graph TB
    subgraph "Application Layer"
        SDK[TypeScript SDK]
        API[GraphQL/REST APIs]
        APPS[dApps & Integrations]
    end

    subgraph "Rust Subnet"
        INDEX[Indexing Engine]
        TRANSFORM[Data Transformer]
        CACHE[Cache Layer]
        QUERY[Query Engine]
    end

    subgraph "Intuition Protocol"
        VAULT[EthMultiVault]
        ATOM[AtomWallet]
        CURVE[Bonding Curves]
    end

    subgraph "Intuition Network"
        L3[Base L3 - Orbit Stack]
        METALAYER[Metalayer Standards]
        METATOKEN[Metatoken Bridge]
    end

    SDK --> API
    API --> QUERY
    QUERY --> CACHE
    CACHE --> TRANSFORM
    TRANSFORM --> INDEX
    INDEX --> VAULT
    VAULT --> L3
    ATOM --> L3
    CURVE --> L3
    L3 --> METALAYER
    L3 --> METATOKEN

    style L3 fill:#e1f5fe
    style VAULT fill:#fff3e0
    style INDEX fill:#e8f5e9
```

## Layer 1: Intuition Network (Base L3)

### Overview

The Intuition Network is an **EVM-compatible Layer 3** built on Base using the Orbit stack. This provides the ultra-fast, low-cost transaction environment essential for high-frequency knowledge graph operations.

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '1rem',
  margin: '1rem 0'
}}>

### Why Layer 3?

Traditional L1s and even L2s are too expensive and slow for the granular operations required by a knowledge graph. Every atom creation, triple attestation, and signal update needs to be economically viable. The L3 architecture provides:

- **Sub-cent transaction costs** - Making micro-attestations economically feasible
- **Sub-second finality** - Enabling real-time knowledge graph updates
- **Massive throughput** - Supporting millions of daily knowledge operations
- **EVM compatibility** - Leveraging existing tooling and developer knowledge

</div>

### Technical Specifications

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
  gap: '1rem',
  margin: '1.5rem 0'
}}>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1rem'
}}>

**Performance**
- Block time: ~250ms
- Transaction throughput: 10,000+ TPS
- Finality: < 1 second
- Gas costs: < $0.001 per tx

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1rem'
}}>

**Stack Components**
- **Base Layer**: Orbit framework on Base
- **Consensus**: Optimistic rollup with fraud proofs
- **Execution**: EVM-compatible runtime
- **Data Availability**: Base for settlement

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1rem'
}}>

**Interoperability**
- **Metalayer**: Cross-chain messaging protocol
- **Metatoken**: Unified token standard
- **Bridge**: Native Base ‚Üî L3 bridge
- **Standards**: ERC-1155, ERC-4626, ERC-4337

</div>

</div>

### Cross-Chain Interoperability

The Network leverages **Caldera's Metalayer and Metatoken standards** for seamless cross-chain operations:

```solidity
// Example: Cross-chain atom reference
interface IMetalayerBridge {
    function attestCrossChain(
        uint256 chainId,
        uint256 atomId,
        bytes calldata data
    ) external returns (bytes32 messageId);

    function resolveAtom(
        uint256 chainId,
        uint256 atomId
    ) external view returns (string memory uri);
}
```

This enables atoms and triples to reference data across any supported chain, creating a truly interoperable knowledge graph.

## Layer 2: Intuition Protocol (On-Chain Logic)

### Overview

The Intuition Protocol implements all on-chain logic for the knowledge graph through a suite of smart contracts. This is where atoms are created, triples are formed, and economic incentives are enforced.

### Core Contract Architecture

<div style={{
  backgroundColor: 'var(--ifm-background-surface-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem',
  margin: '1.5rem 0'
}}>

#### **EthMultiVault**
The economic engine managing all vault operations:

```solidity
contract EthMultiVault {
    // Core vault operations
    function deployVault(uint256 atomId) external returns (address vault);
    function deposit(uint256 vaultId, uint256 amount) external;
    function redeem(uint256 vaultId, uint256 shares) external;

    // Bonding curve integration
    function calculatePrice(uint256 supply) public view returns (uint256);
    function calculateShares(uint256 deposit, uint256 totalSupply) external view;
}
```

**Key Features:**
- Automated vault deployment for atoms/triples
- Dynamic pricing via bonding curves
- Share-based ownership model
- Fee distribution to stakers

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-surface-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem',
  margin: '1.5rem 0'
}}>

#### **AtomWallet**
Primary interface for creating and managing knowledge graph primitives:

```solidity
contract AtomWallet {
    // Atom operations
    function createAtom(string memory uri) external returns (uint256 atomId);

    // Triple operations
    function createTriple(
        uint256 subjectId,
        uint256 predicateId,
        uint256 objectId
    ) external returns (uint256 tripleId);

    // Signal operations
    function depositAtom(uint256 atomId, uint256 amount) external;
    function depositTriple(uint256 tripleId, uint256 amount, bool isPositive) external;
}
```

**Key Features:**
- Gas-efficient batch operations
- Account abstraction support (ERC-4337)
- Multi-signature capabilities
- Upgradeable proxy pattern

</div>

### Economic Mechanics

The Protocol implements sophisticated economic incentives:

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
  gap: '1rem',
  margin: '1.5rem 0'
}}>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '1rem'
}}>

**Bonding Curves**
- Automated price discovery
- Early adopter rewards
- Exponential growth model
- Anti-manipulation mechanics

</div>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '1rem'
}}>

**Fee Distribution**
- Creator fees: 5% of deposits
- Protocol fees: 2% of deposits
- Staker rewards: Proportional shares
- Compound interest mechanics

</div>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '1rem'
}}>

**Vault Mechanics**
- Positive/negative signal vaults
- Automatic liquidity provision
- Rage quit protection
- Time-weighted averaging

</div>

</div>

### State Management

The Protocol maintains the complete on-chain state of the knowledge graph:

```typescript
interface OnChainState {
  atoms: Map<number, {
    id: number;
    uri: string;
    vault: address;
    creator: address;
    timestamp: number;
  }>;

  triples: Map<number, {
    id: number;
    subjectId: number;
    predicateId: number;
    objectId: number;
    vaultFor: address;
    vaultAgainst: address;
  }>;

  signals: Map<address, Map<number, {
    shares: bigint;
    lastUpdate: number;
  }>>;
}
```

## Layer 3: Rust Subnet (Off-Chain Infrastructure)

### Overview

The Rust Subnet is Intuition's high-performance off-chain infrastructure that indexes on-chain state, resolves off-chain data references, and serves the unified knowledge graph through APIs.

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-100)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem',
  margin: '1.5rem 0',
  borderLeft: '4px solid var(--ifm-color-primary)'
}}>

**Why Rust?**

The Subnet is built in Rust for maximum performance and reliability:
- **Memory safety** without garbage collection
- **Concurrent processing** for parallel indexing
- **Zero-cost abstractions** for efficient data structures
- **WebAssembly compatibility** for edge deployment

</div>

### Core Components

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
  gap: '1.5rem',
  margin: '2rem 0'
}}>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem'
}}>

#### **Event Processing Pipeline**

Processes blockchain events through multiple stages:

```rust
// Consumer modes for different processing stages
pub enum ConsumerMode {
    Raw(RawConsumerContext),           // Raw event ingestion
    Decoded(DecodedConsumerContext),   // Event decoding
    Resolver(ResolverConsumerContext), // Data resolution
}

impl ConsumerMode {
    pub async fn process_message(&self, message: String) -> Result<(), ConsumerError> {
        match self {
            ConsumerMode::Raw(context) => {
                self.raw_message_store_and_relay(message, context).await
            }
            ConsumerMode::Decoded(context) => {
                self.handle_decoded_message(message, context).await
            }
            ConsumerMode::Resolver(context) => {
                self.handle_resolved_message(message, context).await
            }
        }
    }
}
```

- Real-time event processing through SQS queues
- Multi-stage pipeline (Raw ‚Üí Decoded ‚Üí Resolved)
- Chain reorganization handling
- Parallel processing across consumers

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem'
}}>

#### **Data Resolver**

Resolves and enriches on-chain references with off-chain data:

```rust
pub struct ResolverConsumerContext {
    pub client: Arc<dyn BasicConsumer>,
    pub image_guard_url: String,
    pub ipfs_resolver: IPFSResolver,
    pub mainnet_client: Arc<ENSRegistryInstance<Http<Client>, RootProvider<Http<Client>>>>,
    pub pg_pool: PgPool,
    pub reqwest_client: reqwest::Client,
}

impl ResolverConsumerContext {
    pub async fn resolve_atom_data(&self, atom_uri: &str) -> Result<ResolvedData, ConsumerError> {
        match atom_uri {
            uri if uri.starts_with("ipfs://") => {
                self.ipfs_resolver.fetch_content(uri).await
            }
            uri if uri.starts_with("http") => {
                self.reqwest_client.get(uri).send().await?.json().await
            }
            addr if is_ethereum_address(addr) => {
                self.resolve_ens_name(addr).await
            }
        }
    }
}
```

- IPFS content resolution via Pinata
- HTTP/HTTPS metadata fetching
- ENS name resolution on mainnet
- Image validation through image-guard service

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem'
}}>

#### **Database Integration**

Processes and stores structured data for API consumption:

```rust
pub struct DecodedConsumerContext {
    pub base_client: Arc<EthMultiVaultInstance<Http<Client>, RootProvider<Http<Client>>>>,
    pub pg_pool: PgPool,
    pub backend_schema: String,
}

impl DecodedConsumerContext {
    pub async fn handle_decoded_message(&self, message: DecodedMessage) -> Result<(), ConsumerError> {
        match &message.body {
            EthMultiVaultEvents::AtomCreated(atom_data) => {
                atom_data.handle_atom_creation(self, &message).await?;
            }
            EthMultiVaultEvents::TripleCreated(triple_data) => {
                triple_data.handle_triple_creation(self, &message).await?;
            }
            EthMultiVaultEvents::Deposited(deposit_data) => {
                deposit_data.handle_deposit_creation(self, &message).await?;
            }
        }
        Ok(())
    }
}
```

- PostgreSQL with Hasura GraphQL layer
- Real-time event storage and indexing
- Complex relationship mapping
- Optimized queries with database migrations

</div>

</div>

### Data Pipeline

The Subnet implements a sophisticated data pipeline:

```mermaid
graph LR
    subgraph "Input"
        CHAIN[Chain Events]
        IPFS[IPFS Data]
        HTTP[HTTP Sources]
    end

    subgraph "Processing"
        INDEX[Indexer]
        VALIDATE[Validator]
        TRANSFORM[Transformer]
        ENRICH[Enricher]
    end

    subgraph "Storage"
        GRAPH[Graph DB]
        SEARCH[Search Index]
        CACHE[Redis Cache]
    end

    subgraph "Output"
        GQL[GraphQL API]
        REST[REST API]
        WS[WebSocket]
    end

    CHAIN --> INDEX
    IPFS --> TRANSFORM
    HTTP --> TRANSFORM
    INDEX --> VALIDATE
    VALIDATE --> TRANSFORM
    TRANSFORM --> ENRICH
    ENRICH --> GRAPH
    ENRICH --> SEARCH
    GRAPH --> CACHE
    CACHE --> GQL
    CACHE --> REST
    CACHE --> WS
```

### API Layer

The Subnet exposes multiple API interfaces:

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
  gap: '1rem',
  margin: '1.5rem 0'
}}>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '1rem'
}}>

**GraphQL API**
```graphql
query GetAtomWithTriples {
  atom(id: "123") {
    uri
    vault {
      totalStaked
      sharePrice
    }
    triplesAsSubject {
      predicate { uri }
      object { uri }
      signal
    }
  }
}
```

</div>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '1rem'
}}>

**REST API**
```http
GET /api/v1/atoms/123
GET /api/v1/triples?subject=123
POST /api/v1/search
WebSocket /ws/subscriptions
```

</div>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '1rem'
}}>

**Real-time Subscriptions**
```typescript
subscription OnAtomUpdate {
  atomUpdated(id: "123") {
    signal
    lastActivity
    vaultBalance
  }
}
```

</div>

</div>

## Data Flow Architecture

### Transaction Lifecycle

Understanding how data flows through the system is crucial for developers:

<div style={{
  backgroundColor: 'var(--ifm-background-surface-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '12px',
  padding: '2rem',
  margin: '2rem 0'
}}>

1. **User Action** ‚Üí SDK creates transaction
2. **Network Processing** ‚Üí L3 validates and includes in block
3. **Protocol Execution** ‚Üí Smart contracts update state
4. **Event Emission** ‚Üí Contracts emit events
5. **Subnet Indexing** ‚Üí Events processed and indexed
6. **Data Resolution** ‚Üí Off-chain data fetched and cached
7. **API Response** ‚Üí Unified data served to applications

**Average End-to-End Latency: < 2 seconds**

</div>

### State Synchronization

The system maintains consistency across all layers:

```typescript
interface SyncStrategy {
  // Real-time sync for recent blocks
  realtimeSync: {
    blockLag: 2,
    confirmations: 1,
    retryPolicy: ExponentialBackoff
  };

  // Batch sync for historical data
  batchSync: {
    chunkSize: 1000,
    parallelWorkers: 10,
    checkpointInterval: 100
  };

  // Consistency checks
  validation: {
    stateRootVerification: true,
    periodicReconciliation: '1h',
    alertThreshold: 0.001 // 0.1% discrepancy
  };
}
```

## Performance Optimizations

### Caching Strategy

Multi-layer caching for optimal performance:

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
  gap: '1rem',
  margin: '1.5rem 0'
}}>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '0.75rem'
}}>

**L1: CDN Edge Cache**
- Static content
- Popular queries
- 5-minute TTL

</div>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '0.75rem'
}}>

**L2: Redis Cache**
- Query results
- Session data
- 1-hour TTL

</div>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '0.75rem'
}}>

**L3: Application Cache**
- Computed values
- Aggregate data
- 24-hour TTL

</div>

</div>

### Query Optimization

The Subnet employs sophisticated query optimization:

- **Query planning** - Analyzes queries to determine optimal execution path
- **Parallel execution** - Breaks queries into independent subqueries
- **Index utilization** - Maintains specialized indexes for common patterns
- **Result streaming** - Streams large results instead of loading all at once

## Security Architecture

### Smart Contract Security

- **Audited contracts** by leading security firms
- **Upgradeable proxies** with time-locked admin functions
- **Rate limiting** on sensitive operations
- **Emergency pause** functionality

### API Security

- **JWT authentication** for protected endpoints
- **Rate limiting** per API key
- **DDoS protection** at edge layer
- **Input validation** and sanitization

### Data Integrity

- **Merkle proofs** for on-chain data
- **IPFS content addressing** for immutable references
- **Signature verification** for attestations
- **Consensus validation** across indexer nodes

## Development Patterns

### Recommended Integration Flow

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-100)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem',
  margin: '2rem 0',
  borderLeft: '4px solid var(--ifm-color-primary)'
}}>

For developers building on Intuition, we recommend:

1. **Use the TypeScript SDK** for all contract interactions
2. **Query via GraphQL** for complex data needs
3. **Subscribe to WebSockets** for real-time updates
4. **Cache aggressively** at the application layer
5. **Batch operations** when possible to reduce costs

</div>

### Example: Creating and Querying Atoms

```typescript
// Using the SDK to create an atom
const atom = await intuition.createAtom({
  uri: 'ipfs://QmXoypizjW3WknFiJnKLwHCnL72vedxjQkDDP1mXWo6uco'
});

// Staking on the atom
await intuition.stake(atom.id, parseEther('100'));

// Querying via GraphQL
const query = gql`
  query GetAtom($id: ID!) {
    atom(id: $id) {
      uri
      creator
      vault {
        totalStaked
        holders
      }
      signal
    }
  }
`;

const result = await client.query({
  query,
  variables: { id: atom.id }
});
```

## Deployment Architecture

### Infrastructure Setup

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
  gap: '1rem',
  margin: '1.5rem 0'
}}>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1rem'
}}>

**Network Nodes**
- Distributed globally
- Auto-scaling groups
- Multi-region failover
- 99.99% uptime SLA

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1rem'
}}>

**Subnet Infrastructure**
- Kubernetes clusters
- Horizontal pod autoscaling
- Rolling deployments
- Blue-green releases

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1rem'
}}>

**Data Storage**
- PostgreSQL with replication
- Redis sentinel clusters
- IPFS pinning services
- S3-compatible object storage

</div>

</div>

## Next Steps

Ready to start building? Explore these resources:

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))',
  gap: '1rem',
  marginTop: '2rem'
}}>

<div style={{
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '6px',
  padding: '1rem',
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[Smart Contracts](/docs/developer-tools/contracts)** - Deep dive into Protocol contracts

</div>

<div style={{
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '6px',
  padding: '1rem',
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[GraphQL API](/docs/developer-tools/graphql-api)** - Learn the query interface

</div>

<div style={{
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '6px',
  padding: '1rem',
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[SDK Guide](/docs/developer-tools/sdks)** - Start building applications

</div>

<div style={{
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '6px',
  padding: '1rem',
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[Deployments](/docs/developer-tools/contracts/deployments)** - Contract addresses

</div>

</div>

---

### File: docs/guides/developer-tools/graphql-api/custom-queries.mdx


# Custom Queries

This page provides practical examples of common GraphQL queries for the Intuition API.

## Best Practices

1. **Use Fragments**: Create reusable fragments for common fields
2. **Optimize Queries**: Only request the fields you need
3. **Handle Errors**: Always implement proper error handling
4. **Cache Strategically**: Use React Query's caching capabilities
5. **Type Safety**: Leverage generated types for better development experience

## Basic Queries

:::note
This page will be expanded with more query examples, advanced patterns, and real-world use cases.
:::

### Fetching Atoms

```graphql
query GetAtom($id: ID!) {
  atom(id: $id) {
    id
    content
    metadata {
      title
      author
      createdAt
    }
  }
}
```

### Fetching Triples

```graphql
query GetTriples($subject: ID, $predicate: String, $object: ID) {
  triples(subject: $subject, predicate: $predicate, object: $object) {
    id
    subject {
      id
      content
    }
    predicate
    object {
      id
      content
    }
    metadata {
      createdAt
      confidence
    }
  }
}
```

### Fetching Signals

```graphql
query GetSignals($type: String, $limit: Int) {
  signals(type: $type, limit: $limit) {
    id
    type
    data
    timestamp
    source
  }
}
```

## Advanced Queries

### Complex Filtering

```graphql
query SearchAtoms($query: String!, $filters: AtomFilters) {
  searchAtoms(query: $query, filters: $filters) {
    id
    content
    metadata {
      title
      tags
      createdAt
    }
    relevance
  }
}
```

### Pagination

```graphql
query GetAtomsPaginated($first: Int, $after: String) {
  atoms(first: $first, after: $after) {
    edges {
      node {
        id
        content
        metadata {
          title
          createdAt
        }
      }
      cursor
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
  }
}
```

## React Query Hooks

### Using Generated Hooks

```tsx
import { useGetAtomQuery } from '@0xintuition/graphql'

function AtomViewer({ atomId }: { atomId: string }) {
  const { data, loading, error } = useGetAtomQuery({
    variables: { id: atomId }
  })

  if (loading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <div>
      <h1>{data?.atom?.metadata?.title}</h1>
      <p>{data?.atom?.content}</p>
    </div>
  )
}
```

### Custom Hooks

```tsx
import { useQuery } from '@tanstack/react-query'
import { getAtomDocument } from '@0xintuition/graphql'

function useCustomAtomQuery(atomId: string) {
  return useQuery({
    queryKey: ['atom', atomId],
    queryFn: () => client.request(getAtomDocument, { id: atomId }),
    enabled: !!atomId
  })
}
```

---

### File: docs/guides/developer-tools/graphql-api/graphql-generator.mdx


# GraphQL Generator

The Intuition GraphQL package can be used as a GraphQL generator for your custom queries. It provides a type-safe interface for interacting with the Intuition API. It functions as the core data fetching layer, supplying generated types and React Query hooks for easy integration with the semantic knowledge graph.

## Key Features

- Type-safe GraphQL operations leveraging code gen
- React Query hooks for data fetching
- Reusable GraphQL fragments
- Easy to customize to your specific needs
- Supports real-time updates from the Intuition GraphQL API through GraphQL subscriptions


## Installation


The source code for the GraphQL generator is available on GitHub, which you can copy and paste into your own project to use as a GraphQL generator: [`intuition-ts/packages/graphql`](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql)


## Schema Management

The package uses a local-first approach for schema management:

- Local `schema.graphql` as source of truth
- Remote schema fallback for resilience
- Automatic schema generation during builds
- Version controlled schema for team consistency



## Package Structure

```bash
graphql/
‚îú‚îÄ‚îÄ src/
‚îÇ ‚îú‚îÄ‚îÄ client.ts # Client configuration
‚îÇ ‚îú‚îÄ‚îÄ fragments/ # Reusable fragments
‚îÇ ‚îú‚îÄ‚îÄ queries/ # GraphQL queries
‚îÇ ‚îú‚îÄ‚îÄ mutations/ # GraphQL mutations
‚îÇ ‚îî‚îÄ‚îÄ generated/ # Generated types
‚îú‚îÄ‚îÄ schema.graphql # Schema definition
‚îî‚îÄ‚îÄ codegen.ts # Codegen config
```

Although this package does not include a subscriptions folder, you can easily add one to the generator because the GraphQL API allows subscriptions for real-time updates.



## Package Approach

1. **Schema Updates**
    - Uses the local schema committed in the repository as the source for codegen and uses the remote URL as a fallback
2. **Query Organization**
    - Uses fragments for reusable fields
    - Includes use-case specific queries as well as general purpose queries
3. **Type Safety**
    - Leverages generated types from our schema
    - Generates React Query hooks as well as document queries that can be used in a server context (or with another client such as Apollo)
4. **Client Configuration**
    - Default client configuration can be overridden in each consumer app
    - Supports environment-specific API URLs

## Craft your own custom queries

We advise drafting and testing your queries, mutations, and subscriptions before implementing them into code. You should also use a GraphQL explorer to explore the Intuition GraphQL API schema.

For this, you can use [Apollo Explorer](https://studio.apollographql.com/sandbox/explorer) and input the URL of the Intuition testnet GraphQL API: `https://testnet.intuition.sh/v1/graphql`.


## Development Workflow

1. **Code Generation**
    - `pnpm codegen:build # Generate types`
    - `pnpm codegen:watch # Watch mode for development`
2. **Building**
    - `pnpm build # Full build with codegen`
    - `pnpm dev # Development mode with watch`
3. **Testing**
    - `pnpm test`


## Use your custom React Query hooks

Once you have run the codegen, you can use your custom React Query Hooks in your own components.

```tsx
import { useCustomTriplesQuery } from 'graphql/generated/hooks'

function MyComponent() {
  // Query triples based on your custom needs
  const { data: triples, isLoading: triplesLoading } = useCustomTriplesQuery({
    query: 'query CustomQuery { ... }'
  })

  return (
    <div>


      <h2>Triples ({triples?.triples?.length || 0})</h2>
      {triples?.triples?.map(triple => (
        <div key={triple.id}>
          {triple.subject.uri} - {triple.predicate.uri} - {triple.object.uri}
        </div>
      ))}
    </div>
  )
}
```

The GraphQL API provides the foundation for building powerful applications on Intuition.

## Related Resources

- [GraphQL Code Generator](https://the-guild.dev/graphql/codegen)
- [React Query Documentation](https://tanstack.com/query)
- [Intuition GraphQL Package Source](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql)


---

### File: docs/guides/developer-tools/graphql-api/migration-guide.mdx


# Migrating GraphQL from v1.5 to v2.0

## Overview

| Environment | Endpoint |
|-------------|----------|
| **Intuition Testnet** | `https://testnet.intuition.sh/v1/graphql` |


## ‚ö†Ô∏è Breaking Changes

### 1. ID Field Type Changes: Numeric ‚Üí String

**CRITICAL IMPACT** - All existing queries and mutations using these fields will break.

#### Core Entity ID Changes

| Entity        | Field             | Old Type   | New Type  |
| ------------- | ----------------- | ---------- | --------- |
| `accounts`    | `atom_id`         | `numeric`  | `String`  |
| `atoms`       | `term_id`         | `numeric!` | `String!` |
| `atoms`       | `value_id`        | `numeric`  | `String`  |
| `atom_values` | `id`              | `numeric!` | `String!` |
| `atom_values` | `book_id`         | `numeric`  | `String`  |
| `atom_values` | `byte_object_id`  | `numeric`  | `String`  |
| `atom_values` | `json_object_id`  | `numeric`  | `String`  |
| `atom_values` | `organization_id` | `numeric`  | `String`  |
| `atom_values` | `person_id`       | `numeric`  | `String`  |
| `atom_values` | `text_object_id`  | `numeric`  | `String`  |
| `atom_values` | `thing_id`        | `numeric`  | `String`  |
| `vaults`      | `term_id`         | `numeric!` | `String!` |

#### Entity Primary ID Changes

All primary `id` fields changed from `numeric!` to `String!`:

- `books`
- `byte_object`
- `caip10`
- `json_objects`
- `organizations`
- `persons`
- `text_objects`
- `things`
- `terms`

### 2. Removed Aggregate Fields

**MEDIUM IMPACT** - Statistical queries will break for entities with String IDs.

Removed aggregate field types (no longer available for statistical operations):

- `*_avg_fields` for: accounts, atom_values, books, byte_object, json_objects, organizations, persons, text_objects, things
- `*_stddev_fields`, `*_stddev_pop_fields`, `*_stddev_samp_fields`
- `*_sum_fields`, `*_var_pop_fields`, `*_var_samp_fields`, `*_variance_fields`

## üÜï New Features

### 1. New Optional Fields

#### atom_values

- `caip10_id: String` - Link to CAIP-10 identifiers

### 2. New Entity Types

Statistics and analytics entities:

- `statHours` - Hourly statistics aggregation
- `term_total_state_changes` - Term state change tracking
- `term_total_state_change_stats_daily` - Daily aggregated statistics
- `term_total_state_change_stats_hourly` - Hourly aggregated statistics
- `term_total_state_change_stats_monthly` - Monthly aggregated statistics
- `term_total_state_change_stats_weekly` - Weekly aggregated statistics

### 3. New Scalar Types

- `atom_resolving_status` - Custom scalar for atom resolution states
- `vault_type` - Custom scalar for vault type definitions

## üîß Migration Checklist

### Client Application Updates

#### 1. Query/Mutation Updates

- [ ] Update all numeric ID field references to String
- [ ] Remove or update queries using deprecated aggregate fields
- [ ] Test all existing GraphQL operations

#### 2. Code Generation Updates

- [ ] Regenerate TypeScript types
- [ ] Update GraphQL codegen configuration
- [ ] Verify generated types match new schema

#### 3. Variable Updates

```graphql
# OLD
query GetAtom($termId: numeric!) {
  atoms(where: { term_id: { _eq: $termId } }) {
    term_id
    value_id
  }
}

# NEW
query GetAtom($termId: String!) {
  atoms(where: { term_id: { _eq: $termId } }) {
    term_id
    value_id
    raw_data
    resolving_status
  }
}
```

---

### File: docs/guides/developer-tools/graphql-api/npm-package.mdx


# GraphQL NPM Package

The Intuition GraphQL package provides a type-safe interface for interacting with the Intuition API. It functions as the core data fetching layer, supplying generated types and React Query hooks for easy integration with the semantic knowledge graph.


## Key Features

- React Query hooks for data fetching
- Type-safe data fetching
- Error handling
- Loading state
- Pagination
- Sorting
- Filtering


## Installation

Install the package using your preferred package manager:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="npm" label="npm" default>

```bash
npm install @0xintuition/graphql
```

</TabItem>
<TabItem value="pnpm" label="pnpm">

```bash
pnpm install @0xintuition/graphql
```

</TabItem>
<TabItem value="yarn" label="yarn">

```bash
yarn add @0xintuition/graphql
```

</TabItem>
<TabItem value="bun" label="bun">

```bash
bun install @0xintuition/graphql
```

</TabItem>
</Tabs>

## Quick Start

### 1. Client Configuration (Optional)

Configure the GraphQL client at the root of your application:

```tsx
import { configureClient, API_URL_DEV, API_URL_PROD, API_URL_LOCAL } from '@0xintuition/graphql'

// Configure the GraphQL client with desired API URL
configureClient({
  apiUrl: API_URL_LOCAL, // For local development
})
```

**Available API URLs:**
- `API_URL_PROD`: `https://testnet.intuition.sh/v1/graphql` (default)
- `API_URL_DEV`: `https://testnet.intuition.sh/v1/graphql`
- `API_URL_LOCAL`: `http://localhost:8080/v1/graphql`

If you omit this configuration, the package defaults to `API_URL_PROD`.

### 2. Server Client Usage

For server-side operations:

```typescript
import { createServerClient } from '@0xintuition/graphql'

// Basic usage (most common)
const client = createServerClient({})

// With optional authentication token (rarely needed)
const clientWithAuth = createServerClient({
  token: 'your-auth-token'
})
```

### 3. Using Generated Hooks

Import and use the generated React Query hooks:

```typescript
import { useGetStatsQuery } from '@0xintuition/graphql'

function StatsComponent() {
  const { data, isLoading, error } = useGetStatsQuery()

  if (isLoading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return <div>{/* Render stats data */}</div>
}
```


```tsx
import { useAtomsQuery, useTriplesQuery, useUserPositionsQuery } from '@0xintuition/graphql'

function MyComponent() {
  // Query atoms
  const { data: atoms, isLoading: atomsLoading } = useAtomsQuery({
    variables: { first: 10 }
  })

  // Query triples
  const { data: triples, isLoading: triplesLoading } = useTriplesQuery({
    variables: { first: 10 }
  })

  // Query user positions
  const { data: positions } = useUserPositionsQuery({
    variables: { userAddress: '0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6' }
  })

  if (atomsLoading || triplesLoading) {
    return <div>Loading...</div>
  }

  return (
    <div>
      <h2>Atoms ({atoms?.atoms?.length || 0})</h2>
      {atoms?.atoms?.map(atom => (
        <div key={atom.id}>
          <strong>{atom.uri}</strong> - {atom.totalShares} shares
        </div>
      ))}

      <h2>Triples ({triples?.triples?.length || 0})</h2>
      {triples?.triples?.map(triple => (
        <div key={triple.id}>
          {triple.subject.uri} - {triple.predicate.uri} - {triple.object.uri}
        </div>
      ))}
    </div>
  )
}
```


## Available React Hooks
The following groups correspond to the query documents in the `src/queries` subdirectory of the package. Hook names are generated from each document and follow the `use<Name>Query` convention. The complete and canonical list may be found in the directory: [`packages/graphql/src/queries`](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql/src/queries)

### Accounts
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useAccountByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useAccountsQuery</code></li>
    </ul>
  </div>
</div>

### Atoms
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useAtomByIdQuery</code></li>
      <li><code>useGetAtomQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useAtomsQuery</code></li>
      <li><code>useGetAtomsQuery</code></li>
    </ul>
  </div>
</div>

### Claims
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useClaimByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useClaimsQuery</code></li>
    </ul>
  </div>
</div>

### Events
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useEventByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useEventsQuery</code></li>
    </ul>
  </div>
</div>

### Follows
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useFollowByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useFollowsQuery</code></li>
    </ul>
  </div>
</div>

### Lists
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useListByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useListsQuery</code></li>
    </ul>
  </div>
</div>

### Points
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>usePointByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>usePointsQuery</code></li>
    </ul>
  </div>
</div>

### Positions
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>usePositionByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>usePositionsQuery</code></li>
      <li><code>useUserPositionsQuery</code></li>
    </ul>
  </div>
</div>

### Signals
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useSignalByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useSignalsQuery</code></li>
      <li><code>useGetSignalsQuery</code></li>
    </ul>
  </div>
</div>

### Stats
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get</h4>
    <ul className="uniform-card-list">
      <li><code>useGetStatsQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useStatsQuery</code></li>
    </ul>
  </div>
</div>

### Tags
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useTagByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useTagsQuery</code></li>
    </ul>
  </div>
</div>

### Triples
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useTripleByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useTriplesQuery</code></li>
    </ul>
  </div>
</div>

### Vaults
<div className="uniform-card-grid-small">
  <div className="uniform-card">
    <h4 className="uniform-card-title">Get by ID</h4>
    <ul className="uniform-card-list">
      <li><code>useVaultByIdQuery</code></li>
    </ul>
  </div>
  <div className="uniform-card">
    <h4 className="uniform-card-title">Search &amp; Filter</h4>
    <ul className="uniform-card-list">
      <li><code>useVaultsQuery</code></li>
    </ul>
  </div>
</div>

These hooks are generated via GraphQL Code Generator and may expand over time as new documents are added. See the package source below for the current and authoritative list.


## Source Code

The GraphQL package source code is available on GitHub: [`intuition-ts/packages/graphql`](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql)


## Related Resources

- [GraphQL Code Generator](https://the-guild.dev/graphql/codegen)
- [React Query Documentation](https://tanstack.com/query)


---

### File: docs/guides/developer-tools/graphql-api/overview.mdx


import GraphQLPlayground from '@site/src/components/GraphQLPlayground';
import BrowserOnly from '@docusaurus/BrowserOnly';
import ExcalidrawViewer from '@site/src/components/ExcalidrawViewer';

# GraphQL API Overview

<BrowserOnly fallback={<p>Loading diagram...</p>}>
  {() => (
    <ExcalidrawViewer src="/excalidraw/architecture-diagram.excalidraw.json" />
  )}
</BrowserOnly>

Intuition provides a GraphQL API for querying its knowledge graph in a convenient and versatile way. There are a few ways to get started with this GraphQL API, depending on the level of abstraction and customization you require.

If this is your first time using GraphQL, you can learn more at [graphql.org](https://graphql.org/).

Until mainnet launch, the Intuition team hosts an open GraphQL API powered by Hasura, which may be accessed at [https://testnet.intuition.sh/v1/graphql](https://testnet.intuition.sh/v1/graphql). For more information about running the backend yourself, visit [Run an Intuition node](/docs/run-node/run-an-intuition-node).

<div className="uniform-card-grid">

  <a
    href="/docs/developer-tools/sdks/overview"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <SdkIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      SDK
    </h3>
    <p className="uniform-card-content">
      Integrate with Intuition smart contracts using our TypeScript SDK.
    </p>
  </a>

  <a
    href="/docs/developer-tools/graphql-api/custom-queries"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <QueriesIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Custom Queries
    </h3>
    <p className="uniform-card-content">
      Create bespoke GraphQL queries for your specific use case.
    </p>
  </a>

</div>

### GraphQL Package

<div className="uniform-card-grid-small">
  <a
    href="/docs/developer-tools/graphql-api/npm-package"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <NpmIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Install it with NPM
    </h3>
    <p className="uniform-card-content">
      Install and use the NPM package with ready-made React Query hooks.
    </p>
  </a>

  <a
    href="/docs/developer-tools/graphql-api/npm-package"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <GraphQlGeneratorIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Use it as a GraphQL Generator
    </h3>
    <p className="uniform-card-content">
      Use the GraphQL package to generate your own queries and mutations.
    </p>
  </a>
</div>

## Interactive Playground

Try the Intuition GraphQL API straight from your browser!  The playground below connects to the live testnet endpoint and allows you to explore the knowledge graph in real time.

<GraphQLPlayground />

---

### File: docs/guides/developer-tools/graphql-api/reads.mdx


import ExplorerEmbed from '@site/src/components/ExplorerEmbed';

# Reads

## GraphQL API

Our GraphQL API provides a flexible and efficient way to interact with our atomic data structure system. Through this documentation, you'll learn how to query and manipulate atomic data using our GraphQL endpoints. To help you explore and test the API interactively, we've integrated Apollo Explorer sandbox environments throughout this documentation.

These interactive playgrounds allow you to experiment with queries in real-time, seeing exactly how the API responds to different inputs and parameters.

This documentation will be split into sections by primitive, such as `Atoms`, `Triples`, and so on.

:::tip
We maintain a GraphQL SDK for our API that includes these queries with additional hooks for React developers to use directly in their apps. You can find it here: [https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql)

Our SDK utilizes GraphQL Codegen and Fragments, but for the sake of clarity and simplicity the query examples in the playgrounds won't utilize Fragments.
:::

## Best Practices

1. **Use the SDK**: Leverage our GraphQL SDK for type-safe queries
2. **Optimize Queries**: Only request the fields you need
3. **Handle Loading States**: Always show loading indicators
4. **Implement Error Boundaries**: Catch and handle errors gracefully
5. **Use Pagination**: Implement proper pagination for large datasets
6. **Cache Strategically**: Use React Query's caching capabilities

## Backend Architecture Overview

This architecture diagram illustrates the data flow and integration stack for the Intuition backend. We ingest data from two primary RPC sources: our EthMultiVault contract and a ChainLinkOracle contract. This blockchain data is processed in a Docker environment indexed through Substreams, parsing and structuring the data into a PostgreSQL database.

Hasura then provides a GraphQL API layer on top of Postgres, enabling flexible data querying powering our app layers. This architecture provides efficient blockchain data indexing, reliable storage, and scalable API access. Our upcoming GraphQL SDK will further streamline the process for app developers looking to consume our data for building and extending the Intuition protocol.

## GraphQL Playground

The interactive Apollo Sandbox below lets you explore our GraphQL API in real-time. You can write and execute queries, inspect the schema, and see live responses from our API. We've set up this environment to help you get familiar with our data structure and available operations.

Try starting with some basic queries like fetching atoms or exploring relationship triples. Here's a query to get you started:

<div className="mb-4">
  <ExplorerEmbed />
</div>

:::tip
You can copy and paste the code snippet below into the sandbox above to view the results.
:::

```graphql
query GetAtoms(
  $limit: Int
  $offset: Int
  $orderBy: [atoms_order_by!]
  $where: atoms_bool_exp
) {
  total: atoms_aggregate(where: $where) {
    aggregate {
      count
    }
  }
  atoms(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {
    # Basic metadata
    term_id
    data
    image
    label
    emoji
    type
    wallet_id
    creator {
      id
      label
      image
    }

    # Transaction details
    block_number
    created_at
    updated_at
    transaction_hash
    creator_id

    # Vault details
    term {
      vaults(where: { curve_id: { _eq: "1" } }, order_by: { curve_id: asc }) {
        position_count
        total_shares
        current_share_price
        market_cap
        positions_aggregate {
          aggregate {
            count
            sum {
              shares
            }
          }
        }
        positions {
          id
          account {
            label
            id
          }
          shares
        }
      }
    }

    # Value metadata
    value {
      person {
        name
        image
        description
        url
      }
      thing {
        name
        image
        description
        url
      }
      organization {
        name
        image
        description
        url
      }
      account {
        id
        label
        image
      }
    }
  }
}
```

You can start with this initial `GetAtoms` query in the Apollo Sandbox or write your own. The schema Explorer (docs tab) on the left side of the sandbox shows all available queries, mutations, and types. As you type, you'll get real-time autocompletion and documentation hints to help you build your queries. You can then click the play button to see the response and then adjust your query as you explore our data.

Need inspiration? Check out the example queries in the GraphQL API Example Queries page to get started, or jump right in and start exploring!

## Query Examples

### GetAtoms

The `GetAtoms` query is the primary way to fetch atom data from the Intuition system. It provides comprehensive information about atoms including metadata, transaction details, and vault information.

```graphql
query GetAtoms(
  $limit: Int
  $offset: Int
  $orderBy: [atoms_order_by!]
  $where: atoms_bool_exp
) {
  total: atoms_aggregate(where: $where) {
    aggregate {
      count
    }
  }
  atoms(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {
    # Basic metadata
    term_id
    data
    image
    label
    emoji
    type
    wallet_id
    creator {
      id
      label
      image
    }

    # Transaction details
    block_number
    created_at
    updated_at
    transaction_hash
    creator_id

    # Vault details
    term {
      vaults(where: { curve_id: { _eq: "1" } }, order_by: { curve_id: asc }) {
        position_count
        total_shares
        current_share_price
        market_cap
        positions_aggregate {
          aggregate {
            count
            sum {
              shares
            }
          }
        }
        positions {
          id
          account {
            label
            id
          }
          shares
        }
      }
    }

    # Value metadata
    value {
      person {
        name
        image
        description
        url
      }
      thing {
        name
        image
        description
        url
      }
      organization {
        name
        image
        description
        url
      }
      account {
        id
        label
        image
      }
    }
  }
}
```

### GetAccounts

Query account information including balances and positions.

```graphql
query GetAccounts($limit: Int, $offset: Int) {
  accounts(limit: $limit, offset: $offset) {
    id
    label
    image
    positions {
      id
      shares
      vault {
        id
        atom {
          label
          image
        }
      }
    }
  }
}
```

### GetTriples

Fetch relationship triples between atoms.

```graphql
query GetTriples(
  $limit: Int
  $offset: Int
  $orderBy: [triples_order_by!]
  $where: triples_bool_exp
) {
  total: triples_aggregate(where: $where) {
    aggregate {
      count
    }
  }
  triples(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {
    term_id
    counter_term_id
    created_at
    subject {
      term_id
      label
      image
      data
      type
      value {
        thing {
          description
          url
        }
        person {
          description
          url
        }
        organization {
          description
          url
        }
      }
    }
    predicate {
      term_id
      label
      image
      data
      type
    }
    object {
      term_id
      label
      image
      data
      type
      value {
        thing {
          description
          url
        }
        person {
          description
          url
        }
        organization {
          description
          url
        }
      }
    }
    # Vault details for pro/counter positions
    term {
      vaults(where: { curve_id: { _eq: "2" } }) {
        total_shares
        current_share_price
        market_cap
        position_count
      }
    }
    counter_term {
      vaults(where: { curve_id: { _eq: "2" } }) {
        total_shares
        current_share_price
        market_cap
        position_count
      }
    }
  }
}
```

### GetPositions

Query user positions in atom vaults.

```graphql
query GetPositions(
  $limit: Int
  $offset: Int
  $orderBy: [positions_order_by!]
  $where: positions_bool_exp
) {
  total: positions_aggregate(where: $where) {
    aggregate {
      count
      sum {
        shares
      }
    }
  }
  positions(limit: $limit, offset: $offset, order_by: $orderBy, where: $where) {
    id
    created_at
    updated_at
    shares
    account {
      id
      label
      image
    }
    vault {
      created_at
      updated_at
      term {
        atom {
          term_id
          label
          image
          term {
            vaults(where: { curve_id: { _eq: "1" } }) {
              term_id
              total_shares
              current_share_price
              position_count
            }
          }
        }
        triple {
          term_id
          subject {
            term_id
            label
            image
          }
          predicate {
            term_id
            label
            image
          }
          object {
            term_id
            label
            image
          }
          term {
            vaults(where: { curve_id: { _eq: "2" } }) {
              market_cap
              current_share_price
              position_count
            }
          }
        }
      }
    }
  }
}
```

### GetVaults

Fetch vault information including share prices and positions.

```graphql
query GetVaults($limit: Int, $offset: Int) {
  vaults(limit: $limit, offset: $offset) {
    id
    atom {
      id
      label
      image
    }
    current_share_price
    total_shares
    position_count
    positions_aggregate {
      aggregate {
        count
        sum {
          shares
        }
      }
    }
  }
}
```

## Utilities

### Search and Filtering

```graphql
query SearchAtoms($query: String!, $filters: atoms_bool_exp) {
  atoms(where: $filters) {
    id
    label
    image
    type
    creator {
      id
      label
    }
  }
}
```

### Pagination

```graphql
query GetAtomsPaginated($first: Int, $after: String) {
  atoms(first: $first, after: $after) {
    edges {
      node {
        id
        label
        image
        type
      }
      cursor
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
  }
}
```

## React Integration

### Using the GraphQL SDK

```tsx
import { useGetAtomsQuery } from '@0xintuition/graphql'

function AtomList() {
  const { data, loading, error } = useGetAtomsQuery({
    variables: {
      limit: 10,
      offset: 0
    }
  })

  if (loading) return <div>Loading...</div>
  if (error) return <div>Error: {error.message}</div>

  return (
    <div>
      {data?.atoms.map(atom => (
        <div key={atom.id}>
          <h3>{atom.label}</h3>
          <img src={atom.image} alt={atom.label} />
          <p>Type: {atom.type}</p>
        </div>
      ))}
    </div>
  )
}
```


---

### File: docs/guides/developer-tools/graphql-api/use-cases/building-user-activity-feeds.mdx


import GraphQLPlaygroundCustom from '@site/src/components/GraphQLPlaygroundCustom';

# Building User Activity Feeds

Learn how to create personalized, real-time activity feeds that track user interactions across the Intuition ecosystem using the GraphQL API.

## Understanding the Progression

1. **Get the whole user activity feed**, including atoms made and positions taken, along with vault details.
2. **Get recent claims** produced by the user, both atoms (max 10) and triples (max 10) with detailed metadata.
3. **Get active user positions** ordered by share amount - shows current stakes with vault performance metrics.

export const activityQueries = [
  {
    id: 'user-activity',
    title: 'Step 1: Get User Activity',
    query: `query GetUserActivity($userAddress: String!, $limit: Int = 20) {
  atoms(
    where: { creator_id: { _eq: $userAddress } }
    order_by: [{ created_at: desc }]
    limit: $limit
  ) {
    term_id
    label
    image
    type
    created_at
    transaction_hash
  }

  positions(
    where: { account_id: { _eq: $userAddress } }
    order_by: [{ created_at: desc }]
    limit: $limit
  ) {
    id
    shares
    created_at
    vault {
      term_id
      current_share_price
      market_cap
      term {
        atom {
          term_id
          label
          image
        }
      }
    }
  }
}`,
    variables: {
      userAddress: '0x4Ff2D2D253827897210bf1f29713f8389f55C68E',
      limit: 20
    }
  },
  {
    id: 'recent-claims',
    title: 'Step 2: User Recent Claims',
    query: `query GetUserClaims($userAddress: String!, $limit: Int = 10) {
  atoms(
    where: { creator_id: { _eq: $userAddress } }
    order_by: [{ created_at: desc }]
    limit: $limit
  ) {
    term_id
    label
    image
    emoji
    type
    data
    created_at
    block_number
  }

  triples(
    where: { creator_id: { _eq: $userAddress } }
    order_by: [{ created_at: desc }]
    limit: $limit
  ) {
    term_id
    created_at
    subject {
      term_id
      label
      image
    }
    predicate {
      term_id
      label
    }
    object {
      term_id
      label
      image
    }
  }
}`,
    variables: {
      userAddress: '0x4Ff2D2D253827897210bf1f29713f8389f55C68E',
      limit: 10
    }
  },
  {
    id: 'user-positions',
    title: 'Step 3: Active User Positions',
    query: `query GetUserPositions($userAddress: String!, $limit: Int = 20) {
  positions(
    where: {
      account_id: { _eq: $userAddress }
      shares: { _gt: "0" }
    }
    order_by: [{ shares: desc }]
    limit: $limit
  ) {
    id
    shares
    created_at
    updated_at
    vault {
      term_id
      current_share_price
      market_cap
      term {
        atom {
          term_id
          label
          image
          emoji
        }
        triple {
          term_id
          subject { label image }
          predicate { label }
          object { label image }
        }
      }
    }
  }
}`,
    variables: {
      userAddress: '0x4Ff2D2D253827897210bf1f29713f8389f55C68E',
      limit: 20
    }
  }
];

<GraphQLPlaygroundCustom queries={activityQueries} />

---

### File: docs/guides/developer-tools/graphql-api/use-cases/discovering-most-trusted-accounts.mdx


import GraphQLPlaygroundCustom from '@site/src/components/GraphQLPlaygroundCustom';

# Discovering the Most Trusted Accounts

Learn how to leverage the Intuition GraphQL API to find and rank the ecosystem's most trusted accounts based on their positions, stakes, and activity patterns.

## Understanding the Progression

1. **Get top 20 accounts** ranked by total shares across all positions, showing the most trusted accounts based on cumulative stakes.
2. **Get detailed information** for a given account including all positions and atoms created.
3. **Find top 20 individual positions** by share amount, showing which accounts hold the largest single stakes.

export const accountQueries = [
  {
    id: 'trusted-accounts',
    title: 'Step 1: Get Most Trusted Accounts',
    query: `query GetTrustedAccounts($limit: Int = 20) {
  accounts(
    limit: $limit
    order_by: [{ positions_aggregate: { sum: { shares: desc } } }]
    where: {
      positions_aggregate: {
        count: { predicate: { _gt: 0 } }
      }
    }
  ) {
    id
    label
    image
    positions_aggregate {
      aggregate {
        count
        sum {
          shares
        }
      }
    }
    positions(
      limit: 10
      order_by: [{ shares: desc }]
    ) {
      id
      shares
      created_at
      vault {
        term_id
        current_share_price
        market_cap
        term {
          atom {
            term_id
            label
            image
          }
        }
      }
    }
  }
}`,
    variables: {
      limit: 20
    }
  },
  {
    id: 'account-details',
    title: 'Step 2: Get Account Details',
    query: `query GetAccountDetails($accountId: String!) {
  accounts(where: { id: { _eq: $accountId } }) {
    id
    label
    image
    positions_aggregate {
      aggregate {
        count
        sum {
          shares
        }
      }
    }
    positions(
      limit: 50
      order_by: [{ shares: desc }]
    ) {
      id
      shares
      created_at
      vault {
        term_id
        current_share_price
        market_cap
        total_shares
        term {
          atom {
            term_id
            label
            image
            type
          }
          triple {
            term_id
            subject { label }
            predicate { label }
            object { label }
          }
        }
      }
    }
    atoms(order_by: [{ created_at: desc }]) {
      term_id
      label
      type
      created_at
    }
  }
}`,
    variables: {
      accountId: '0xbd2DE08aF9470c87C4475117Fb912B8f1d588D9c'
    }
  },
  {
    id: 'top-holders',
    title: 'Step 3: Top Position Holders',
    query: `query GetTopHolders($limit: Int = 20) {
  positions(
    limit: $limit
    order_by: [{ shares: desc }]
  ) {
    id
    shares
    created_at
    account {
      id
      label
      image
      positions_aggregate {
        aggregate {
          count
          sum {
            shares
          }
        }
      }
    }
    vault {
      term_id
      market_cap
      current_share_price
      term {
        atom {
          label
          image
        }
      }
    }
  }
}`,
    variables: {
      limit: 20
    }
  }
];

<GraphQLPlaygroundCustom queries={accountQueries} />

---

### File: docs/guides/developer-tools/graphql-api/use-cases/finding-related-claims.mdx


import GraphQLPlaygroundCustom from '@site/src/components/GraphQLPlaygroundCustom';

# Finding Related Claims

Learn how to find and navigate related claims in the Intuition knowledge graph by exploring triples, their relationships, and semantic connections.

## Understanding the Progression

1. **Find all triples** where a specific atom appears as subject or object and discover direct relationships.
2. **Find similar claims** by predicate pattern and subject type, then discover relationship patterns across the graph.
3. **Get detailed information** about a specific triple, including vault metrics and top positions.

export const relationshipQueries = [
  {
    id: 'related-claims',
    title: 'Step 1: Find Related Claims',
    query: `query GetRelatedClaims($atomId: String!, $limit: Int = 20) {
  as_subject: triples(
    where: { subject_id: { _eq: $atomId } }
    order_by: [{ term: { vaults_aggregate: { max: { market_cap: desc } } } }]
    limit: $limit
  ) {
    term_id
    created_at
    predicate {
      term_id
      label
      image
    }
    object {
      term_id
      label
      image
      type
    }
    term {
      vaults(where: { curve_id: { _eq: "2" } }) {
        market_cap
        position_count
      }
    }
  }

  as_object: triples(
    where: { object_id: { _eq: $atomId } }
    order_by: [{ term: { vaults_aggregate: { max: { market_cap: desc } } } }]
    limit: $limit
  ) {
    term_id
    created_at
    subject {
      term_id
      label
      image
      type
    }
    predicate {
      term_id
      label
      image
    }
    term {
      vaults(where: { curve_id: { _eq: "2" } }) {
        market_cap
        position_count
      }
    }
  }

  atom: atoms(where: { term_id: { _eq: $atomId } }, limit: 1) {
    term_id
    label
    image
    type
  }
}`,
    variables: {
      atomId: '0xf12dba36ffebb8e05ae49d3f9220b1994295662ccdc573f44aff7b51f8ad8fd6',
      limit: 20
    }
  },
  {
    id: 'similar-claims',
    title: 'Step 2: Find Similar Claims',
    query: `query FindSimilarClaims($predicateLabel: String!, $subjectType: atom_type, $limit: Int = 20) {
  triples(
    where: {
      predicate: { label: { _ilike: $predicateLabel } }
      _and: [
        { subject: { type: { _eq: $subjectType } } }
      ]
    }
    order_by: [{ term: { vaults_aggregate: { max: { market_cap: desc } } } }]
    limit: $limit
  ) {
    term_id
    created_at
    subject {
      term_id
      label
      image
      type
    }
    predicate {
      term_id
      label
    }
    object {
      term_id
      label
      image
      type
    }
    term {
      vaults(where: { curve_id: { _eq: "2" } }) {
        total_shares
        market_cap
        position_count
      }
    }
  }
}`,
    variables: {
      predicateLabel: '%is a%',
      subjectType: 'Thing',
      limit: 20
    }
  },
  {
    id: 'triple-details',
    title: 'Step 3: Get Triple Details',
    query: `query GetTripleDetails($termId: String!) {
  triples(where: { term_id: { _eq: $termId } }) {
    term_id
    counter_term_id
    created_at
    subject {
      term_id
      label
      image
      type
    }
    predicate {
      term_id
      label
      image
    }
    object {
      term_id
      label
      image
      type
    }
    term {
      vaults(where: { curve_id: { _eq: "2" } }) {
        term_id
        total_shares
        current_share_price
        market_cap
        position_count
        positions(limit: 5, order_by: { shares: desc }) {
          account {
            label
          }
          shares
        }
      }
    }
    counter_term {
      vaults(where: { curve_id: { _eq: "2" } }) {
        term_id
        total_shares
        current_share_price
        market_cap
        position_count
      }
    }
  }
}`,
    variables: {
      termId: '0xffb30efde2b49a7deadd920a7df684595ed4a291a582033c16b0795796965600'
    }
  }
];

<GraphQLPlaygroundCustom queries={relationshipQueries} />

---

### File: docs/guides/developer-tools/graphql-api/use-cases/finding-top-dapps-on-coinbase.mdx


import GraphQLPlaygroundCustom from '@site/src/components/GraphQLPlaygroundCustom';

# Finding the Top dApps on Coinbase

This guide shows you how to progressively build queries to discover and rank the top decentralized applications (Dapps) on Coinbase by market capitalization.

Follow these 4 queries step-by-step. Each one builds on the previous to achieve the final result: **a ranked list of top dApps on Coinbase**.

## Understanding the Progression

1. **Run a basic query** to view all dApps (organizations) in the system.
2. **Repeat the query**, but filtered for Coinbase-related Dapps (note how the results narrow down).
3. **Add performance metrics** from vaults (market cap, shares, and positions), data is now richer but not yet sorted.
4. **Repeat the query from Step 3**, but this time sort by market cap to show the top performing dApps first.

export const progressiveQueries = [
  {
    id: 'step1-discover',
    title: 'Step 1: Discover All Dapps (Organizations)',
    query: `query DiscoverAllDapps($limit: Int = 10) {
  atoms(
    limit: $limit
    where: { type: { _eq: "Thing" } }
  ) {
    term_id
    label
    image
    emoji
    type
    created_at
  }
}`,
    variables: {
      limit: 10
    }
  },
  {
    id: 'step2-filter',
    title: 'Step 2: Filter for Coinbase-Related Dapps',
    query: `query FilterCoinbaseDapps($limit: Int = 10) {
  atoms(
    limit: $limit
    where: {
      type: { _eq: "Thing" }
      _or: [
        { label: { _ilike: "%coinbase%" } }
        { data: { _ilike: "%coinbase%" } }
      ]
    }
  ) {
    term_id
    label
    image
    emoji
    type
    data
    created_at
  }
}`,
    variables: {
      limit: 10
    }
  },
  {
    id: 'step3-metrics',
    title: 'Step 3: Add Performance Metrics (Market Cap, Shares)',
    query: `query AddPerformanceMetrics($limit: Int = 10) {
  atoms(
    limit: $limit
    where: {
      type: { _eq: "Thing" }
      _or: [
        { label: { _ilike: "%coinbase%" } }
        { data: { _ilike: "%coinbase%" } }
      ]
    }
  ) {
    term_id
    label
    image
    emoji
    type

    term {
      vaults(where: { curve_id: { _eq: "1" } }) {
        total_shares
        current_share_price
        market_cap
        position_count
      }
    }

    creator {
      id
      label
    }
    created_at
  }
}`,
    variables: {
      limit: 10
    }
  },
  {
    id: 'step4-final',
    title: 'Step 4: FINAL RESULT - Ranked by Market Cap',
    query: `query GetTopDappsRanked($limit: Int = 10) {
  atoms(
    limit: $limit
    order_by: [{ term: { vaults_aggregate: { max: { market_cap: desc } } } }]
    where: {
      type: { _eq: "Thing" }
      _or: [
        { label: { _ilike: "%coinbase%" } }
        { data: { _ilike: "%coinbase%" } }
      ]
    }
  ) {
    term_id
    label
    image
    emoji
    type

    term {
      vaults(where: { curve_id: { _eq: "1" } }) {
        total_shares
        current_share_price
        market_cap
        position_count
      }
    }

    creator {
      id
      label
    }
    created_at
  }
}`,
    variables: {
      limit: 10
    }
  }
];

<GraphQLPlaygroundCustom queries={progressiveQueries} />

---

### File: docs/guides/developer-tools/graphql-api/use-cases/overview.mdx


# GraphQL API Use Cases

This section contains practical, step-by-step tutorials for common use cases when working with the Intuition GraphQL API. Each example explains how to build real-world applications with our semantic knowledge graph.

## Available Examples

Select a use case above to see detailed step-by-step implementation guides.

<div className="uniform-card-grid">
  <a
    href="/finding-top-dapps-on-coinbase"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <AppIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Finding the Top dApps on Coinbase
    </h3>
    <p className="uniform-card-content">
      Query and rank decentralized applications based on market data.
    </p>
  </a>

  <a
    href="/discovering-most-trusted-accounts"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <StarIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Discovering the Most Trusted Accounts
    </h3>
    <p className="uniform-card-content">
      Find highly trusted accounts based on stake and activity.
    </p>
  </a>

  <a
    href="/building-user-activity-feeds"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <FeedIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Building User Activity Feeds
    </h3>
    <p className="uniform-card-content">
      Create personalized activity streams for users.
    </p>
  </a>

  <a
    href="/finding-related-claims"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <WaypointsIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Finding Related Claims
    </h3>
    <p className="uniform-card-content">
      Discover linked triples and relationship patterns.
    </p>
  </a>
</div>

---

### File: docs/guides/developer-tools/graphql-api/writes.mdx


# Writes

## GraphQL Mutations

Our GraphQL API provides convenient mutations to help structure and publish Atom metadata following common schemas and best practices. While the protocol supports any URI scheme, these mutations offer an opinionated approach to creating well-structured, interoperable data.

## Current Schema Support

Our GraphQL API provides mutations for uploading structured metadata following common schemas. The primary mutation is `pinThing` which uploads metadata to IPFS following the **Thing schema**.

### pinThing Mutation

```graphql
mutation pinThing(
  $name: String!
  $description: String
  $image: String
  $url: String
) {
  pinThing(
    thing: {
      name: $name,
      description: $description,
      image: $image,
      url: $url
    }
  ) {
    uri
  }
}
```

### Example Usage

```json
{
  "name": "My First Thing",
  "description": "This is an example description of a thing",
  "image": "https://example.com/image.png",
  "url": "https://example.com"
}
```

### Variables Example

```json
{
  "name": "Intuition Protocol",
  "description": "A decentralized trust protocol for the internet",
  "image": "https://intuition.systems/logo.png",
  "url": "https://intuition.systems"
}
```

The mutation returns an IPFS URI that can be used when creating an Atom:

```typescript
const { data } = await pinThing(thingVariables)
// data.pinThing.uri contains the IPFS URI
// Use this URI when creating atoms via the SDK
```

## Advanced Mutation Examples

### Creating Atoms with Metadata

```graphql
mutation CreateAtomWithMetadata($uri: String!, $curveId: Int!) {
  createAtom(uri: $uri, curveId: $curveId) {
    id
    uri
    createdAt
    vault {
      id
      curveId
      isActive
    }
  }
}
```

### Creating Triples

```graphql
mutation CreateTriple(
  $subjectId: String!
  $predicateId: String!
  $objectId: String!
  $curveId: Int!
) {
  createTriple(
    subjectId: $subjectId
    predicateId: $predicateId
    objectId: $objectId
    curveId: $curveId
  ) {
    id
    subject {
      id
      uri
    }
    predicate {
      id
      uri
    }
    object {
      id
      uri
    }
    positiveVault {
      id
      curveId
    }
    negativeVault {
      id
      curveId
    }
  }
}
```

### Taking Positions on Atoms

```graphql
mutation TakePositionOnAtom(
  $atomId: String!
  $shares: String!
  $curveId: Int!
) {
  takePosition(
    atomId: $atomId
    shares: $shares
    curveId: $curveId
  ) {
    id
    user
    shares
    assets
    atom {
      id
      uri
    }
    vault {
      id
      curveId
    }
  }
}
```

### Taking Positions on Triples

```graphql
mutation TakePositionOnTriple(
  $tripleId: String!
  $shares: String!
  $isPositive: Boolean!
  $curveId: Int!
) {
  takeTriplePosition(
    tripleId: $tripleId
    shares: $shares
    isPositive: $isPositive
    curveId: $curveId
  ) {
    id
    user
    shares
    assets
    isPositive
    triple {
      id
      subject {
        uri
      }
      predicate {
        uri
      }
      object {
        uri
      }
    }
    vault {
      id
      curveId
    }
  }
}
```

## Example Workflows

### Basic Thing Creation

```typescript
// 1. Upload metadata
const thingData = {
  name: 'Example Thing',
  description: 'Description...',
  image: 'ipfs://Qm...',
  url: 'https://...',
}

const { cid } = await uploadThing(thingData)

// 2. Create Atom with returned CID
const atomId = await createAtom(cid)
```

### Creating a Knowledge Graph Entry

```typescript
// 1. Create subject atom
const subjectData = {
  name: 'Alice',
  description: 'A person',
  image: 'ipfs://QmAlice...',
  url: 'https://example.com/alice'
}
const { cid: subjectCid } = await uploadThing(subjectData)
const subjectAtom = await createAtom(subjectCid)

// 2. Create predicate atom
const predicateData = {
  name: 'knows',
  description: 'Relationship indicating knowledge',
  image: 'ipfs://QmKnows...',
  url: 'https://example.com/knows'
}
const { cid: predicateCid } = await uploadThing(predicateData)
const predicateAtom = await createAtom(predicateCid)

// 3. Create object atom
const objectData = {
  name: 'Bob',
  description: 'Another person',
  image: 'ipfs://QmBob...',
  url: 'https://example.com/bob'
}
const { cid: objectCid } = await uploadThing(objectData)
const objectAtom = await createAtom(objectCid)

// 4. Create triple relationship
const triple = await createTriple({
  subjectId: subjectAtom.id,
  predicateId: predicateAtom.id,
  objectId: objectAtom.id,
  curveId: 1
})

// 5. Take a position on the triple
const position = await takeTriplePosition({
  tripleId: triple.id,
  shares: '1000000000000000000', // 1 share in wei
  isPositive: true,
  curveId: 1
})
```

### Variables for Testing

```json
{
  "uri": "ipfs://QmExample...",
  "curveId": 1,
  "subjectId": "0x1234567890abcdef1234567890abcdef12345678",
  "predicateId": "0xabcdef1234567890abcdef1234567890abcdef12",
  "objectId": "0x9876543210fedcba9876543210fedcba98765432",
  "atomId": "0x1234567890abcdef1234567890abcdef12345678",
  "tripleId": "0xabcdef1234567890abcdef1234567890abcdef12",
  "shares": "1000000000000000000",
  "isPositive": true
}
```

## Upcoming Schema Support

We are actively expanding our mutation support to include schemas from **schema.org**. Additionally, we'll be adding support for **CAIP-10 addresses** to enable cross-chain identity resolution.

## Best Practices

### Complete Metadata
Provide as much relevant metadata as possible to improve the Atom's utility across different contexts.

### Persistent Storage
All metadata is stored on IPFS, ensuring data availability and immutability.

### URI Standards
Use standard URI formats:
- **IPFS**: `ipfs://Qm...`
- **HTTP(S)**: `https://...`
- **CAIP-10** (coming soon): `eip155:1:0x...`

### Error Handling
Always handle potential errors in mutations:

```typescript
try {
  const result = await createAtom(uri, curveId)
  console.log('Atom created:', result.id)
} catch (error) {
  console.error('Failed to create atom:', error.message)
}
```

### Gas Estimation
For on-chain operations, always estimate gas before executing:

```typescript
const gasEstimate = await contract.estimateGas.createAtom(uri, curveId)
const tx = await contract.createAtom(uri, curveId, { gasLimit: gasEstimate })
```

## TypeScript Integration

We maintain a package, `graphql` within our `intuition-ts` monorepo that auto-generates TypeScript types and React hooks to make integrations easier. This includes type-safe mutations, queries, and React hooks for all supported schemas.

### Using Generated Hooks

```typescript
import { 
  useUploadThingMutation, 
  useCreateAtomMutation, 
  useCreateTripleMutation,
  useTakePositionMutation 
} from '@0xintuition/graphql'

function CreateAtomComponent() {
  const [uploadThing, { loading: uploading }] = useUploadThingMutation()
  const [createAtom, { loading: creating }] = useCreateAtomMutation()

  const handleCreateAtom = async (thingData: ThingData) => {
    try {
      // Upload metadata
      const { data: uploadResult } = await uploadThing({
        variables: thingData
      })

      // Create atom with returned CID
      const { data: atomResult } = await createAtom({
        variables: {
          uri: uploadResult.uploadThing.cid,
          curveId: 1
        }
      })

      console.log('Atom created:', atomResult.createAtom.id)
    } catch (error) {
      console.error('Failed to create atom:', error)
    }
  }

  return (
    <button 
      onClick={() => handleCreateAtom(thingData)}
      disabled={uploading || creating}
    >
      {uploading || creating ? 'Creating...' : 'Create Atom'}
    </button>
  )
}
```

We are actively finalizing patterns to properly externalize this package, which will be released shortly. This guide will be updated to provide example implementations once the package is released.


## Related Resources

- [GraphQL API Overview](/guides/developer-tools/graphql-api/overview)
- [GraphQL Reads](/guides/developer-tools/graphql-api/reads)
- [Intuition GraphQL Package Source](https://github.com/0xIntuition/intuition-ts/tree/main/packages/graphql) 

---

### File: docs/guides/developer-tools/interactions/create-atom.md


# Create Atom

Creating atoms in the Intuition protocol involves interacting with the EthMultiVault contract to establish new entities in the knowledge graph. This process includes creating the atom itself and managing its associated vault.

## Prerequisites

This implementation guide assumes that you've completed the setup steps in the [Overview](/guides/developer-tools/interactions/overview) guide. Steps for creating the `createMultivaultContract` and the `publicClient` referenced in this implementation example can be found in the overview.

## Implementation

We recommend creating a `multivault.ts` that includes the following atom creation functionality:

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Core Atom Creation Pattern</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// Create atom with initial deposit
const createAtomConfig = {
  ...multiVaultContract,
  functionName: 'createAtom',
  args: [atomData, initialDeposit],
}

// Execute transaction
const hash = await walletClient.writeContract(createAtomConfig)

// Wait for confirmation
const receipt = await publicClient.waitForTransactionReceipt({ hash })`}
</pre>
</div>
</div>

## Complete Example

Here is a full example of the atom creation pattern used in the `createAtom` function:

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Full Implementation</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`export async function createAtom(
  contract: string,
  atomData: string,
  initialDeposit: bigint,
  walletClient: WalletClient,
  publicClient: PublicClient
) {
  const multiVaultContract = createMultiVaultContract(contract)

  // Prepare atom creation transaction
  const createAtomConfig = {
    ...multiVaultContract,
    functionName: 'createAtom',
    args: [atomData, initialDeposit],
  }

  try {
    // Execute the transaction
    const hash = await walletClient.writeContract(createAtomConfig)
    
    // Wait for transaction confirmation
    const receipt = await publicClient.waitForTransactionReceipt({ hash })
    
    // Parse events to get atom ID
    const atomCreatedEvent = receipt.logs.find(
      log => log.eventName === 'AtomCreated'
    )
    
    if (!atomCreatedEvent) {
      throw new Error('Atom creation event not found')
    }
    
    const atomId = atomCreatedEvent.args.atomId
    const vaultId = atomCreatedEvent.args.vaultId
    
    return {
      success: true,
      atomId,
      vaultId,
      transactionHash: hash,
      receipt
    }
  } catch (error) {
    return {
      success: false,
      error: error.message
    }
  }
}`}
</pre>
</div>
</div>

## Key Functions

We use this pattern to create atoms and manage their lifecycle:

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>createAtom</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Creates a new atom with optional initial deposit and returns atom/vault IDs.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>validateAtomData</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Validates atom data format and ensures it meets protocol requirements.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>estimateAtomCost</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Estimates the cost of creating an atom including fees and gas costs.
</p>
</div>

</div>

## Usage Example

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Basic Atom Creation</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// Create a new atom
const atomData = "did:ethr:mainnet:0x1234567890abcdef"
const initialDeposit = parseEther("0.1")

const result = await createAtom(
  MULTIVAULT_CONTRACT_ADDRESS,
  atomData,
  initialDeposit,
  walletClient,
  publicClient
)

if (result.success) {
  console.log({
    atomId: result.atomId,
    vaultId: result.vaultId,
    transactionHash: result.transactionHash
  })
} else {
  console.error('Atom creation failed:', result.error)
}`}
</pre>
</div>
</div>

## Error Handling

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Common Error Scenarios</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Insufficient Funds</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Ensure wallet has sufficient ETH for gas and deposit amount.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Invalid Atom Data</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Validate atom data format before submission.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Network Issues</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Handle RPC failures and network connectivity issues.
</p>
</div>
</div>
</div>

## Best Practices

- Always validate atom data before submission
- Estimate costs before executing transactions
- Implement proper error handling and user feedback
- Use multicall patterns for batch operations
- Monitor transaction status and provide confirmation feedback

## Next Steps

After creating atoms, explore:

- [Create Triple](/guides/developer-tools/interactions/create-triple) - Learn how to create relationships between atoms
- [Deposit & Return](/guides/developer-tools/interactions/deposit-return) - Manage vault deposits and withdrawals
- [Retrieve Vault Details](/guides/developer-tools/interactions/retrieve-vault-details) - Get comprehensive vault information

For a full reference implementation, see the [Intuition TypeScript SDK](https://github.com/0xIntuition/intuition-ts). 

---

### File: docs/guides/developer-tools/interactions/create-triple.md


# Create Triple

Creating triples in the Intuition protocol involves establishing relationships between atoms through the EthMultiVault contract. This process creates both the triple structure and its associated vaults for positive and negative positions.

## Prerequisites

This implementation guide assumes that you've completed the setup steps in the [Overview](/guides/developer-tools/interactions/overview) guide and have existing atoms to work with.

## Implementation

We recommend creating a `multivault.ts` that includes the following triple creation functionality:

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Core Triple Creation Pattern</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// Create triple with initial deposit
const createTripleConfig = {
  ...multiVaultContract,
  functionName: 'createTriple',
  args: [subjectId, predicateId, objectId, initialDeposit],
}

// Execute transaction
const hash = await walletClient.writeContract(createTripleConfig)`}
</pre>
</div>
</div>

## Key Functions

We use this pattern to create triples and manage their lifecycle:

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>createTriple</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Creates a new triple with optional initial deposit and returns triple/vault IDs.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>validateTripleComponents</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Validates that subject, predicate, and object atoms exist and are valid.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>estimateTripleCost</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Estimates the cost of creating a triple including fees and gas costs.
</p>
</div>

</div>

## Usage Example

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Basic Triple Creation</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// Create a new triple
const subjectId = 123n  // Atom ID for "Alice"
const predicateId = 456n // Atom ID for "knows"
const objectId = 789n    // Atom ID for "Bob"
const initialDeposit = parseEther("0.1")

const result = await createTriple(
  MULTIVAULT_CONTRACT_ADDRESS,
  subjectId,
  predicateId,
  objectId,
  initialDeposit,
  walletClient,
  publicClient
)`}
</pre>
</div>
</div>

## Vault Management

Each triple creates two vaults:

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Positive Vault</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
For users who believe the triple is true. Deposits here signal agreement.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Negative Vault</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
For users who believe the triple is false. Deposits here signal disagreement.
</p>
</div>

</div>

## Best Practices

- Validate all atom IDs before creating triples
- Check for existing triples to avoid duplicates
- Estimate costs before executing transactions
- Implement proper error handling and user feedback
- Use multicall patterns for batch operations

## Next Steps

After creating triples, explore:

- [Deposit & Return](/guides/developer-tools/interactions/deposit-return) - Manage vault deposits and withdrawals
- [Retrieve Vault Details](/guides/developer-tools/interactions/retrieve-vault-details) - Get comprehensive vault information

For a full reference implementation, see the [Intuition TypeScript SDK](https://github.com/0xIntuition/intuition-ts). 

---

### File: docs/guides/developer-tools/interactions/deposit-return.md


# Deposit & Return

Managing deposits and withdrawals from vaults in the Intuition protocol involves interacting with the EthMultiVault contract to stake and unstake tokens. This process includes proper fee handling and share price calculations.

## Prerequisites

This implementation guide assumes that you've completed the setup steps in the [Overview](/guides/developer-tools/interactions/overview) guide. Steps for creating the `createMultivaultContract` and the `publicClient` referenced in this implementation example can be found in the overview.

## Implementation

We recommend creating a `multivault.ts` that includes the following deposit and withdrawal functionality:

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Core Deposit Pattern</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// Deposit into vault
const depositConfig = {
  ...multiVaultContract,
  functionName: 'deposit',
  args: [vaultId, amount],
}

// Execute transaction
const hash = await walletClient.writeContract(depositConfig)`}
</pre>
</div>
</div>

## Key Functions

We use these patterns to manage vault deposits and withdrawals:

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>deposit</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Deposit tokens into a vault and receive shares based on current share price.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>withdraw</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Withdraw tokens from a vault by burning shares at current share price.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>estimateDeposit</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Estimate the number of shares received for a given deposit amount.
</p>
</div>

</div>

## Usage Examples

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Basic Deposit</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// Deposit into vault
const vaultId = 123n
const amount = parseEther("0.1")

const result = await deposit(
  MULTIVAULT_CONTRACT_ADDRESS,
  vaultId,
  amount,
  walletClient,
  publicClient
)`}
</pre>
</div>
</div>

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Basic Withdrawal</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// Withdraw from vault
const vaultId = 123n
const shares = parseEther("10")

const result = await withdraw(
  MULTIVAULT_CONTRACT_ADDRESS,
  vaultId,
  shares,
  walletClient,
  publicClient
)`}
</pre>
</div>
</div>

## Fee Structure

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Understanding Fees</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Entry Fee</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Fee charged when depositing into a vault, calculated as a percentage of deposit.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Exit Fee</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Fee charged when withdrawing from a vault, calculated as a percentage of withdrawal.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Protocol Fee</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Fee collected by the protocol for maintaining the system and infrastructure.
</p>
</div>
</div>
</div>

## Share Price Dynamics

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Bonding Curve Mechanics</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Price Discovery</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Share price increases as more tokens are deposited into the vault.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Early Adopter Advantage</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Early depositors receive more shares for the same token amount.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Liquidity Provision</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Vaults provide continuous liquidity for depositors and withdrawers.
</p>
</div>
</div>
</div>

## Best Practices

- Always estimate fees before executing transactions
- Consider share price impact when depositing large amounts
- Implement proper error handling for failed transactions
- Monitor vault state and share prices before transactions
- Use multicall patterns for batch operations
- Provide clear feedback to users about fee structures

## Next Steps

After managing deposits and withdrawals, explore:

- [Retrieve Vault Details](/guides/developer-tools/interactions/retrieve-vault-details) - Get comprehensive vault information
- [Create Atom](/guides/developer-tools/interactions/create-atom) - Create atoms to deposit into
- [Create Triple](/guides/developer-tools/interactions/create-triple) - Create triples with associated vaults

For a full reference implementation, see the [Intuition TypeScript SDK](https://github.com/0xIntuition/intuition-ts). 

---

### File: docs/guides/developer-tools/interactions/overview.md


# Contract Interactions Overview

The Intuition protocol's smart contracts manage complex state involving Atoms, Triples, and their associated vaults. When interacting with these primitives, we recommend retrieving state data directly from the EthMultiVault contract.

## Key Concepts

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1.5rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.75rem', color: 'var(--ifm-color-primary)' }}>Multicall Operations</h4>
<p style={{ margin: 0, fontSize: '0.95rem', color: 'var(--ifm-color-emphasis-700)' }}>
Batch multiple read-only contract calls into a single request to reduce RPC calls and improve performance.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.75rem', color: 'var(--ifm-color-primary)' }}>State Management</h4>
<p style={{ margin: 0, fontSize: '0.95rem', color: 'var(--ifm-color-emphasis-700)' }}>
Retrieve comprehensive vault information including assets, share prices, and user positions.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.75rem', color: 'var(--ifm-color-primary)' }}>Configuration Access</h4>
<p style={{ margin: 0, fontSize: '0.95rem', color: 'var(--ifm-color-emphasis-700)' }}>
Access global protocol configuration including fee structures and minimum deposits.
</p>
</div>

</div>

## Implementation Approach

We utilize multicall operations that batch multiple read-only contract calls into a single request. This approach significantly reduces RPC calls and provides data you'll need for contract interactions, such as the `atomCost` that is referenced in the contract interaction guides.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Core Multicall Pattern</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// Core multicall configuration
const coreContractConfigs = [
  {
    ...multiVaultContract,
    functionName: 'vaults',
    args: [vid],
  },
  {
    ...multiVaultContract, 
    functionName: 'currentSharePrice',
    args: [vid],
  },
  // ... additional calls
]

// Execute multicall
const resp: MulticallResponse[] = await publicClient.multicall({
  contracts: coreContractConfigs,
})`}
</pre>
</div>
</div>

## Available Interactions

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(2, 1fr)', gap: '1rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Create Atom</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Learn how to create new atoms and manage their associated vaults.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Create Triple</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Understand how to create triples and manage their relationships.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Deposit & Return</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Manage deposits and withdrawals from vaults with proper fee handling.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Retrieve Vault Details</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Get comprehensive vault information including assets, prices, and positions.
</p>
</div>

</div>

## Prerequisites

Before diving into contract interactions, ensure you have:

- Basic understanding of Intuition's core concepts (Atoms, Triples, Vaults)
- Familiarity with Ethereum development and smart contract interactions
- Knowledge of multicall patterns and batch operations
- Access to the Intuition SDK and development environment

## Next Steps

Explore the specific interaction guides to learn how to:

- Create and manage atoms and triples
- Handle deposits and withdrawals
- Retrieve vault state information
- Implement proper error handling and validation

Each guide provides detailed implementation examples and best practices for working with Intuition's smart contracts. 

---

### File: docs/guides/developer-tools/interactions/retrieve-vault-details.md


# Retrieve Vault Details

The Intuition protocol's EthMultiVault contract manages complex state involving Atoms, Triples, and their associated vaults. When interacting with these primitives, we recommend retrieving the state data directly from the EthMultiVault contract.

We utilize multicall operations that batch multiple read-only contract calls into a single request. This approach significantly reduces RPC calls and provides data you'll need for contract interactions, such as the `atomCost` that is referenced in the contract interaction guides.

## Implementation

This implementation guide assumes that you've completed the steps in the [Overview](/guides/developer-tools/interactions/overview) guide. Steps for creating the `createMultivaultContract` and the `publicClient` referenced in this implementation example can be found in the overview.

We recommend creating a `multivault.ts` that includes the following:

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Core Multicall Configuration</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// createMultiVaultcontract
const multiVaultContract = createMultiVaultContract(contract)

// Core multicall configuration
const coreContractConfigs = [
  {
    ...multiVaultContract,
    functionName: 'vaults',
    args: [vid],
  },
  {
    ...multiVaultContract, 
    functionName: 'currentSharePrice',
    args: [vid],
  },
  // ... additional calls
]

// Execute multicall
const resp: MulticallResponse[] = await publicClient.multicall({
  contracts: coreContractConfigs,
})`}
</pre>
</div>
</div>

## Complete Example

Here is a full example of the multicall pattern used in the `getMultivaultConfig` function:

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Full Implementation</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`export async function getMultiVaultConfig(contract: string) {
  const multiVaultContract = createMultiVaultContract(contract)

  const coreContractConfigs = [
    {
      ...multiVaultContract,
      functionName: 'generalConfig',
      args: [],
    },
    {
      ...multiVaultContract,
      functionName: 'vaultFees',
      args: [0],
    },
    {
      ...multiVaultContract,
      functionName: 'atomConfig',
      args: [],
    },
  ]

  const resp: MulticallResponse[] = await publicClient.multicall({
    contracts: coreContractConfigs,
  })

  const admin = resp[0].result[0] as \`0x\${string}\`
  const protocol_vault = resp[0].result[1] as \`0x\${string}\`
  const fee_denominator = resp[0].result[2] as bigint
  const formatted_fee_denominator = formatUnits(fee_denominator, 18)
  const min_deposit = resp[0].result[3] as bigint
  const formatted_min_deposit = formatUnits(min_deposit, 18)
  const min_share = resp[0].result[4] as bigint
  const formatted_min_share = formatUnits(min_share, 18)
  const entry_fee = resp[1].result[0] as bigint
  const formatted_entry_fee = formatUnits(entry_fee, 18)
  const exit_fee = resp[1].result[1] as bigint
  const formatted_exit_fee = formatUnits(exit_fee, 18)
  const protocol_fee = resp[1].result[2] as bigint
  const formatted_protocol_fee = formatUnits(protocol_fee, 18)
  const atom_cost = resp[2].result[0] as bigint
  const formatted_atom_cost = formatUnits(atom_cost, 18)
  const atom_creation_fee = resp[2].result[1] as bigint
  const formatted_atom_creation_fee = formatUnits(atom_creation_fee, 18)

  return {
    admin,
    protocol_vault,
    fee_denominator: fee_denominator.toString(),
    formatted_fee_denominator,
    min_deposit: min_deposit.toString(),
    formatted_min_deposit,
    min_share: min_share.toString(),
    formatted_min_share,
    entry_fee: entry_fee.toString(),
    formatted_entry_fee,
    exit_fee: exit_fee.toString(),
    formatted_exit_fee,
    protocol_fee: protocol_fee.toString(),
    formatted_protocol_fee,
    atom_cost: atom_cost.toString(),
    formatted_atom_cost,
    atom_creation_fee: atom_creation_fee.toString(),
    formatted_atom_creation_fee,
  } as MultivaultConfig
}`}
</pre>
</div>
</div>

## Key Functions

We use this multicall pattern to retrieve configuration that we're able to use throughout the app:

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>getVaultDetails</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Retrieves comprehensive vault information including total assets, conviction, current share price, fee configurations, user-specific positions, and counter-vault details.
</p>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>getMultiVaultConfig</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Retrieves global protocol configuration including fee structures, minimum deposits, and protocol admin addresses.
</p>
</div>

</div>

## Usage Example

The full `getVaultDetails` function follows the same pattern used in the `getMultiVaultConfig` example but is too large to include in the docs. We recommend looking at the [Intuition TypeScript SDK](https://github.com/0xIntuition/intuition-ts/blob/main/apps/portal/app/.server/multivault.ts) for a full reference implementation.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Basic Usage</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// Fetch vault and countervault details with user positions:
const vaultDetails = await getVaultDetails(
  MULTIVAULT_CONTRACT_ADDRESS,
  vaultId,
  userWallet,
  counterVaultId
)

// Access formatted values such as atom_cost and triple_cost
console.log({
  atomCost: vaultDetails.atom_cost,
  tripleCost: vaultDetails.triple_cost,
})`}
</pre>
</div>
</div>

## Reference Implementation

For a full example of how we implement all of our EthMultiVault multicalls, you can look at a reference implementation in our monorepo:

- [https://github.com/0xIntuition/intuition-ts/blob/main/apps/portal/app/.server/multivault.ts](https://github.com/0xIntuition/intuition-ts/blob/main/apps/portal/app/.server/multivault.ts)

## Best Practices

- Use multicall patterns to reduce RPC calls and improve performance
- Always handle errors gracefully when retrieving vault data
- Cache vault details when possible to reduce redundant calls
- Validate returned data before using it in your application
- Monitor vault state changes and update your UI accordingly

## Next Steps

After retrieving vault details, explore:

- [Create Atom](/guides/developer-tools/interactions/create-atom) - Create atoms and manage their vaults
- [Create Triple](/guides/developer-tools/interactions/create-triple) - Create triples with associated vaults
- [Deposit & Return](/guides/developer-tools/interactions/deposit-return) - Manage vault deposits and withdrawals

For a full reference implementation, see the [Intuition TypeScript SDK](https://github.com/0xIntuition/intuition-ts). 

---

### File: docs/guides/developer-tools/sdks/migration-guide.mdx


# Migrating SDK from v1.5 to v2.0

This guide helps you migrate your code from v1.x to v2.0.0-alpha of the Intuition TypeScript packages. This is a **major version update** with significant breaking changes due to the underlying contract migration from `EthMultiVault` to `MultiVault`.

## Contract Migration Overview

The core smart contract has been upgraded from `EthMultiVault` to `MultiVault`, introducing significant architectural changes that impact all TypeScript libraries built on top.

### Key Contract Changes

#### 1. **ID System Migration**

- **EthMultiVault**: Uses `uint256` for atom/triple IDs
- **MultiVault**: Uses `bytes32` for term IDs (atoms and triples are now "terms")

#### 2. **Terminology Changes**

- **EthMultiVault**: Atoms and Triples as separate entities
- **MultiVault**: Unified "Terms" concept (atoms and triples are both terms)
- **EthMultiVault**: Vault IDs
- **MultiVault**: Term IDs with Curve IDs for bonding curves

#### 3. **Bonding Curve Integration**

- **EthMultiVault**: Limited bonding curve support
- **MultiVault**: Full bonding curve integration with curve IDs for all operations

## Breaking Changes Overview

### Package Version Updates

| Package                 | Previous Version | New Version     |
| ----------------------- | ---------------- | --------------- |
| `@0xintuition/protocol` | `1.0.0-alpha.1`  | `2.0.0-alpha.2` |
| `@0xintuition/sdk`      | `1.0.0-alpha.3`  | `2.0.0-alpha.2` |
| `@0xintuition/graphql`  | `1.0.0-alpha.3`  | `2.0.0-alpha.2` |
| `@0xintuition/cli`      | `0.0.2`          | `2.0.0-alpha.2` |

## 1. Contract Migration Impact

### Contract Function Mapping

The migration from `EthMultiVault` to `MultiVault` requires updating all contract interactions. Here's the complete function mapping:

#### Core Creation Functions

##### Atom Creation

```solidity
// EthMultiVault
function createAtom(bytes atomUri) payable returns (uint256)
function batchCreateAtom(bytes[] atomUris) payable returns (uint256[])

// MultiVault
function createAtoms(bytes[] data, uint256[] assets) payable returns (bytes32[])
```

##### Triple Creation

```solidity
// EthMultiVault
function createTriple(uint256 subjectId, uint256 predicateId, uint256 objectId) payable returns (uint256)
function batchCreateTriple(uint256[] subjectIds, uint256[] predicateIds, uint256[] objectIds) payable returns (uint256[])

// MultiVault
function createTriples(bytes32[] subjectIds, bytes32[] predicateIds, bytes32[] objectIds, uint256[] assets) payable returns (bytes32[])
```

#### Deposit Functions

##### EthMultiVault

```solidity
function depositAtom(address receiver, uint256 id) payable returns (uint256)
function depositTriple(address receiver, uint256 id) payable returns (uint256)
function batchDeposit(address receiver, uint256[] termIds, uint256[] amounts) payable returns (uint256[])
```

##### MultiVault

```solidity
function deposit(address receiver, bytes32 termId, uint256 curveId, uint256 minShares) payable returns (uint256)
function depositBatch(address receiver, bytes32[] termIds, uint256[] curveIds, uint256[] assets, uint256[] minShares) payable returns (uint256[])
```

#### Redeem Functions

##### EthMultiVault

```solidity
function redeemAtom(uint256 shares, address receiver, uint256 id) returns (uint256)
function redeemTriple(uint256 shares, address receiver, uint256 id) returns (uint256)
function batchRedeem(uint256 percentage, address receiver, uint256[] ids) returns (uint256[])
```

##### MultiVault

```solidity
function redeem(address receiver, bytes32 termId, uint256 curveId, uint256 shares, uint256 minAssets) returns (uint256)
function redeemBatch(address receiver, bytes32[] termIds, uint256[] curveIds, uint256[] shares, uint256[] minAssets) returns (uint256[])
```

### Contract Address Changes: `EthMultiVault` ‚Üí `MultiVault`

**Before:**

```typescript
import { EthMultiVaultAbi } from '@0xintuition/protocol'
import { getEthMultiVaultAddress } from '@0xintuition/sdk'

const address = getEthMultiVaultAddress(chainId)
```

**After:**

```typescript
import { intuitionTestnet, MultiVaultAbi } from '@0xintuition/protocol'
import { getMultiVaultAddressFromChainId } from '@0xintuition/sdk'

const address = getMultiVaultAddressFromChainId(intuitionTestnet.id)
```

### Contract Event Changes

#### EthMultiVault Events

```solidity
event AtomCreated(address indexed creator, address indexed atomWallet, bytes atomData, uint256 vaultId)
event TripleCreated(address indexed creator, uint256 subjectId, uint256 predicateId, uint256 objectId, uint256 vaultId)
```

#### MultiVault Events

```solidity
event AtomCreated(address indexed creator, bytes32 indexed termId, bytes atomData, address atomWallet)
event TripleCreated(address indexed creator, bytes32 indexed termId, bytes32 subjectId, bytes32 predicateId, bytes32 objectId)
```

### Data Structure Migration

#### ID Handling Update

```typescript
// Before (EthMultiVault)
const atomId: bigint = 123n;
const tripleId: bigint = 456n;

// After (MultiVault)
const atomId: `0x${string}` = "0x1234..."; // 32-byte hash
const tripleId: `0x${string}` = "0x5678..."; // 32-byte hash
```

#### Query Functions

```solidity
// EthMultiVault
function atoms(uint256 atomId) view returns (bytes)
function getTripleAtoms(uint256 id) view returns (uint256, uint256, uint256)

// MultiVault
function atom(bytes32 atomId) view returns (bytes)
function getAtom(bytes32 atomId) view returns (bytes)
function triple(bytes32 tripleId) view returns (bytes32, bytes32, bytes32)
function getTriple(bytes32 tripleId) view returns (bytes32, bytes32, bytes32)
```

#### Share and Asset Conversions

```solidity
// EthMultiVault
function convertToShares(uint256 assets, uint256 id) view returns (uint256)
function convertToAssets(uint256 shares, uint256 id) view returns (uint256)

// MultiVault
function convertToShares(bytes32 termId, uint256 curveId, uint256 assets) view returns (uint256)
function convertToAssets(bytes32 termId, uint256 curveId, uint256 shares) view returns (uint256)
```

### New MultiVault Features

#### 1. **Utilization Tracking**

```typescript
const userUtilization = await multiVault.getUserUtilizationForEpoch(
  userAddress,
  epoch,
)
const totalUtilization = await multiVault.getTotalUtilizationForEpoch(epoch)
```

#### 2. **Epoch System**

```typescript
const currentEpoch = await multiVault.currentEpoch()
const lastActiveEpoch = await multiVault.lastActiveEpoch(userAddress)
```

#### 3. **Enhanced Fee Management**

```typescript
// Atom wallet deposit fees
const accumulatedFees =
  await multiVault.accumulatedAtomWalletDepositFees(atomWallet)
await multiVault.claimAtomWalletDepositFees(termId)

// Protocol fees by epoch
const protocolFees = await multiVault.accumulatedProtocolFees(epoch)
```

#### 4. **Improved Preview Functions**

```typescript
// Preview with different scenarios
const [shares, assetsAfterFees] = await multiVault.previewDeposit(termId, curveId, assets);
const [shares, assetsAfterFixedFees, assetsAfterFees] = await multiVault.previewAtomCreate(termId, curveId, assets);
```

## 2. TypeScript Library Changes

### Protocol Package (`@0xintuition/protocol`)

#### Atom Creation: Singular ‚Üí Plural

**Before:**

```typescript
import {
  createAtom,
  createAtomCalculateBaseCost,
  createAtomEncode,
} from '@0xintuition/protocol'

// Single atom creation
await createAtom(config, { args: [atomUri], value })

// Encoding
const encodedData = createAtomEncode(atomUri)

// Cost calculation
const cost = await createAtomCalculateBaseCost(config)
```

**After:**

```typescript
import {
  createAtoms,
  createAtomsEncode,
  getAtomCost,
} from '@0xintuition/protocol'

// Atoms creation (supports single or multiple)
await createAtoms(config, {
  args: [
    [atomUri1, atomUri2],
    [assets1, assets2],
  ],
  value,
})

// Encoding
const encodedData = createAtomsEncode([atomUri1, atomUri2], [assets1, assets2])

// Cost calculation
const cost = await getAtomCost(config)
```

#### Triple Creation: Singular ‚Üí Plural

**Before:**

```typescript
import {
  createTriple,
  createTripleCalculateBaseCost,
  createTripleEncode,
} from '@0xintuition/protocol'

await createTriple(config, {
  args: [subjectId, predicateId, objectId],
  value,
})

const encodedData = createTripleEncode(subjectId, predicateId, objectId)
const cost = await createTripleCalculateBaseCost(config)
```

**After:**

```typescript
import {
  createTriples,
  createTriplesEncode,
  getTripleCost,
} from '@0xintuition/protocol'

await createTriples(config, {
  args: [
    [subjectId1, subjectId2],
    [predicateId1, predicateId2],
    [objectId1, objectId2],
    [assets1, assets2],
  ],
  value,
})

const encodedData = createTriplesEncode(
  [subjectId1, subjectId2],
  [predicateId1, predicateId2],
  [objectId1, objectId2],
  [assets1, assets2],
)

const cost = await getTripleCost(config)
```

#### Deposit and Redeem Simplification

**Before:**

```typescript
import {
  depositAtom,
  depositAtomEncode,
  depositTriple,
  depositTripleEncode,
  redeemAtom,
  redeemAtomEncode,
  redeemTriple,
  redeemTripleEncode,
} from '@0xintuition/protocol'

// Separate functions for atoms and triples
await depositAtom(config, { args: [receiver, atomId], value })
await depositTriple(config, { args: [receiver, tripleId], value })
await redeemAtom(config, { args: [shares, receiver, atomId] })
await redeemTriple(config, { args: [shares, receiver, tripleId] })
```

**After:**

```typescript
import {
  deposit,
  depositEncode,
  redeem,
  redeemEncode,
} from '@0xintuition/protocol'

// Unified functions for any vault (atom or triple)
await deposit(config, {
  args: [receiver, termId, curveId, assets, minShares],
  value,
})
await redeem(config, { args: [receiver, termId, cirveId, shares, minAssets] })

// Unified encoding
const depositData = depositEncode(receiver, vaultId)
const redeemData = redeemEncode(shares, receiver, vaultId)
```

#### Batch Operations Renamed

**Before:**

```typescript
import {
  batchCreateAtom,
  batchCreateTriple,
  batchDepositCurve,
  batchRedeemCurve,
} from '@0xintuition/protocol'
```

**After:**

```typescript
import {
  createAtoms, // Replaces batchCreateAtom
  createTriples, // Replaces batchCreateTriple
  depositBatch, // Replaces batchDepositCurve
  redeemBatch, // Replaces batchRedeemCurve
} from '@0xintuition/protocol'
```

#### Multicall Function Name

**Before:**

```typescript
import { multiCallIntuitionConfigs } from '@0xintuition/protocol'

const config = await multiCallIntuitionConfigs({ address, publicClient })
```

**After:**

```typescript
import { multicallIntuitionConfig } from '@0xintuition/protocol'

const config = await multicallIntuitionConfig({ address, publicClient })
```

#### Removed EthMultiVault API

**Before:**

```typescript
import { EthMultiVault } from '@0xintuition/protocol'

const ethMultiVault = new EthMultiVault({ publicClient, walletClient })
const result = await ethMultiVault.createAtom('hello')
```

**After:**

```typescript
import {
  getMultiVaultAddressFromChainId,
  intuitionTestnet,
  MultiVaultAbi,
} from '@0xintuition/protocol'

import { getContract } from 'viem'

const multiVault = getContract({
  abi: MultiVaultAbi,
  address: getMultiVaultAddressFromChainId(intuitionTestnet.id),
  client: {
    public: publicClient,
    wallet: walletClient,
  },
})

const atomCost = await multiVault.read.getAtomCost()
const result = await multiVault.createAtoms([['hello'], [atomCost]], {
  value: atomCost,
})
```

### Bonding Curve Integration

The new `MultiVault` contract requires curve IDs for all operations:

```typescript
// MultiVault requires curve ID for all operations
const defaultCurveId = await multiVault.getBondingCurveConfig().defaultCurveId

// Use in all deposit/redeem operations
await multiVault.deposit(receiver, termId, defaultCurveId, minShares, {
  value: assets,
})
```

### Migration Steps

#### Step 1: Update Function Calls

##### Creating Atoms

```typescript
// Before
const atomId = await ethMultiVault.createAtom(atomData, { value: fee });

// After
const atomIds = await multiVault.createAtoms([atomData], [assets], { value: totalValue });
const atomId = atomIds[0];
```

##### Depositing

```typescript
// Before
const shares = await ethMultiVault.depositAtom(receiver, atomId, { value: assets });

// After
const shares = await multiVault.deposit(receiver, termId, curveId, minShares, { value: assets });
```

##### Redeeming

```typescript
// Before
const assets = await ethMultiVault.redeemAtom(shares, receiver, atomId);

// After
const assets = await multiVault.redeem(receiver, termId, curveId, shares, minAssets);
```

## 3. SDK Package Changes (`@0xintuition/sdk`)

### API Function Renaming

**Before:**

```typescript
import { getAtom, getTriple } from '@0xintuition/sdk'

const atomData = await getAtom('124862')
const tripleData = await getTriple('54670')
```

**After:**

```typescript
import { getAtomDetails, getTripleDetails } from '@0xintuition/sdk'

const atomData = await getAtomDetails(
  '0x57d94c116a33bb460428eced262b7ae2ec6f865e7aceef6357cec3d034e8ea21',
)
const tripleData = await getTripleDetails(
  '0x4957d3f442acc301ad71e73f26efd6af78647f57dacf2b3a686d91fa773fe0b6',
)
```

### Triple Creation Parameter Changes

**Before:**

```typescript
import { createTripleStatement } from '@0xintuition/sdk'

const triple = await createTripleStatement(config, {
  args: [subjectVaultId, predicateVaultId, objectVaultId],
  depositAmount: 1000000000000000000n, // Optional
})
```

**After:**

```typescript
import { createTripleStatement } from '@0xintuition/sdk'

const triple = await createTripleStatement(config, {
  args: [
    [subjectVaultId],
    [predicateVaultId],
    [objectVaultId],
    [1000000000000000000n],
  ],
  value: 1000000000000000000n, // Required
})
```

## 4. Configuration Changes

### EthMultiVault Config

```solidity
struct GeneralConfig {
    address admin;
    address protocolMultisig;
    uint256 feeDenominator;
    uint256 minDeposit;
    uint256 minShare;
    uint256 atomUriMaxLength;
    uint256 decimalPrecision;
    uint256 minDelay;
}
```

### MultiVault Config

```solidity
struct GeneralConfig {
    address admin;
    address protocolMultisig;
    uint256 feeDenominator;
    address trustBonding;      // New
    uint256 minDeposit;
    uint256 minShare;
    uint256 atomDataMaxLength; // Renamed
    uint256 decimalPrecision;
    // minDelay removed
}
```

## 5. Removed Functions

The following functions have been removed and replaced:

### Protocol Package

- `createAtom` ‚Üí `createAtoms`
- `createTriple` ‚Üí `createTriples`
- `batchCreateAtom` ‚Üí `createAtoms`
- `batchCreateTriple` ‚Üí `createTriples`
- `depositAtom` / `depositTriple` ‚Üí `deposit`
- `redeemAtom` / `redeemTriple` ‚Üí `redeem`
- `createAtomCalculateBaseCost` ‚Üí `getAtomCost`
- `createTripleCalculateBaseCost` ‚Üí `getTripleCost`
- All curve-specific functions ‚Üí `depositBatch` / `redeemBatch`
- `atoms-by-hash.ts` file completely removed

### SDK Package

- `createThing` ‚Üí `createAtomFromThing`
- `createEthereumAccount` ‚Üí `createAtomFromEthereumAccount`
- `getEthMultiVaultAddress` ‚Üí `getMultiVaultAddressFromChainId`
- `getAtom` ‚Üí `getAtomDetails`
- `getTriple` ‚Üí `getTripleDetails`

## 6. Breaking Changes Summary

1. **All IDs changed from `uint256` to `bytes32`**
2. **Curve ID parameter required for most operations**
3. **Batch functions have different signatures**
4. **Event structures updated**
5. **Some functions renamed or merged**
6. **New slippage protection with `minShares`/`minAssets` parameters**

## 7. Best Practices

1. **Always use the default curve ID** unless you have specific bonding curve requirements
2. **Implement proper slippage protection** with min/max parameters
3. **Handle the new epoch system** for utilization tracking
4. **Update your event listeners** to match new event structures
5. **Use preview functions** to estimate outcomes before transactions

## üìù Summary

This major version update consolidates and simplifies the API while adding new functionality. The main changes are:

- **Contract Migration**: `EthMultiVault` ‚Üí `MultiVault` with architectural improvements
- **ID System**: Changed from `uint256` to `bytes32` for all term identifiers
- **Bonding Curves**: Full integration requiring curve IDs for all operations
- **Singular ‚Üí Plural**: Functions now support batch operations by default
- **Unified APIs**: Simplified deposit/redeem functions for all vault types
- **Enhanced Features**: New utilization tracking, epoch system, and preview functions
- **Event Updates**: Improved event parsing with new event structures

Take your time with the migration and test thoroughly. The new API is more powerful and consistent, providing a better developer experience.

---

### File: docs/guides/developer-tools/sdks/overview.mdx


# Intuition SDK Guide

The Intuition SDK is your toolkit for building with the Intuition Protocol. Think of it as a friendly bridge between your application and Intuition's powerful knowledge graph system.

## What does the SDK do?

The SDK makes it easy to:

- **Create and manage semantic data** - Build atoms (individual pieces of information) and triples (relationships between atoms)
- **Interact with the blockchain** - Handle deposits, withdrawals, and smart contract interactions seamlessly
- **Query the knowledge graph** - Search and retrieve data from Intuition's decentralized database
- **Build user-friendly apps** - Focus on your app's features while the SDK handles the complex protocol interactions

Whether you're building a social platform, a data verification tool, or any application that needs to work with verifiable, decentralized information, the SDK provides the building blocks you need.

The Intuition SDK simplifies development with the Intuition backend systems, providing a clean TypeScript interface for creating and managing Atoms and Triples with ease.

## Installation

### From NPM Registry

Install the SDK using your preferred package manager:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="npm" label="npm" default>

```bash
npm install @0xintuition/sdk
```

</TabItem>
<TabItem value="pnpm" label="pnpm">

```bash
pnpm install @0xintuition/sdk
```

</TabItem>
<TabItem value="bun" label="bun">

```bash
bun install @0xintuition/sdk
```

</TabItem>
</Tabs>

### Local Development

For local development or testing with a custom build:

<Tabs>
<TabItem value="npm-local" label="npm" default>

```bash
# Clone the repository
git clone https://github.com/0xIntuition/intuition-ts.git
cd intuition-ts/packages/sdk

# Install dependencies
npm install

# Build the package
npm run build

# Link locally
npm link

# In your project
npm link @0xintuition/sdk
```

</TabItem>
<TabItem value="pnpm-local" label="pnpm">

```bash
# Clone the repository
git clone https://github.com/0xIntuition/intuition-ts.git
cd intuition-ts/packages/sdk

# Install dependencies
pnpm install

# Build the package
pnpm build

# Link locally
pnpm link --global

# In your project
pnpm link --global @0xintuition/sdk
```

</TabItem>
<TabItem value="bun-local" label="bun">

```bash
# Clone the repository
git clone https://github.com/0xIntuition/intuition-ts.git
cd intuition-ts/packages/sdk

# Install dependencies
bun install

# Build the package
bun run build

# Link locally
bun link

# In your project
bun link @0xintuition/sdk
```

</TabItem>
</Tabs>

## Prerequisites

The SDK requires **viem@2.x.x** to execute reads and writes. Make sure you have it installed:

```bash
npm install viem@^2.0.0
```

## Setup

### Basic Client Configuration

Set up your viem clients for interacting with the Intuition protocol:

```typescript
import {
  getMultiVaultAddressFromChainId,
  intuitionTestnet,
} from '@0xintuition/protocol'

import {
  createPublicClient,
  createWalletClient,
  http,
  privateKeyToAccount,
} from 'viem'

export const address = getMultiVaultAddressFromChainId(intuitionTestnet.id)

export const publicClient = createPublicClient({
  chain: intuitionTestnet,
  transport: http(),
})

const account = privateKeyToAccount(
  '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
)
export const walletClient = createWalletClient({
  chain: intuitionTestnet,
  transport: http(),
  account: account,
})
```

## Supported Networks

The Intuition SDK supports multiple networks:

| Network | Chain ID | Type | Status |
|---------|----------|------|--------|
| Intuition Network | 1155 | Mainnet | ‚úÖ Production |
| Intuition Network Testnet | 13579 | Testnet | ‚úÖ Development |
| Base Mainnet | 8453 | Mainnet | ‚úÖ Production |
| Base Sepolia | 84532 | Testnet | ‚úÖ Development |
| Ethereum Mainnet | 1 | Mainnet | ‚úÖ Production |
| Sepolia | 11155111 | Testnet | ‚úÖ Development |
| Arbitrum One | 42161 | Mainnet | ‚úÖ Production |
| Arbitrum Sepolia | 421614 | Testnet | ‚úÖ Development |

The SDK automatically detects the network and uses the appropriate contract addresses via `getEthMultiVaultAddressFromChainId()`.

**Note**: The Intuition L3 network (Caldera rollup) is currently in development. Access the [Hub](https://intuition-testnet.hub.caldera.xyz/) for L3 network development tools and testing.

## Reading Data

### Fetching Atoms and Triples

```typescript
import { getAtomDetails, getTripleDetails } from '@0xintuition/sdk'

// Get atom data by ID
const atomData = await getAtomDetails(
  '0x57d94c116a33bb460428eced262b7ae2ec6f865e7aceef6357cec3d034e8ea21',
)

// Get triple data by ID
const tripleData = await getTripleDetails(
  '0x4957d3f442acc301ad71e73f26efd6af78647f57dacf2b3a686d91fa773fe0b6',
)

## Creating Triples

Triples connect three atoms in a subject-predicate-object relationship:

```typescript
import { createAtomFromString, createTripleStatement } from '@0xintuition/sdk'

// Create three atoms first
const atom1 = await createAtomFromString(
  { walletClient, publicClient, address },
  'atom1',
)
const atom2 = await createAtomFromString(
  { walletClient, publicClient, address },
  'atom2',
)
const atom3 = await createAtomFromString(
  { walletClient, publicClient, address },
  'atom3',
)

// Create a triple statement connecting the three atoms
const triple = await createTripleStatement(
  { walletClient, publicClient, address },
  {
    args: [atom1.state.termId, atom2.state.termId, atom3.state.termId],
    value: 1000000000000000000n, // 1 ETH in wei for deposit
  },
)
```

## Creating Atoms

### Create Atom from String

The simplest way to create an atom with a text label:

```typescript
import { createAtomFromString } from '@0xintuition/sdk'

const data = await createAtomFromString(
  { walletClient, publicClient, address },
  'is great',
)
```

### Create Atom from IPFS Upload

Create an atom by uploading metadata to IPFS:

```typescript
import { createAtomFromIpfsUpload } from '@0xintuition/sdk'

const data = await createAtomFromIpfsUpload(
  {
    walletClient,
    publicClient,
    address,
    pinataApiKey: 'your-pinata-api-key',
  },
  {
    url: 'https://www.intuition.systems/',
    name: 'Intuition',
    description: 'A decentralized trust protocol',
    image: 'https://example.com/image.png',
    tags: ['decentralized', 'trust', 'protocol'],
    twitter: 'https://twitter.com/intuition_systems',
    github: 'github.com/intuition-systems',
  },
)
```

### Create a Thing

Create an atom representing a structured object:

```typescript
import { createAtomFromThing } from '@0xintuition/sdk'

const data = await createAtomFromThing(
  { walletClient, publicClient, address },
  {
    url: 'https://www.intuition.systems/',
    name: 'Intuition',
    description: 'A decentralized trust protocol',
    image: 'https://example.com/image.png',
  },
)
```

### Create an Ethereum Account

Create an atom representing an Ethereum account:

```typescript
import { createAtomFromEthereumAccount } from '@0xintuition/sdk'

const data = await createAtomFromEthereumAccount(
  { walletClient, publicClient, address },
  {
    address: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045',
    chainId: 1, // Mainnet
  },
)
```

### Batch Operations

The SDK provides efficient batch operations for creating multiple atoms at once:

#### Batch Create Atoms from IPFS URIs

```typescript
import {
  batchCreateAtomsFromIpfsUris,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromIpfsUris(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    'ipfs://bafkreib7534cszxn2c6qwoviv43sqh244yfrxomjbealjdwntd6a7atq6u',
    'ipfs://bafkreicq2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q',
  ],
)
```

#### Batch Create Atoms from Smart Contracts

```typescript
import {
  batchCreateAtomsFromSmartContracts,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromSmartContracts(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    '0xA0b86a33E6441b8c4C8C8C8C8C8C8C8C8C8C8C8C',
    '0xB1c97a44E7551b9d5C8C8C8C8C8C8C8C8C8C8C8C8C',
  ],
)
```

#### Batch Create Atoms from Ethereum Accounts

```typescript
import {
  batchCreateAtomsFromEthereumAccounts,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromEthereumAccounts(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    { address: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', chainId: 1 },
    { address: '0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6', chainId: 1 },
  ],
)
```

#### Batch Create Atoms from Things

```typescript
import {
  batchCreateAtomsFromThings,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromThings(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    {
      url: 'https://www.intuition.systems/',
      name: 'Intuition',
      description: 'A decentralized trust protocol.',
      image: 'https://example.com/image.png',
    },
    {
      url: 'https://example.com/',
      name: 'Example',
      description: 'An example thing.',
      image: 'https://example.com/example.png',
    },
  ],
)
```

#### Batch Create Triple Statements

```typescript
import {
  batchCreateTripleStatements,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateTripleStatements(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    { args: [atom1.state.vaultId, atom2.state.vaultId, atom3.state.vaultId] },
    { args: [atom4.state.vaultId, atom5.state.vaultId, atom6.state.vaultId] },
  ],
)
```

## Response Data Structure

After successfully creating a new Atom, the SDK returns a data object containing:

```typescript
const data: {
    uri: string
    transactionHash: `0x${string}`;
    state: {
        creator: Address,
        termId: Hex,
        atomData: Hex,
        atomWallet: Address
    };
}
```

## React Integration Example

Here's a complete React component that creates an atom from structured metadata:

```tsx
import * as React from 'react'

import {
  createAtomFromThing,
  getMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

import { useChainId, usePublicClient, useWalletClient } from 'wagmi'

type IntuitionButton = React.HTMLAttributes<HTMLElement>

const IntuitionButton = ({ children, className }: IntuitionButton) => {
  const chainId = useChainId()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()

  const handleClick = async () => {
    const multiVaultAddress = getMultiVaultAddressFromChainId(chainId)
    const data = await createAtomFromThing(
      { walletClient, publicClient, address: multiVaultAddress },
      {
        url: 'https://www.intuition.systems/',
        name: 'Intuition',
        description: 'A decentralized trust protocol.',
        image: 'https://example.com/image.png',
      },
    )
  }

  return <button onClick={handleClick}>Create Thing</button>
}

export { IntuitionButton }
```

## Development

### Building the SDK

<Tabs>
<TabItem value="npm-build" label="npm" default>

```bash
npm run build
```

</TabItem>
<TabItem value="pnpm-build" label="pnpm">

```bash
pnpm build
```

</TabItem>
<TabItem value="bun-build" label="bun">

```bash
bun run build
```

</TabItem>
</Tabs>

### Running Tests

<Tabs>
<TabItem value="npm-test" label="npm" default>

```bash
npm test
```

</TabItem>
<TabItem value="pnpm-test" label="pnpm">

```bash
pnpm test
```

</TabItem>
<TabItem value="bun-test" label="bun">

```bash
bun test
```

</TabItem>
</Tabs>



## Resources

- [NPMJS/Intuition](https://www.npmjs.com/package/@0xintuition/sdk)
- [Github Repo](https://github.com/0xIntuition/intuition-ts/tree/main/packages/sdk)
- [Intuition Discord](https://discord.gg/intuition)

## Contributing

Contributions are welcome! Please see the main repository for more information on how to contribute.

---

### File: docs/guides/economics/overview.md


# Economics

Intuition transforms every digital interaction into an economic opportunity. Every like, comment, review, connection, and action you take across the web becomes an economic bet, allowing you to buy meaningful ownership in any piece of data.

## $TRUST Token

The native token $TRUST enables users to:
- Accumulate stake in the information you believe in
- Retain true ownership of what you create
- Earn as that data gains traction and value across the network

## Trust Whitepaper

For a comprehensive understanding of Intuition's economic model and theoretical foundations, read our [Trust Whitepaper](https://cdn.prod.website-files.com/65cdf366e68587fd384547f0/68316bdfe42a265d3dc45498_trust-whitepaper.pdf).

## $TRUST Tokenomics

Learn about the $TRUST token economics, distribution, and utility in our detailed [$TRUST tokenomics overview](https://app.forgd.com/share/trust/9837b0d0-e11f-410f-80e6-62a0b6fe13ff/public).

---

### File: docs/guides/introduction/index.md


<a href="/docs/introduction/overview" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>
<div style={{
  backgroundImage: 'linear-gradient(rgba(0, 0, 0, 0.75), rgba(64, 64, 64, 0.85)), url(/img/Intro_int.png)',
  backgroundSize: 'cover',
  backgroundPosition: 'center',
  backgroundBlendMode: 'overlay',
  borderRadius: '16px',
  padding: '4rem 2rem',
  marginBottom: '3rem',
  color: 'white',
  textAlign: 'center',
  cursor: 'pointer',
  transition: 'all 0.3s ease'
}}>
  <h1 style={{
    fontSize: '3rem',
    fontWeight: '700',
    marginBottom: '1rem',
    textShadow: '0 2px 4px rgba(0,0,0,0.5)'
  }}>
    The Trust Protocol
  </h1>
  <p style={{
    fontSize: '1.25rem',
    opacity: '0.95',
    maxWidth: '800px',
    margin: '0 auto',
    lineHeight: '1.6',
    textShadow: '0 1px 2px rgba(0,0,0,0.3)'
  }}>
    Building the world's first open and semantic knowledge graph. A universal data layer that enables trustful interactions at scale.
  </p>
</div>
</a>

## The Vision

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  marginBottom: '3rem'
}}>

Intuition is building the world's first **open and semantic token-curated knowledge graph**, decoupling identities, data, and algorithms from the application layer. This universal and permissionless data lake opens the door to a new pillar of the decentralized web - a **trustful interaction layer**.

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))',
  gap: '2rem',
  marginTop: '2rem'
}}>

<div className="vision-card" style={{
  textAlign: 'center',
  padding: '2rem 1.5rem',
  backgroundColor: 'var(--ifm-background-color)',
  borderRadius: '12px',
  border: '1px solid var(--ifm-color-emphasis-200)',
  transition: 'all 0.3s ease'
}}>
<div style={{
  width: '80px',
  height: '80px',
  borderRadius: '20px',
  background: 'var(--ifm-color-emphasis-800)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  margin: '0 auto 1.5rem auto',
  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)'
}}>
<svg width="40" height="40" viewBox="0 0 24 24" fill="white">
<path d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M12,8A4,4 0 0,0 8,12A4,4 0 0,0 12,16A4,4 0 0,0 16,12A4,4 0 0,0 12,8Z"/>
</svg>
</div>
<h4 style={{ marginBottom: '1rem', color: 'var(--ifm-color-primary)', fontSize: '1.1rem', fontWeight: '600' }}>Universal Data Layer</h4>
<p style={{ margin: 0, fontSize: '0.95rem', lineHeight: '1.6', color: 'var(--ifm-color-emphasis-700)' }}>
Decoupled from applications, accessible everywhere
</p>
</div>

<div className="vision-card" style={{
  textAlign: 'center',
  padding: '2rem 1.5rem',
  backgroundColor: 'var(--ifm-background-color)',
  borderRadius: '12px',
  border: '1px solid var(--ifm-color-emphasis-200)',
  transition: 'all 0.3s ease'
}}>
<div style={{
  width: '80px',
  height: '80px',
  borderRadius: '20px',
  background: 'var(--ifm-color-emphasis-800)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  margin: '0 auto 1.5rem auto',
  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)'
}}>
<svg width="40" height="40" viewBox="0 0 24 24" fill="white">
<path d="M9,12L11,14L15,10L13,8L11,10L9,12M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2Z"/>
</svg>
</div>
<h4 style={{ marginBottom: '1rem', color: 'var(--ifm-color-primary)', fontSize: '1.1rem', fontWeight: '600' }}>Trustful Interactions</h4>
<p style={{ margin: 0, fontSize: '0.95rem', lineHeight: '1.6', color: 'var(--ifm-color-emphasis-700)' }}>
Verifiable facts and subjective opinions coexist
</p>
</div>

<div className="vision-card" style={{
  textAlign: 'center',
  padding: '2rem 1.5rem',
  backgroundColor: 'var(--ifm-background-color)',
  borderRadius: '12px',
  border: '1px solid var(--ifm-color-emphasis-200)',
  transition: 'all 0.3s ease'
}}>
<div style={{
  width: '80px',
  height: '80px',
  borderRadius: '20px',
  background: 'var(--ifm-color-emphasis-800)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  margin: '0 auto 1.5rem auto',
  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.1)'
}}>
<svg width="40" height="40" viewBox="0 0 24 24" fill="white">
<path d="M17,9H7V7H17M17,13H7V11H17M14,17H7V15H14M12,3A1,1 0 0,1 13,4A1,1 0 0,1 12,5A1,1 0 0,1 11,4A1,1 0 0,1 12,3M19,3H14.82C14.4,1.84 13.3,1 12,1C10.7,1 9.6,1.84 9.18,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3Z"/>
</svg>
</div>
<h4 style={{ marginBottom: '1rem', color: 'var(--ifm-color-primary)', fontSize: '1.1rem', fontWeight: '600' }}>Semantic Structure</h4>
<p style={{ margin: 0, fontSize: '0.95rem', lineHeight: '1.6', color: 'var(--ifm-color-emphasis-700)' }}>
Rich, queryable knowledge graph with meaning
</p>
</div>

</div>

</div>



## Where Trustful Interaction Meets Trustless Code

<div style={{
  display: 'grid',
  gridTemplateColumns: '1fr 1fr',
  gap: '3rem',
  alignItems: 'center',
  marginBottom: '3rem'
}}>

<div>
<p style={{ fontSize: '1.1rem', lineHeight: '1.7', marginBottom: '1.5rem' }}>
At its core, Intuition is building a **knowledge and social graph** that integrates incentive-driven mechanisms, decentralized identifiers, and semantic data structures to lay the foundation for a trustworthy internet.
</p>

<p style={{ fontSize: '1.1rem', lineHeight: '1.7', marginBottom: '1.5rem' }}>
With the introduction of a few novel primitives, Intuition unlocks the ability to **operationalize information and trust** at an unprecedented scale.
</p>

<p style={{ fontSize: '1.1rem', lineHeight: '1.7' }}>
The system provides applications and their users easy access to a **semantically rich dataset** about everything and anything, where both objective facts and subjective opinions can coexist and be validated.
</p>
</div>

<div style={{ textAlign: 'center' }}>
<img src="/img/intro_2.png" alt="Intuition System Overview" style={{ 
  width: '100%', 
  maxWidth: '500px',
  borderRadius: '16px',
  boxShadow: '0 8px 24px rgba(0, 0, 0, 0.12)'
}} />
</div>

</div>

<div style={{
  backgroundColor: 'var(--ifm-color-primary-lightest)',
  border: '1px solid var(--ifm-color-primary-light)',
  borderRadius: '16px',
  padding: '2rem',
  textAlign: 'center',
  marginBottom: '3rem'
}}>
<h3 style={{ marginTop: 0, marginBottom: '1rem', color: 'var(--ifm-color-primary-dark)' }}>
A Semantic Web of Trust
</h3>
<p style={{ margin: 0, color: 'var(--ifm-color-primary-dark)', fontSize: '1.1rem', lineHeight: '1.6' }}>
We believe in a future where **information** is not just stored but made **verifiable**, wrapped in a semantic embrace, mapped by a directed graph of state changes captured on an immutable ledger.
</p>
</div>

## Current Information System Challenges

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  marginBottom: '3rem'
}}>

Intuition offers a new model for trust and identity to address the limitations of the current paradigm:

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
  gap: '2rem',
  marginTop: '2rem'
}}>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  padding: '1.5rem',
  borderRadius: '12px',
  border: '1px solid var(--ifm-color-emphasis-200)'
}}>
<h4 style={{ 
  marginTop: 0, 
  marginBottom: '1rem', 
  color: '#EF4444'
}}>
Verification & Provenance
</h4>
<ul style={{ margin: 0, paddingLeft: '1rem', fontSize: '0.95rem', lineHeight: '1.6' }}>
<li>Difficulty confirming data authenticity</li>
<li>No standard for tracing content origin</li>
</ul>
</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  padding: '1.5rem',
  borderRadius: '12px',
  border: '1px solid var(--ifm-color-emphasis-200)'
}}>
<h4 style={{ 
  marginTop: 0, 
  marginBottom: '1rem', 
  color: '#F59E0B'
}}>
Bias & Inequality
</h4>
<ul style={{ margin: 0, paddingLeft: '1rem', fontSize: '0.95rem', lineHeight: '1.6' }}>
<li>AI models inherit source biases</li>
<li>Skewed insights create mistrust</li>
</ul>
</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  padding: '1.5rem',
  borderRadius: '12px',
  border: '1px solid var(--ifm-color-emphasis-200)'
}}>
<h4 style={{ 
  marginTop: 0, 
  marginBottom: '1rem', 
  color: '#8B5CF6'
}}>
Accountability
</h4>
<ul style={{ margin: 0, paddingLeft: '1rem', fontSize: '0.95rem', lineHeight: '1.6' }}>
<li>Weak contributor accountability</li>
<li>No incentives for accuracy</li>
</ul>
</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  padding: '1.5rem',
  borderRadius: '12px',
  border: '1px solid var(--ifm-color-emphasis-200)'
}}>
<h4 style={{ 
  marginTop: 0, 
  marginBottom: '1rem', 
  color: '#DC2626'
}}>
Privacy & Security
</h4>
<ul style={{ margin: 0, paddingLeft: '1rem', fontSize: '0.95rem', lineHeight: '1.6' }}>
<li>Data collected without transparency</li>
<li>Breaches compromise trust</li>
</ul>
</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  padding: '1.5rem',
  borderRadius: '12px',
  border: '1px solid var(--ifm-color-emphasis-200)'
}}>
<h4 style={{ 
  marginTop: 0, 
  marginBottom: '1rem', 
  color: '#059669'
}}>
Misaligned Incentives
</h4>
<ul style={{ margin: 0, paddingLeft: '1rem', fontSize: '0.95rem', lineHeight: '1.6' }}>
<li>Engagement over accuracy</li>
<li>Sensationalism rewarded</li>
</ul>
</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  padding: '1.5rem',
  borderRadius: '12px',
  border: '1px solid var(--ifm-color-emphasis-200)'
}}>
<h4 style={{ 
  marginTop: 0, 
  marginBottom: '1rem', 
  color: '#1D4ED8'
}}>
Fragmentation
</h4>
<ul style={{ margin: 0, paddingLeft: '1rem', fontSize: '0.95rem', lineHeight: '1.6' }}>
<li>Platforms operate in silos</li>
<li>No unified trust standards</li>
</ul>
</div>

</div>

<div style={{
  backgroundColor: 'var(--ifm-color-success-lightest)',
  border: '1px solid var(--ifm-color-success-light)',
  borderRadius: '12px',
  padding: '1.5rem',
  marginTop: '2rem',
  textAlign: 'center'
}}>
<p style={{ margin: 0, color: 'var(--ifm-color-success-dark)', fontSize: '1.1rem', fontWeight: '500' }}>
Intuition leverages **game theoretic cryptoeconomics** to solve these problems at scale, fostering a truly interoperable web - one more akin to Tim Berners-Lee's vision for the **Semantic Web**.
</p>
</div>

</div>

## Explore Introduction

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(320px, 1fr))',
  gap: '2rem',
  marginBottom: '3rem'
}}>

<a href="/docs/introduction/overview" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<div style={{
  width: '60px',
  height: '60px',
  borderRadius: '16px',
  background: 'linear-gradient(135deg, #3B82F6, #1D4ED8)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: '1.5rem',
  boxShadow: '0 4px 12px rgba(59, 130, 246, 0.3)'
}}>
<svg width="28" height="28" viewBox="0 0 24 24" fill="white">
<path d="M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3M13,13H11V7H13V13M13,17H11V15H13V17Z"/>
</svg>
</div>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>Overview</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem'
}}>
Learn about Intuition's core concepts, architecture, and economic model. Understand how the system works and what makes it unique.
</p>
<div style={{ fontSize: '0.9rem', color: 'var(--ifm-color-primary)', fontWeight: '500' }}>
Architecture ‚Ä¢ Economics ‚Ä¢ Vision
</div>
</div>
</a>

<a href="/docs/introduction/why-intuition" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<div style={{
  width: '60px',
  height: '60px',
  borderRadius: '16px',
  background: 'linear-gradient(135deg, #10B981, #047857)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: '1.5rem',
  boxShadow: '0 4px 12px rgba(16, 185, 129, 0.3)'
}}>
<svg width="28" height="28" viewBox="0 0 24 24" fill="white">
<path d="M11,9H13V7H11M12,20C7.59,20 4,16.41 4,12C4,7.59 7.59,4 12,4C16.41,4 20,7.59 20,12C20,16.41 16.41,20 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M11,17H13V11H11V17Z"/>
</svg>
</div>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>Why Intuition?</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem'
}}>
Learn about the challenges Intuition addresses and our unique approach to building a decentralized knowledge graph.
</p>
<div style={{ fontSize: '0.9rem', color: 'var(--ifm-color-primary)', fontWeight: '500' }}>
Problems ‚Ä¢ Solutions ‚Ä¢ Vision
</div>
</div>
</a>

<a href="/docs/introduction/the-primitives" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<div style={{
  width: '60px',
  height: '60px',
  borderRadius: '16px',
  background: 'linear-gradient(135deg, #7C3AED, #A855F7)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: '1.5rem',
  boxShadow: '0 4px 12px rgba(124, 58, 237, 0.3)'
}}>
<svg width="28" height="28" viewBox="0 0 24 24" fill="white">
<path d="M12,2L13.09,8.26L22,9L13.09,9.74L12,16L10.91,9.74L2,9L10.91,8.26L12,2Z"/>
</svg>
</div>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>Primitives</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem'
}}>
Dive deep into the fundamental building blocks: Atoms, Triples, and Signal. Learn how these primitives work together to create structured, semantic data.
</p>
<div style={{ fontSize: '0.9rem', color: 'var(--ifm-color-primary)', fontWeight: '500' }}>
Atoms ‚Ä¢ Triples ‚Ä¢ Signals
</div>
</div>
</a>

<a href="/docs/resources/key-terms" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<div style={{
  width: '60px',
  height: '60px',
  borderRadius: '16px',
  background: 'linear-gradient(135deg, #F59E0B, #D97706)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: '1.5rem',
  boxShadow: '0 4px 12px rgba(245, 158, 11, 0.3)'
}}>
<svg width="28" height="28" viewBox="0 0 24 24" fill="white">
<path d="M12,3C7.58,3 4,4.79 4,7C4,9.21 7.58,11 12,11C16.42,11 20,9.21 20,7C20,4.79 16.42,3 12,3M4,9V12C4,14.21 7.58,16 12,16C16.42,16 20,14.21 20,12V9C20,11.21 16.42,13 12,13C7.58,13 4,11.21 4,9M4,14V17C4,19.21 7.58,21 12,21C16.42,21 20,19.21 20,17V14C20,16.21 16.42,18 12,18C7.58,18 4,16.21 4,14Z"/>
</svg>
</div>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>Key Terms</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem'
}}>
Master the essential terminology and concepts that form the foundation of the Intuition ecosystem and knowledge graph.
</p>
<div style={{ fontSize: '0.9rem', color: 'var(--ifm-color-primary)', fontWeight: '500' }}>
Glossary ‚Ä¢ Concepts ‚Ä¢ Definitions
</div>
</div>
</a>

</div> 

---

### File: docs/guides/introduction/overview.md


# Overview

## Intuition at a Glance

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '2rem', borderRadius: '12px', marginBottom: '2rem' }}>
<p style={{ fontSize: '1.25rem', lineHeight: '1.8', margin: '0 0 1rem 0', color: 'var(--ifm-color-emphasis-800)', fontWeight: '500' }}>
Intuition is a decentralized system that makes attestations viable as a meta for digital expression. 

A universal language for signed data.

Instead of information living as unstructured, siloed, minimally-attributable data in Web2 platforms, Intuition turns information into verifiable, tokenized, and portable objects that can flow across apps, chains, and agents.
</p>
<p style={{ fontSize: '1.1rem', lineHeight: '1.7', margin: 0, color: 'var(--ifm-color-emphasis-900)' }}>
<strong>The result is a Semantic Web of Trust, powered the world's first token-curated knowledge graph</strong> ‚Äî a network where information isn't just stored, but structured, incentivized, and made usable for developers and AI systems alike ‚Äî all while maintaining verifiable provenance and attribution.
</p>
</div>


---

### File: docs/guides/introduction/the-economics/bonding-curves/index.mdx


# Bonding Curves

Bonding curves define how the price of an asset changes based on supply and demand. In the Intuition Protocol, they allow vaults to dynamically price semantic assets like atoms and triples.

A bonding curve is a pricing mechanism ‚Äî it determines how much ETH a user pays (or gets back) when depositing to or redeeming from a vault. This lets projects:

- **Incentivize early participation** with cheaper entry prices.
- **Control supply** with rising costs as more tokens are minted.
- **Align economics** with data value or staking behavior.

Intuition uses bonding curves in the EthMultiVault system to handle deposits and redemptions for both atoms (individual semantic claims) and triples (subject‚Äìpredicate‚Äìobject sets).

## Real-World Use Cases

| Use Case | How Bonding Curves Help |
|----------|-------------------------|
| **Data Markets** | Pay to mint assertions on-chain; rising cost controls spam. |
| **Staking Derivatives** | Price increases with TVL, modeling yield or scarcity. |
| **Protocol Governance** | Curves can align incentives for governance participation. |
| **Custom Economies** | Plug in your own math logic via custom curves. |

## Design Philosophy

Bonding curves in Intuition Protocol are modular by design:

- **Registry-based routing**: Vaults remain clean and upgrade-safe.
- **Symmetrical math API**: All curves implement the same interface.
- **Upgradeable curves**: Developers can ship custom curves anytime ‚Äî no need to upgrade the vault.

In upcoming versions (V2), we'll simplify things even further by removing suffixes like `depositAtomCurve`, replacing them with a unified API keyed by `curveId`.

## How Bonding Curves Fit into the Protocol

Here's the basic architecture:

```
User / dApp
   ‚îÇ
   ‚ñº
EthMultiVault
   ‚îú‚îÄ Standard paths (Linear math inline)
   ‚îî‚îÄ Curve-specific paths
        ‚îÇ
        ‚ñº
BondingCurveRegistry ‚îÄ‚îÄ‚Üí BaseCurve (Linear, OffsetProgressive, custom...)
```

- **EthMultiVault** handles deposits/redemptions.
- If a non-linear curve is specified, it routes to the **BondingCurveRegistry**.
- The registry proxies math to the appropriate curve contract using a `curveId`.

## Curve Types

### Linear Curve 
#### (curveId = 1)

A simple, pro-rata pricing model where every deposit gets the same rate:

```solidity
price = totalAssets / totalShares;
```

This is the default math embedded directly into EthMultiVault, but we include a separate LinearCurve contract for compatibility and future flexibility.

:::tip
Great for simple, predictable token issuance.
:::

### Offset Progressive Curve 
#### (curveId = 4)

A more dynamic curve where price increases linearly based on total supply:

```math
P(s) = m ‚àó (s + offset)
```

Mint cost is the area under the curve, meaning early deposits are cheaper:

```math
Cost = (m/2) ‚àó [(s‚ÇÇ + offset)¬≤ ‚àí (s‚ÇÅ + offset)¬≤]
```

Redemption returns are also curve-aware:

```math
Return = (m/2) ‚àó [2 ‚àó (s + offset) ‚àó r ‚àí r¬≤]
```

Where:
```math
- **s** = current shares
- **r** = shares being redeemed
```

:::tip 
Ideal for data markets and staking derivatives ‚Äî you can reward early supporters and make each additional share more expensive.
:::

## Interactive Demo

Try out different bonding curve types and see how they affect pricing:

import BondingCurveDemo from '@site/src/components/BondingCurveDemo';

<BondingCurveDemo />

## Code Examples

### Deposit Using a Curve

Deposit ETH into a vault with the Offset Progressive curve:

```solidity
EthMultiVault.depositAtomCurve{value: amountETH}(
    msg.sender,   // receiver of shares
    atomId,       // which atom to deposit into
    4             // curveId for OffsetProgressive
);
```

### Preview Deposit in Frontend

Estimate how many shares a user would get before committing ETH:

```cpp
uint256 shares = vault.previewDepositCurve(amountETH, atomId, 4);
```

You can also check the current price:

```cpp
uint256 price = registry.currentPrice(totalShares, 4);
```

### Register a New Curve (Admin Only)

If you've written your own curve, you can add it like this:

```cpp
uint256 curveId = registry.addBondingCurve(address(myCustomCurve));
vault.setBondingCurveConfig(address(registry), curveId); // optional
```

You only need to implement the BaseCurve interface to plug in.

## Share Display and User Experience

### Understanding Share Values

Intuition displays share values in a user-friendly format to make ownership easier to understand. The Portal frontend shows one "Share" as 1/100,000th of the 1 ETH-equivalent raw value recorded in smart contracts.

**Why this matters:**
- **Simpler numbers**: Users see whole numbers instead of lengthy decimals
- **Familiar concept**: Similar to how Bitcoin (Satoshis) and Ethereum (Wei) work
- **Clear ownership**: Easier to understand your position size

**Example:**
- Smart contract: 1,000,000 raw units
- Portal display: 10 shares
- Each share = 100,000 raw units

### No Impact on Positions

:::info
**Important**: This is purely a display change. Your actual positions and the underlying smart contracts remain unchanged.
:::

## Summary

- Bonding curves are a flexible pricing tool for atoms and triples.
- Intuition supports multiple curve types, each with their own pricing logic.
- You can preview, extend, or customize bonding behavior with minimal friction.
- The system is secure, upgrade-safe, and open to new economic designs.
- Share display is optimized for user experience while preserving contract integrity.


---

### File: docs/guides/introduction/the-economics/index.md


# The Economics

Intuition is built on the idea that information deserves its own decentralized distribution and financial rails. 

Just as blockchains turned money into programmable assets, Intuition turns information into tokenized, ownable, and composable units that anyone can create and monetize in.

At the core are Atoms (entities) and Triples (relationships). As users publish, curate, and stake on these objects, they generate a token-curated knowledge graph where ownership weights are represented by positions in $TRUST ‚Äî the native token of the Intuition Network and Protocol.

The goal is not to tokenize data just for the sake of a token. The economics of Intuition are designed to:

<div className="uniform-card-grid">

<div className="uniform-card">
<h3 className="uniform-card-title">1. Incentivize Expression</h3>
<ul style={{ margin: 0, paddingLeft: '1.2rem', fontSize: '0.95rem', lineHeight: '1.6' }}>
<li>Users are rewarded for making useful, verifiable attestations</li>
<li>First movers capture outsized rewards for creating identifiers or relationships that prove valuable</li>
<li>The system pays people to contribute knowledge, not just consume it</li>
</ul>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">2. Incentivize Convergence on Canonical Identifiers</h3>
<ul style={{ margin: 0, paddingLeft: '1.2rem', fontSize: '0.95rem', lineHeight: '1.6' }}>
<li>Anyone can permissionlessly create a decentralized identifier (DID) for anything</li>
<li>Instead of fragmenting into infinite duplicates, bonding curves and network effects encourage participants to converge on shared canonical identifiers</li>
<li>This makes Intuition's knowledge graph globally referenceable and interoperable</li>
</ul>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">3. Incentivize Consensus on Standards and Structures</h3>
<ul style={{ margin: 0, paddingLeft: '1.2rem', fontSize: '0.95rem', lineHeight: '1.6' }}>
<li>Communities can propose schemas and data formats (e.g., predicates like <code>foundedBy</code>, <code>headquarteredIn</code>)</li>
<li>Rewards flow toward attestations that align with commonly adopted standards</li>
<li>Over time, the protocol nudges participants into consensus-driven data structures, so the web of knowledge doesn't just grow ‚Äî it grows in a structured, interoperable way</li>
</ul>
</div>

</div>


---

### File: docs/guides/introduction/the-primitives/fundamentals/atoms.md


# Atoms

A system facilitating the arrival at social consensus around globally persistent canonical identifiers for all things demands that these identifiers possess a few key attributes.

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1.5rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Decentralized Identifiers</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
These identifiers should be decentralized identifiers, providing unique, secure, and verifiable identification without any reliance on a central authority.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Unique</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Secure</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Verifiable</span>
</div>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Associated Data</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
These identifiers should have a sufficient amount of associated data to ensure precise referencing of specific entities, concepts, or pieces of information.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Contextual</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Precise</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Referenced</span>
</div>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Agent-Centric State</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
These identifiers must have some agent-centric state that is capable of tracking the usage of the identifier across contexts.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Trackable</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Usage</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Contexts</span>
</div>
</div>

</div>

## The Atom Solution

To solve for these requirements, the concepts of Atoms emerge as the foundation of the Intuition framework, representing the most fundamental units of data. These units can range from a single word to a complex concept, serving as discrete, manageable, and referenceable pieces of information that facilitate seamless data integration and manipulation across the web.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Key Benefits of Atoms</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Universal Reference</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Start to reference data universally across the web.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>User Equity</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Grant users equity in data as they signal its relevancy through usage.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Active Participation</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Reward users for signaling the relevancy of data, encouraging active participation.
</p>
</div>
</div>
</div>

Each Atom is made universally referenceable through a decentralized identifier. This approach ensures that every Atom is uniquely identifiable and can be consistently referenced across the web, maintaining data integrity and meaning regardless of the system or context.

## Decentralized Identifiers (DIDs)

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Example DID</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<pre style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
{`// An example DID

did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736

// An example DID Document

{
    "id": "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736",
    "verificationMethod": [
        {
            "id": "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736#controller",
            "type": "EcdsaSecp256k1RecoveryMethod2020",
            "controller": "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736",
            "blockchainAccountId": "eip155:1:0x3b0BC51Ab9De1e5B7B6E34E5b960285805C41736"
        }
    ],
    "authentication": [
        "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736#controller"
    ],
    "assertionMethod": [
        "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736#controller"
    ],
    "@context": [
        "https://www.w3.org/ns/did/v1",
        "https://w3id.org/security/suites/secp256k1recovery-2020/v2",
        "https://w3id.org/security/v3-unstable"
    ]
}`}
</pre>
</div>
</div>

## Data Requirements

To ensure reliable referencing of entities, concepts, or data within an Atom, each Atom must include at least minimal corresponding data. This data can be of any type, stored anywhere, and presented in any format.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Recommended Data Practices</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Verifiable Data Registry</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Use a Verifiable Data Registry to strengthen data usability through guarantees around immutability, availability, liveness, and persistence.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Supported Structures</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Adhere to supported data structures and schemas for better interoperability and reliability.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Timestamp Inclusion</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
For mutable data, include a timestamp to ensure future references understand exactly what the data represented at the moment of attestation.
</p>
</div>
</div>
</div>

The uniqueness of each Atom is enforced by hashing its underlying data, preventing duplicate Atoms for the same piece of data. This approach allows Atoms to segment data into discrete, manageable units that can be easily combined and reused across diverse contexts and applications.

## Atom Ownership and Token Curated Registries

Given the permissionless nature of the system, multiple Atoms may be representative of the same concept. To foster consensus on high-quality Atoms and establish canonical identifiers for all things, Intuition employs the concept of a Token Curated Registry (TCR).

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>TCR Benefits</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Fractional Ownership</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Users gain fractional ownership over the Atoms they interact with and receive a portion of the interaction fees each respective Atom generates.
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Incentivized Engagement</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
This model incentivizes engagement with popular Atoms, encouraging active participation in the ecosystem.
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Quality Ranking</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
A TCR emerges, ranking Atoms based on their relevance using metrics such as an Atom's Total Value Locked (TVL).
</p>
</div>
</div>
</div>

As users increasingly interact with these Atoms, a TCR emerges, ranking Atoms based on their relevance using metrics such as an Atom's Total Value Locked (TVL). This mechanism facilitates ecosystem convergence on and easy discoverability of the most valuable and widely accepted Atoms/identifiers representing each concept.

## Next Steps

Now that you understand Atoms, explore:

- [Triples](/guides/introduction/the-primitives/fundamentals/triples) - Learn how Atoms combine to form relationships
- [Signal](/guides/introduction/the-primitives/fundamentals/signal) - Understand how users interact with Atoms
- [Structuring Atoms](/guides/introduction/the-primitives/structuring/atoms) - Advanced techniques for working with Atoms 

---

### File: docs/guides/introduction/the-primitives/fundamentals/fees-rewards.md


# Fees & Rewards

In the Intuition system, interactions incur a fee similar to the gas costs in blockchain transactions. These fees serve critical roles in maintaining the system's integrity, incentivizing meaningful contributions, and fostering the creation of high-quality, structured data.

## Purpose of Fees in Intuition

### Preventing Abuse and Attacks

Decentralized and permissionless systems face risks such as Sybil and denial-of-service (DoS) attacks. Intuition mitigates these risks through an economic model that introduces fees for data creation.

**Disincentive Against Abuse**: Fees deter malicious activity by imposing a cost on system misuse.

**Network Resilience**: Any attacks inadvertently benefit the system, as fees are still paid, much like Ethereum benefits from transaction fees, even in non-productive use cases.

This mechanism ensures the ecosystem remains robust and sustainable, even in the face of potential misuse.

### Encouraging Active Participation

Merely providing infrastructure for generating verifiable data is insufficient to motivate meaningful contributions.

**Historical Challenges**: Platforms like Amazon, Yelp, and Wikipedia in Web2 face similar participation issues, where most users refrain from contributing reviews or endorsements.

**Economic Incentives**: Intuition mirrors the blockchain model of block rewards, providing tangible incentives to encourage users to create coherent and valuable data.

### Promoting High-Quality Data

The global proliferation of data has led to an overwhelming amount of low-quality, redundant, or irrelevant information.

**Quality Over Quantity**: Intuition shifts the focus from producing more data to generating reliable, actionable insights.

**Economic Mechanisms**: Fees discourage the creation of irrelevant data while rewarding high-quality contributions.

By implementing this model, contributors are incentivized to create data that meets standards of relevance and accuracy, reducing the prevalence of "junk data."

### Establishing Standards Through Incentives

Creating standards in data structures and schemas has traditionally been challenging, often described as "standards hell."

**Expanding Blockchain Principles**: Intuition applies the concept of financial rewards for distributed consensus‚Äîproven in blockchain ecosystems‚Äîto social consensus and global coordination.

**Use Cases**: These principles extend to data structures, schemas, formats, and canonical identifiers.

## Fee Allocation in Intuition

Intuition allocates fees in two key ways:

1. **Granting Ownership in Data**  
A portion of the fee grants users ownership of the data they interact with, promoting responsibility and meaningful engagement.

2. **Rewarding Data Owners**  
Another portion is distributed to existing data owners, incentivizing the creation and maintenance of valuable data.

## Incentivizing Fractal Data Structures

Intuition's data model‚Äîbuilt on Atoms, Triples, and Signal‚Äîallows for programmatic value distribution throughout the system.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Example: YouTube Video Like</h3>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Consider a user who wishes to create a new data entry stating that they like a YouTube video. The user must pay a fee to create this data which rewards previous owners of related data. If the user wishes to obtain ownership in the statement, they must make an initial deposit.
</p>
</div>

Other users who agree with this statement can also deposit to signal their agreement, which pays existing depositors on the Triple and underlying Atoms and increases the share price of the Triple. In other words, future depositors reinforce the validity and increase the value of the underlying data.

**Creating Data**: A user pays a fee to state they like a YouTube video.  
- The Triple creation fee rewards prior owners of related data.  
- The initial deposit grants ownership of the statement.

**Reinforcing Data**: Other users can also stake on the Triple to explicitly agree with the statement, reinforcing its validity and increasing its value.

This model ensures high-quality, relevant data remains prominent while incentivizing accuracy and meaningful contributions.

## Aligning Incentives with Data Structures

Intuition's economic model motivates users to interact with data they believe will gain engagement. The explicit structure of data encourages users to converge on:

* **Entities and Concepts**: Consensus on key data points.
* **Effective References**: Agreement on the best ways to describe and structure data.

This drives fractal consensus, ensuring scalability from individual Atoms to complex nested Triples.

## Promoting a Self-Regulating Ecosystem

By integrating economic incentives, Intuition creates a self-regulating system that achieves:

* **System Security**: Fees deter attacks and ensure robustness.
* **Meaningful Contributions**: Rewards motivate high-quality data creation.
* **Structured Consensus**: Users are incentivized to align on effective data representations.

By integrating these economic principles, Intuition not only secures the system against malicious attacks but also promotes a healthy, self-regulating ecosystem where users are rewarded for their contributions to the integrity and value of the data.

## Next Steps

Now that you understand Fees & Rewards, explore:

- [State Interpretations](/guides/introduction/the-primitives/fundamentals/state-interpretations) - Learn how the system state is interpreted
- [Calculating Rewards](/guides/introduction/the-primitives/structuring/calculating-rewards) - Advanced techniques for reward calculation
- [Signal](/guides/introduction/the-primitives/fundamentals/signal) - Understand how users interact with the economic system 

---

### File: docs/guides/introduction/the-primitives/fundamentals/index.md


# Fundamentals

Master the core concepts that form the foundation of the Intuition system. These fundamentals provide the essential knowledge needed to understand and work with Atoms, Triples, Signal, and the economic mechanisms that drive the ecosystem.

## Explore Fundamentals

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(320px, 1fr))',
  gap: '2rem',
  marginTop: '3rem',
  marginBottom: '3rem'
}}>

<a href="/docs/introduction/the-primitives/fundamentals/atoms" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>Atoms</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-emphasis-700)'
}}>
Learn about the atomic units of knowledge in Intuition - unique, persistent identifiers for all things in the digital universe.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Identifiers</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Persistent</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Decentralized</span>
</div>
</div>
</a>

<a href="/docs/introduction/the-primitives/fundamentals/triples" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>Triples</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-emphasis-700)'
}}>
Discover how Triples create relationships between Atoms, forming the semantic structure of the knowledge graph.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Relationships</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Semantic</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Structured</span>
</div>
</div>
</a>

<a href="/docs/introduction/the-primitives/fundamentals/signal" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>Signal</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-emphasis-700)'
}}>
Understand how Signal expresses intent, belief, and support within the Intuition ecosystem.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Trust</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Belief</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Support</span>
</div>
</div>
</a>

<a href="/docs/introduction/the-primitives/fundamentals/fees-rewards" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>Fees & Rewards</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-emphasis-700)'
}}>
Explore the economic mechanisms that incentivize quality contributions and maintain system integrity.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Economics</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Incentives</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Security</span>
</div>
</div>
</a>

<a href="/docs/introduction/the-primitives/fundamentals/state-interpretations" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>State Interpretations</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-emphasis-700)'
}}>
Discover how Intuition's state can be interpreted in countless ways, avoiding "truth lock-in" while enabling flexible analysis.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Flexible</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Algorithms</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Perspectives</span>
</div>
</div>
</a>

<a href="/docs/introduction/the-primitives/fundamentals/intuition-in-practice" style={{ textDecoration: 'none', color: 'inherit' }}>
<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  padding: '2rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<h3 style={{
  marginTop: 0,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-primary)',
  fontSize: '1.25rem',
  fontWeight: '600'
}}>Intuition in Practice</h3>
<p style={{
  fontSize: '0.95rem',
  lineHeight: '1.6',
  flexGrow: 1,
  marginBottom: '1.5rem',
  color: 'var(--ifm-color-emphasis-700)'
}}>
See how Intuition primitives work together in real-world scenarios with practical examples and use cases.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Examples</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Use Cases</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Practical</span>
</div>
</div>
</a>

</div>

## Recommended Reading Order

For the best learning experience, we recommend following this sequence:

1. **Atoms** - Start with the fundamental building blocks
2. **Triples** - Learn how relationships are formed
3. **Signal** - Understand how trust and belief are expressed
4. **Fees & Rewards** - Explore the economic incentives
5. **State Interpretations** - See how the system can be interpreted
6. **Intuition in Practice** - Apply your knowledge to real scenarios

## Next Steps

After mastering the fundamentals, explore:

- **[Structuring](/docs/introduction/the-primitives/structuring)** - Advanced techniques for organizing data
- **[Developer Tools](/docs/developer-tools)** - Practical tools for building with Intuition
- **[Use Cases](/docs/use-cases)** - Real-world applications and examples 

---

### File: docs/guides/introduction/the-primitives/fundamentals/intuition-in-practice.md


# In Practice

The introduction of Intuition's core primitives lays a robust foundation for constructing a system that fosters a trustful interaction layer for the decentralized web. These seemingly basic primitives enable a wide range of powerful functionalities, transforming how we manage identities, data, and trust online.

To illustrate this, consider the experience of buying a product on Amazon. With Intuition's primitives, this process can be reimagined in a decentralized, trustless manner:

## Atoms and Triples

Every user, product, review, and transaction can be represented as discrete objects (Atoms) and linked through relationships (Triples). For instance, a Triple could link a product (Atom) to a review (Atom) through a relationship like "hasReview."

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Example: Product Review System</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Product Atom</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>
did:ethr:mainnet:0x...product123
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Review Atom</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>
did:ethr:mainnet:0x...review456
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Triple Relationship</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>
[Product] [hasReview] [Review]
</p>
</div>
</div>
</div>
</div>

## Signal

Each review can be evaluated for credibility using the Signal primitive. Reviews and Signals from verified purchasers or highly reputable users can carry more weight, helping users discern trustworthy feedback from potentially fraudulent reviews.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Credibility Evaluation</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Verified Purchaser</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Higher signal weight due to confirmed purchase
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Reputable User</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Enhanced credibility based on historical accuracy
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Fraud Detection</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Automatic flagging of suspicious review patterns
</p>
</div>
</div>
</div>
</div>

## Fees, Economics, and Incentives

Users are encouraged to express themselves, and reviewers are incentivized to provide honest and detailed feedback. Users earn money for their valuable data contributions, and their reputation becomes cross-contextual, increasing its significance beyond a single platform.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Cross-Contextual Reputation</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<p style={{ margin: '0 0 1rem 0', fontSize: '0.9rem' }}>
For example, a user's status as a trusted reviewer on Amazon could serve as a valuable reputation data point in other contexts, such as securing better loan-to-value ratios in decentralized finance (DeFi) or enhancing the ability to obtain a loan.
</p>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>DeFi Integration</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Better loan-to-value ratios based on reputation
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Portable Trust</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Reputation follows users across platforms
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Economic Rewards</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Earn tokens for valuable contributions
</p>
</div>
</div>
</div>
</div>

### Portable Social and Trust Graphs

Additionally, users might be more inclined to attest to useful information about products on Amazon because their claims can be easily seen by the people they care about, thanks to portable social and trust graphs. Unlike the current Amazon platform, which lacks a friends list, Intuition allows users to take their singular social graph or a set of trust graphs with them anywhere they go.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Trust Graph Benefits</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Portable Connections</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Take your social graph anywhere you go
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Weighted Reviews</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Trusted individual reviews > anonymous reviews
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Prioritized Insights</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Valuable insights from trusted sources prioritized
</p>
</div>
</div>
</div>
</div>

## Interpretations

The listing of a product on a marketplace such as Amazon can be represented as a literal interpretation. For instance, adding a product to a marketplace can be as straightforward as creating a Triple like [Product][listedOn] [Amazon].

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Stakeholder Interpretations</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<p style={{ margin: '0 0 1rem 0', fontSize: '0.9rem' }}>
Expanding on this concept, various stakeholders can publish their interpretations of product reviews:
</p>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Company Aggregation</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Aggregate all reviews and provide summary scores
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Consumer Protection</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Highlight reviews mentioning safety concerns
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Independent Analysis</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Third-party verification and validation
</p>
</div>
</div>
</div>
</div>

## Algorithms

Users can choose from various algorithms to filter and sort reviews based on their preferences. For instance, an algorithm can prioritize reviews from users with similar purchase histories or highlight reviews that mention specific product features.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Customizable Filtering</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Similar Purchase History</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Prioritize reviews from users with similar tastes
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Feature-Specific</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Highlight reviews mentioning specific features
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Trust-Based</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Weight reviews based on user trust networks
</p>
</div>
</div>
</div>
</div>

## Reality Tunnel

Users can compose together interpretations and algorithms to create curated 'views' of data, allowing them to find the voices they trust among thousands of anonymous voices.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Curated Perspectives</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Composable Views</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Combine interpretations and algorithms
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Trusted Voices</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Find reliable sources among anonymous reviews
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Personalized Experience</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Tailored data presentation based on preferences
</p>
</div>
</div>
</div>
</div>

## Portable Identity and Data

Identities and data become universal, and can be referenced and integrated anywhere across the web. Users can see a product's aggregated reviews across Amazon, Facebook Marketplace, Craigslist, or eBay, provided the same canonical identifier for the products is used in each context.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Universal Data Access</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Cross-Platform Aggregation</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
See reviews from Amazon, Facebook, Craigslist, eBay
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Data Continuity</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Data persists even if platforms shut down
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>User Control</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Maintain control over your digital interactions
</p>
</div>
</div>
</div>
</div>

## The Decentralized Trust Layer

By integrating these primitives into contexts and interactions that cannot yet be fully 'trustless,' Intuition establishes a decentralized trust layer. This layer allows users to interact with confidence, knowing that the information they rely on is transparent, verifiable, and free from centralized manipulation.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Key Benefits</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Transparent Information</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
All data is open and verifiable
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Decentralized Control</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
No single entity controls the data
</p>
</div>
<div>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>User-Centric</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Users maintain control over their data
</p>
</div>
</div>
</div>

For instance, when buying a product, users can access a wealth of credible reviews, filtered and presented according to their preferences, all while maintaining control over their data and identities. By leveraging these tools, we can build a more trustworthy and user-centric digital ecosystem, addressing many of the inherent flaws in the current Web2 trust stack and paving the way for a more decentralized and equitable internet.

## Next Steps

Now that you understand how Intuition primitives work together in practice, explore the [Structuring](/guides/introduction/the-primitives/structuring) section to learn advanced techniques for working with Atoms and Triples in real-world applications. 

---

### File: docs/guides/introduction/the-primitives/fundamentals/signal.md


# Signal

Signal, in the context of Intuition, refers to any action or indication that expresses intent, belief, or support. Signals can be classified into three broad categories: explicit signal, implicit signal, and transitive signal. These signals play a crucial role in interpreting user behavior, beliefs, and preferences within the system.

## Types of Signal

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', gap: '1.5rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Explicit Signal</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
A clear, intentional action taken by a user to express support, belief, or intent. These actions are directly observable and often involve a formal mechanism within the system.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Voting</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Attestations</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Intentional</span>
</div>
<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '0.75rem', borderRadius: '6px', fontSize: '0.875rem' }}>
<strong>Example:</strong> A proof of humanity attestation from Worldcoin is an explicit signal that Worldcoin believes the entity to be human.
</div>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Implicit Signal</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
Indirect or inferred indications of support, belief, or intent. This signal is not always directly observable and are often deduced from user behavior or patterns.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Behavioral</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Inferred</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Patterns</span>
</div>
<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '0.75rem', borderRadius: '6px', fontSize: '0.875rem' }}>
<strong>Example:</strong> The frequency and context of user interactions with certain data points can imply their support or belief.
</div>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Transitive Signal</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
Trust or belief that is passed along through a network of relationships. This type of signal leverages the idea that trust can be extended through connections.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Network</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Trust</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Connections</span>
</div>
<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '0.75rem', borderRadius: '6px', fontSize: '0.875rem' }}>
<strong>Example:</strong> If User A attests to something about User B, and User C trusts User A, then User C extends trust to User B.
</div>
</div>

</div>

## Signal in Intuition

Though all systems naturally generate implicit signal, explicit signal in Intuition is expressed in a novel format that enables and incentivizes the creation of many-to-one, non-deterministic attestations.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Key Innovation</h3>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
In Intuition, these semantic statements do not have a single 'issuer' - instead, anyone/anything can signal support or rejection of any existing statement/attestation at any point in time. This decoupling of information from 'who is presently expressing/supporting that information' introduces the ability to accommodate many-to-one attestations, making the data significantly more usable - especially for more complex use cases that involve the concept of transitive signal, such as reputation.
</p>
</div>

<img src="/img/signal_1.png" alt="Signal Many-to-One Attestations" style={{ width: '100%', maxWidth: '800px', margin: '2rem auto', display: 'block', borderRadius: '8px' }} />

To accomplish this, the Intuition system enables users to maintain positions on Atoms and Triples, interpreting these positions as explicit signal from the user. This mechanism can be implemented using tokens or other accounting systems that have the ability to track user balances over time across an arbitrarily large number of entities.

## Atom Signal

Within the Intuition framework, users signal their belief in the relevance of an Atom by adjusting their balance on that Atom. This balance can be increased or decreased arbitrarily.

<img src="/img/signal_2.png" alt="Atom Signal Balance" style={{ width: '100%', maxWidth: '800px', margin: '2rem auto', display: 'block', borderRadius: '8px' }} />

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Balance Interpretation</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Zero Balance</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Implies no signal, indicating neutral stance on the Atom's relevance.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Positive Balance</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Indicates a degree of belief in the Atom's relevance, with higher balances showing stronger belief.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Negative Balance</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
May be used to explicitly signal the irrelevance of an Atom (if supported by the implementation).
</p>
</div>
</div>
</div>

This mechanism is economically driven: users earn fees proportional to their ownership stake in an Atom as other users interact with it. Thus, if a user deems an Atom relevant, they are incentivized to signal its relevance to receive these rewards.

## Triple Signal

In the Intuition framework, users signal their belief in both the relevance and truthfulness of a Triple by modifying their balance on that Triple. Triple balances can be any integer, allowing for a nuanced expression of belief.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Triple Balance System</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Zero Balance</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Indicates no signal, neutral stance on the Triple.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Positive Balance</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Affirms the Triple, indicating it is considered true and relevant.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Negative Balance</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Signals rejection of the Triple, indicating it is considered false and relevant.
</p>
</div>
</div>
</div>

### Example: Trustworthiness Triple

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Example: "[Vitalik][is][trustworthy]"</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<p style={{ margin: '0 0 1rem 0', fontSize: '0.9rem' }}>
For example, with a Triple asserting "[Vitalik][is] [trustworthy]," users would express their belief in its truthfulness, and the relevancy of this truthfulness, by increasing their balance on the affirmative side of the Triple, or signal disbelief by decreasing their balance into the negative. This mechanism allows for nuanced expressions of trust and belief within the decentralized ecosystem.
</p>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '1rem' }}>
<div style={{ textAlign: 'center', border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Positive Balance</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>Believes Vitalik is trustworthy</p>
</div>
<div style={{ textAlign: 'center', border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Negative Balance</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>Believes Vitalik is not trustworthy</p>
</div>
<div style={{ textAlign: 'center', border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Zero Balance</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>No opinion on Vitalik's trustworthiness</p>
</div>
</div>
</div>
</div>

<img src="/img/signal_3.png" alt="Triple Signal Example" style={{ width: '100%', maxWidth: '800px', margin: '2rem auto', display: 'block', borderRadius: '8px' }} />

This mechanism allows for nuanced expressions of trust and belief within the decentralized ecosystem.

## Advanced Applications

This system enables each "statement" to exist in different states based on who is affirming or rejecting it. To illustrate the power of this approach, consider the example of building a decentralized list of followers.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Traditional vs Intuition Model</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Traditional One-to-One</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
If a user had 1,000 followers, there would be 1,000 separate "following" claims. Most of this data would be redundant, as the "following Y" part would remain constant across all claims.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Intuition Model</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
A single Triple representing "I am following Y." Users adjust their balances on this statement to express their stance. To see all followers of Y, examine the Triple and identify who has positive balances.
</p>
</div>
</div>
</div>

Furthermore, the ability to adjust balances allows for a more nuanced expression of preferences. In the context of a 'follow' functionality, instead of a flat follow list where all followers are treated equally, users could explicitly signal varying levels of interest or endorsement.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Nuanced Preferences</h3>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
By increasing their balance on the followers they value more, users can effectively rank their follow list. This means that someone could show a stronger preference for certain individuals or entities by staking more tokens on their affirmations, creating a dynamic and tiered system of trust and preference.
</p>
</div>

This not only enhances the granularity of data but also provides richer insights into user preferences and social dynamics within the network.

## Next Steps

Now that you understand Signal, explore:

- [Fees & Rewards](/guides/introduction/the-primitives/fundamentals/fees-rewards) - Learn about the economic incentives
- [Capturing Signal](/guides/introduction/the-primitives/structuring/capturing-signal) - Advanced techniques for signal capture
- [State Interpretations](/guides/introduction/the-primitives/fundamentals/state-interpretations) - Understand how signal is interpreted 

---

### File: docs/guides/introduction/the-primitives/fundamentals/state-interpretations.md


# State Interpretations

The Intuition system enables a state that can be interpreted in countless ways, intentionally avoiding the imposition of any single perspective. This design aligns with Intuition's principle of avoiding "truth lock-in" by ensuring the protocol remains neutral regarding state and signal interpretations.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Key Principle</h3>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
While the system does not enforce specific interpretations, understanding various methods and perspectives for analyzing the system's state is critical for leveraging its full potential.
</p>
</div>

## Types of Interpretations

<div style={{ display: 'flex', flexDirection: 'row', gap: '1.5rem', marginTop: '2rem', marginBottom: '2rem', flexWrap: 'wrap' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)', flex: '1', minWidth: '300px' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Literal Interpretations</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
Structured, explicit expressions of the state that form the foundation for higher-order applications by defining clear and consistent frameworks for data usage.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Structured</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Explicit</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Consistent</span>
</div>
<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '0.75rem', borderRadius: '6px', fontSize: '0.875rem' }}>
<strong>Benefit:</strong> Achieves consensus on how concepts should be expressed and understood, fostering interoperability and composability.
</div>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)', flex: '1', minWidth: '300px' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Algorithms</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
Tools for filtering and interpreting data, providing flexibility beyond deterministic logic. Essential for extracting meaningful signal from noise in a permissionless environment.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Flexible</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Filtering</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Customizable</span>
</div>
<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '0.75rem', borderRadius: '6px', fontSize: '0.875rem' }}>
<strong>Benefit:</strong> Promotes a diverse marketplace of algorithms, empowering users to choose or create solutions tailored to specific contexts.
</div>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)', flex: '1', minWidth: '300px' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Reality Tunnels</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
Modular combinations of literal interpretations, algorithms, and other components that provide tailored perspectives on data.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Modular</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Tailored</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Perspectives</span>
</div>
<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '0.75rem', borderRadius: '6px', fontSize: '0.875rem' }}>
<strong>Benefit:</strong> Allows users to recombine elements in innovative ways, crafting unique viewpoints for specific contexts.
</div>
</div>

</div>

## Literal Interpretations

Literal interpretations within Intuition provide structured, explicit expressions of the state. These interpretations form the foundation for higher-order applications by defining clear and consistent frameworks for data usage.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Example: Access Control Mechanism</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Triple Definition</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
A Triple is defined using the Predicate "has access to," where the Subject is a user, and the Object is a resource (e.g., System X).
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Literal Interpretation</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
If [Company's Multisig] attests to the Triple being True, the Subject of the Triple has access to the Object.
</p>
</div>
</div>
</div>
</div>

This structured interpretation allows implementers to provision access programmatically. For instance, if System Y references the same data, it could use this interpretation to grant access to User A based on their access to System X.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Cross-System Applications</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Financial Applications</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Adjusting loan-to-value ratios based on access control data.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Reputational Systems</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Modifying reputational scores in specific contexts based on access patterns.
</p>
</div>
</div>
</div>

By registering and sharing these interpretations as Atoms or Triples, the Intuition system creates a registry of literal interpretations. This recursive system enhances transparency, coordination, and innovation, enabling the development of programmatic languages that leverage the principles of discrete objects and their relationships.

## Algorithms

Algorithms in the Intuition framework serve as tools for filtering and interpreting data, providing flexibility beyond deterministic logic. In a permissionless environment where anyone can make claims about anything, algorithms are essential for extracting meaningful signal from the noise.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Key Principle</h3>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Intuition's ecosystem rejects "truth lock-in," recognizing that no single algorithm suits all needs. Instead, it promotes a diverse marketplace of algorithms, empowering users and developers to choose or create solutions tailored to specific contexts.
</p>
</div>

This decoupling of algorithms from applications allows for greater customization and interoperability, contrasting sharply with traditional platforms that enforce opaque, pre-set algorithms.

### Example: Social Graph Algorithm

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Trust-Based Filtering</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<p style={{ margin: '0 0 1rem 0', fontSize: '0.9rem' }}>
Consider an algorithm that filters data based on a user's social graph:
</p>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '1rem' }}>
<div style={{ textAlign: 'center', border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>One Degree</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>100% Weight</p>
</div>
<div style={{ textAlign: 'center', border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Two Degrees</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>80% Weight</p>
</div>
<div style={{ textAlign: 'center', border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Three Degrees</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>60% Weight</p>
</div>
</div>
<p style={{ margin: '1rem 0 0 0', fontSize: '0.9rem', fontStyle: 'italic', color: 'var(--ifm-color-emphasis-600)' }}>
This algorithm provides a nuanced interpretation of data based on proximity, allowing for trust-based filtering that aligns with user preferences.
</p>
</div>
</div>

## Reality Tunnels

The modular nature of Intuition's data interpretation mechanisms enables the creation of "Reality Tunnels." A Reality Tunnel combines literal interpretations, algorithms, and other relevant components to provide a tailored perspective on data.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Example: Trust Graph Reality Tunnel</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Triple Structure</h4>
<p style={{ margin: 0, fontSize: '0.9rem', fontFamily: 'monospace' }}>
[Subject] [in trust graph] [Vitalik's Web3 Trust Graph]
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Components</h4>
<ul style={{ margin: 0, paddingLeft: '1rem', fontSize: '0.9rem' }}>
<li>Curator assigns weights to users</li>
<li>Combined with EigenTrust algorithm</li>
<li>Focused on Web3 knowledge domain</li>
</ul>
</div>
</div>
</div>
</div>

This integrated perspective becomes a Reality Tunnel, offering a customized lens through which users can view and interpret data.

### Switching Perspectives

Reality Tunnels also enable users to switch between perspectives. For instance, during a debate, a user could toggle to their opponent's Reality Tunnel to better understand their reasoning.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Key Advantage</h3>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
This flexibility contrasts with traditional platforms, where users are often restricted to a single perspective defined by a specific algorithm and social graph. By allowing users to explore multiple Reality Tunnels, Intuition fosters a richer, more comprehensive understanding of data and encourages well-informed decision-making.
</p>
</div>

## Enhancing Perspectives and Collaboration

The flexibility to create and toggle between Reality Tunnels transforms how users interact with data. By integrating literal interpretations, customizable algorithms, and composable data structures, Intuition empowers users to access diverse perspectives and foster collaboration.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Benefits</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Enriched Discussions</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Multiple perspectives lead to more comprehensive and nuanced discussions.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Improved Decision-Making</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Access to diverse viewpoints enables better-informed decisions.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Adaptable Ecosystem</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
The system remains adaptable and inclusive for all participants.
</p>
</div>
</div>
</div>

This approach enriches discussions, improves decision-making, and ensures the ecosystem remains adaptable and inclusive for all participants.

## Next Steps

Now that you understand State Interpretations, explore:

- [Structuring](/guides/introduction/the-primitives/structuring) - Learn advanced techniques for working with interpretations
- [Signal](/guides/introduction/the-primitives/fundamentals/signal) - Understand how signal influences interpretations
- [Developer Tools](/guides/developer-tools) - Implement custom interpretations and algorithms 

---

### File: docs/guides/introduction/the-primitives/fundamentals/triples.md


# Triples

With discrete units of data established through Atoms, defining relationships between these units to form higher-order structures is essential. Intuition achieves this by employing Semantic Triples, ensuring a uniform and discrete structure that can be prescribed a decentralized identifier and have some associated agent-centric state.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Key Purpose</h3>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
This structure is essential for achieving consensus on arbitrarily sophisticated and expressive forms of data.
</p>
</div>

## Triple Structure

Triples consist of three elements: Subject, Predicate, and Object, with each element represented as an Atom. This Subject-Predicate-Object format allows users to clearly and explicitly define relationships between Atoms.

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '1.5rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Subject</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
The entity or concept being described in the relationship.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Entity</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Concept</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Atom</span>
</div>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Predicate</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
The relationship or attribute that connects the subject to the object.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Relationship</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Attribute</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Atom</span>
</div>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Object</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
The value or characteristic attributed to the subject through the predicate.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Value</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Characteristic</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Atom</span>
</div>
</div>

</div>

These connections can be visualized as a graph where each node and edge is an Atom.

## Example Triple

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Simple Triple Example</h3>
<div style={{ backgroundColor: 'var(--ifm-background-color)', padding: '1rem', borderRadius: '6px', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', gap: '1rem', marginBottom: '1rem' }}>
<div style={{ textAlign: 'center', border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Subject</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>"Bob"</p>
</div>
<div style={{ textAlign: 'center', border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Predicate</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>"age"</p>
</div>
<div style={{ textAlign: 'center', border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem', color: 'var(--ifm-color-primary)' }}>Object</h4>
<p style={{ margin: 0, fontFamily: 'monospace', fontSize: '0.9rem' }}>"34"</p>
</div>
</div>
<p style={{ margin: 0, textAlign: 'center', fontStyle: 'italic', color: 'var(--ifm-color-emphasis-600)' }}>
In this example, each component‚ÄîSubject, Predicate, and Object is an Atom, and the Triple expresses a specific relationship between these Atoms.
</p>
</div>
</div>

## Fractal Data Representations

Triples offer a flexible yet structured method for representing data relationships. By allowing Triples to act as Atoms within other Triples, Intuition facilitates the expression, storage, and usage of arbitrarily complex data models that can scale and evolve over time.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Key Benefits</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Flexibility</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
This flexibility is crucial for capturing intricate relationships and dynamics within data.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Scalability</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Enabling users to construct sophisticated applications and services on the Intuition framework.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Precision</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
This approach maintains discrete, referenceable units for data at every layer of the structure.
</p>
</div>
</div>
</div>

This flexibility is crucial for capturing intricate relationships and dynamics within data, enabling users to construct sophisticated applications and services on the Intuition framework. This approach maintains discrete, referenceable units for data at every layer of the structure, ensuring scalability and precision in data representation.

## Triple Ownership and Token Curated Registries

Akin to the process outlined for Atoms, the structure of Triples allows users to gain fractional ownership of Triples through interaction. Each interaction generates interaction fees, which are distributed to the owners of each respective Triple, creating an incentivized Token Curated Registry (TCR) for data structures.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem', marginBottom: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>TCR Advantages</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Economic Rewards</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
The TCR encourages system participants to adopt common ways of structuring data by offering economic rewards.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Organic Structuring</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
This approach promotes an organic, incentive-driven structuring of data.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Effective Standardization</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Contrasts with more rigid and traditional methods such as standards committees, which often struggle to achieve effective standardization.
</p>
</div>
</div>
</div>

The TCR encourages system participants to adopt common ways of structuring data by offering economic rewards. This approach promotes an organic, incentive-driven structuring of data, contrasting with more rigid and traditional methods such as standards committees, which often struggle to achieve effective standardization.

## Next Steps

Now that you understand Triples, explore:

- [Signal](/guides/introduction/the-primitives/fundamentals/signal) - Learn how users interact with Triples
- [Structuring Triples](/guides/introduction/the-primitives/structuring/triples) - Advanced techniques for working with Triples
- [Fees & Rewards](/guides/introduction/the-primitives/fundamentals/fees-rewards) - Understand the economic model 

---

### File: docs/guides/introduction/the-primitives/index.md


# Primitives

The Intuition System is built on a set of novel primitives, which form the foundation of the ecosystem and enable the creation of a structured, semantic web of trust. 

:::note
Intuition introduces three new primitives: 

1. **Atoms**: Intuition's atomic unit of knowledge, enabling unique, persistent, canonical identifiers for all things - not just people.
2. **Triples:** A composition of Atoms - defined as Semantic Triples which represent the relationships between Atoms
3. **Signal:** The weight of Atoms and Triples, derived from the total amount of ETH deposited in Atom and Triple Vaults
:::

## Explore Primitives

<div className="uniform-card-grid">

<a href="/docs/introduction/the-primitives/fundamentals" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>
<div className="uniform-card clickable-card">
<h3 className="uniform-card-title">Fundamentals</h3>
<p className="uniform-card-content">
Learn the core concepts of Atoms, Triples, Signal, Fees & Rewards, and State Interpretations. Master the building blocks of the Intuition system.
</p>
</div>
</a>

<a href="/docs/introduction/the-primitives/structuring" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>
<div className="uniform-card clickable-card">
<h3 className="uniform-card-title">Structuring</h3>
<p className="uniform-card-content">
Discover advanced techniques for structuring data with Atoms and Triples, capturing signal, and calculating rewards in the Intuition ecosystem.
</p>
</div>
</a>

</div>

## Core Primitives Overview

<div className="uniform-card-grid-small">

<div className="uniform-card">
<h3 className="uniform-card-title">Atoms</h3>
<p className="uniform-card-content">
The most basic units of knowledge within Intuition, functioning as unique, globally persistent, decentralized identifiers for all things‚Äîpeople, concepts, products, and more.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Subjects</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Predicates</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Objects</span>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Triples</h3>
<p className="uniform-card-content">
Higher-order structures used to define relationships between Atoms. Each Triple consists of three components: a Subject, Predicate, and Object.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Relationships</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Semantic</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Machine-readable</span>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Signal</h3>
<p className="uniform-card-content">
Actions that express intent, belief, or support within the system. Signals can be explicit or implicit, contributing to trust and belief expression.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Trust</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Belief</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Support</span>
</div>
</div>

</div>

## Understanding Atoms

The digital universe is vast, where everything from tangible objects to abstract concepts can be endowed with a digital identity. Atoms confer unique recognition and definition to persons, places, ideas, or even memes, ensuring each entity's distinct presence. Within Intuition, every Atom is secured by a unique DID (Decentralized Identifier) and an Ethereum wallet address, establishing a verifiable foundation.

Atoms are categorized into three primary roles within semantic structures: **Subjects**, **Predicates**, and **Objects**. This structure facilitates the creation of **Triples** that articulate specific assertions or facts about the world.

### Example Triple Structure

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1rem', borderRadius: '8px', margin: '1rem 0', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<p style={{ margin: '0 0 0.5rem 0', fontWeight: '600', color: 'var(--ifm-color-emphasis-900)' }}>Subject - Predicate - Object</p>
<p style={{ margin: '0', fontFamily: 'monospace', fontSize: '0.9rem', color: 'var(--ifm-color-emphasis-700)' }}>
<strong>Alice</strong> <span style={{ color: 'var(--ifm-color-emphasis-600)' }}>[Subject]</span> <strong>- hasAccessTo</strong> <span style={{ color: 'var(--ifm-color-emphasis-600)' }}>[Predicate]</span> <strong>- Intuition</strong> <span style={{ color: 'var(--ifm-color-emphasis-600)' }}>[Object]</span>
</p>
</div>

* **Alice** is the **Subject**
* **hasAccessTo** is the **Predicate**
* **Intuition** is the **Object**

Further illustrating the flexibility of Atoms, **Intuition** can also act as a **Subject:**

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1rem', borderRadius: '8px', margin: '1rem 0', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<p style={{ margin: '0', fontFamily: 'monospace', fontSize: '0.9rem', color: 'var(--ifm-color-emphasis-700)' }}>
<strong>Intuition</strong> <span style={{ color: 'var(--ifm-color-emphasis-600)' }}>[Subject]</span> <strong>- is a</strong> <span style={{ color: 'var(--ifm-color-emphasis-600)' }}>[Predicate]</span> <strong>- Ethereum-based attestation protocol</strong> <span style={{ color: 'var(--ifm-color-emphasis-600)' }}>[Object]</span>
</p>
</div>

This claim demonstrates Intuition's role and essence in a semantic, structured format.

## Composition of Knowledge

Acknowledging the potential for any entity, concept, or piece of data to hold a digital identity opens the door to collaboratively crafting an expansive knowledge graph. By arranging Atoms into Triples, we co-create a graph mapping out entities' interrelations and factual, verifiable assertions about the world.

The journey within Intuition starts with an Atom. Engaging with this concept might begin by identifying entities within your realm of knowledge that fit neatly into the categories of Subjects, Predicates, or Objects. This process is a first step toward contributing to our collective mission: building a collaborative knowledge graph demonstrating the connections and relationships among all entities.

## Components of an Atom

<div className="uniform-card-grid-small">

<div className="uniform-card">
<h4 className="uniform-card-title">Atom Data</h4>
<p className="uniform-card-content">
Describes the concept or entity represented by an Atom, typically stored off-chain using decentralized storage solutions like IPFS or Arweave, with a URI pointing to this data stored on-chain.
</p>
</div>

<div className="uniform-card">
<h4 className="uniform-card-title">Atom Wallet</h4>
<p className="uniform-card-content">
A smart contract wallet associated with each Atom, granting it agency over its identity. This wallet is controlled by a specialized smart contract known as the Atom Warden.
</p>
</div>

<div className="uniform-card">
<h4 className="uniform-card-title">Atom Vault</h4>
<p className="uniform-card-content">
A mechanism that allows users to deposit tokens into an Atom, signaling its relevance and support within the system. The Total Value Locked (TVL) in an Atom Vault indicates the Atom's acceptance and importance.
</p>
</div>

</div>

## Triples

Triples are higher-order structures within Intuition, used to define relationships between Atoms. Each Triple consists of three components: a Subject, Predicate, and Object, all of which are Atoms. This structure enables precise, machine-readable representations of data, facilitating complex and interconnected attestations.

### Triple Structure

<div className="uniform-card-grid-small" style={{ marginTop: '1rem' }}>

<div className="uniform-card">
<h4 className="uniform-card-title">Subject</h4>
<p className="uniform-card-content">
The entity or concept being described.
</p>
</div>

<div className="uniform-card">
<h4 className="uniform-card-title">Predicate</h4>
<p className="uniform-card-content">
The relationship or attribute of the subject.
</p>
</div>

<div className="uniform-card">
<h4 className="uniform-card-title">Object</h4>
<p className="uniform-card-content">
The value or characteristic attributed to the subject.
</p>
</div>

</div>

In this example, each component‚ÄîSubject, Predicate, and Object‚Äîis an Atom, and the Triple expresses a specific relationship between these Atoms.

Triples form the relationships between Atoms, allowing for arbitrarily-linked data across the web.

:::tip
Triples can be used as Atoms in other Triples, allowing for the expression of arbitrarily complex statements in a standardized format.
:::

## Signal

Signal in Intuition refers to any action that expresses intent, belief, or support within the system. Signals can be explicit, such as voting mechanisms or signed attestations, or implicit, inferred from user behavior.

### Signal Mechanisms

Users hold positions on Atoms and Triples, signaling their stance by increasing their balance on the relevant entities. Signals contribute to the nuanced expression of trust and belief, allowing for a dynamic and tiered system of preferences within the decentralized ecosystem.

<div className="uniform-card" style={{ margin: '1rem 0' }}>
<p className="uniform-card-title" style={{ marginBottom: '0.5rem' }}>Important Distinction</p>
<p className="uniform-card-content" style={{ margin: 0 }}>
Creating an Atom or Triple is distinctly different from taking a position on them. While users have the option to both create and take a position on an Atom/Triple at the time of creation, this Initial Deposit is not required. A user who makes no Initial Deposit will only create an Atom or Triple, which does not constitute a Signal.
</p>
</div>

---

### File: docs/guides/introduction/the-primitives/structuring/atoms.md


# Atoms

Atoms are the fundamental building blocks of data in Intuition. Understanding how to properly structure atoms is crucial for building effective applications on the protocol.

## What are Atoms?

Atoms represent discrete, manageable pieces of information that can be referenced and combined across the web. Each atom is uniquely identified by a decentralized identifier (DID) and contains structured data that can be of any type or format.

## Structuring Atoms

### Basic Structure

An atom consists of three core components:

1. **Decentralized Identifier (DID)** - Unique identifier for the atom
2. **Data Content** - The actual information being represented
3. **Metadata** - Additional context and properties

### Example Atom Structure

```json
{
  "id": "did:ethr:mainnet:0x3b0bc51ab9de1e5b7b6e34e5b960285805c41736",
  "data": {
    "type": "concept",
    "content": "Machine Learning",
    "description": "A subset of artificial intelligence that enables systems to learn and improve from experience",
    "tags": ["AI", "technology", "computing"]
  },
  "metadata": {
    "created": "2024-01-15T10:30:00Z",
    "creator": "did:ethr:mainnet:0x123...",
    "version": "1.0"
  }
}
```

## Best Practices for Atom Structure

### 1. Clear and Descriptive Content

- Use precise, unambiguous language
- Include sufficient context for understanding
- Avoid overly complex or nested structures

### 2. Consistent Naming Conventions

- Use camelCase for property names
- Maintain consistent terminology across related atoms
- Follow established domain conventions

### 3. Proper Metadata

- Always include creation timestamps
- Specify the creator's DID
- Include version information for mutable atoms

### 4. Scalable Design

- Design atoms to be composable
- Consider future extensibility
- Maintain backward compatibility

## Atom Categories

### Concept Atoms
Represent abstract ideas, categories, or classifications.

```json
{
  "type": "concept",
  "content": "Blockchain Technology",
  "category": "technology"
}
```

### Entity Atoms
Represent specific people, places, or things.

```json
{
  "type": "entity",
  "content": "Ethereum",
  "category": "blockchain",
  "properties": {
    "founded": "2015",
    "creator": "Vitalik Buterin"
  }
}
```

### Attribute Atoms
Represent characteristics or properties.

```json
{
  "type": "attribute",
  "content": "Decentralized",
  "category": "property",
  "appliesTo": ["blockchain", "governance"]
}
```

## Creating Atoms Programmatically

### Using the SDK (copy‚Äëpaste ready)

```ts
import {
  createAtomFromString,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'
import { createPublicClient, createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { sepolia } from 'viem/chains'

// 1) Configure viem clients (example uses Sepolia)
const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`)
const walletClient = createWalletClient({ account, chain: sepolia, transport: http() })
const publicClient = createPublicClient({ chain: sepolia, transport: http() })

// 2) Resolve MultiVault address for the current chain
const multivaultAddress = getEthMultiVaultAddressFromChainId(sepolia.id)

// 3) Create an Atom from a simple string label
const result = await createAtomFromString(
  { walletClient, publicClient, address: multivaultAddress },
  'Machine Learning',
)

console.log('Created atom vaultId:', result.state.vaultId)
```

### Validation

Ensure your atoms follow these validation rules:

- **Required Fields**: `id`, `data.content`, `metadata.created`
- **Content Length**: Minimum 1 character, maximum 10,000 characters
- **Tag Count**: Maximum 20 tags per atom
- **Metadata**: Must include creator DID and timestamp

## Atom Relationships

Atoms can be related to each other through various mechanisms:

### Direct References
```json
{
  "content": "Deep Learning",
  "relatedAtoms": [
    "did:ethr:mainnet:0x...", // Machine Learning atom
    "did:ethr:mainnet:0x..."  // Neural Networks atom
  ]
}
```

### Hierarchical Structure
```json
{
  "content": "Artificial Intelligence",
  "children": [
    "did:ethr:mainnet:0x...", // Machine Learning
    "did:ethr:mainnet:0x..."  // Expert Systems
  ]
}
```

## Quality Guidelines

### Content Quality
- Ensure accuracy and verifiability
- Use clear, concise language
- Provide sufficient context
- Avoid redundant or duplicate atoms

### Technical Quality
- Follow proper DID standards
- Include comprehensive metadata
- Use consistent data formats
- Implement proper versioning

### Community Standards
- Respect intellectual property
- Avoid misleading or false information
- Contribute to the ecosystem's growth
- Engage with the community constructively

## Next Steps

Now that you understand how to structure atoms, explore:

- [Triples](./triples.md) - Learn how to connect atoms into meaningful relationships
- [Capturing Signal](./capturing-signal.md) - Understand how to measure atom usage and relevance
- [Calculating Rewards](./calculating-rewards.md) - Discover how atom interactions generate rewards

---

### File: docs/guides/introduction/the-primitives/structuring/calculating-rewards.md


# Calculating Rewards

The reward system in Intuition incentivizes high-quality contributions and active participation in the ecosystem. Understanding how rewards are calculated helps users maximize their earnings and contribute effectively.

## Reward Fundamentals

### What are Rewards?

Rewards in Intuition are distributed in $TRUST tokens to users who:
- Create valuable atoms and triples
- Provide accurate and useful information
- Engage with the ecosystem meaningfully
- Stake tokens to back their contributions

### Reward Types

#### 1. Creation Rewards
Rewards for creating high-quality atoms and triples.

```javascript
const creationReward = await calculateCreationReward({
  atomId: "did:ethr:mainnet:0x...",
  creator: userDid,
  quality: 0.95,
  stake: 1000, // TRUST tokens
  usage: 150   // views/interactions
});
```

#### 2. Usage Rewards
Rewards for atoms and triples that are frequently used.

```javascript
const usageReward = await calculateUsageReward({
  atomId: "did:ethr:mainnet:0x...",
  timeframe: "30d",
  usage: {
    views: 500,
    references: 25,
    shares: 10
  }
});
```

#### 3. Quality Rewards
Rewards for maintaining high accuracy and relevance.

```javascript
const qualityReward = await calculateQualityReward({
  atomId: "did:ethr:mainnet:0x...",
  accuracy: 0.98,
  consensus: 0.92,
  relevance: 0.85
});
```

#### 4. Staking Rewards
Rewards for staking tokens to back contributions.

```javascript
const stakingReward = await calculateStakingReward({
  userId: userDid,
  stakedAmount: 5000, // TRUST tokens
  duration: 90, // days
  atomQuality: 0.9
});
```

## Reward Calculation Formula

### Base Reward Formula

```javascript
const baseReward = (qualityScore * stakeAmount * usageMultiplier) / totalStake;
```

### Quality Score Components

```javascript
const qualityScore = (
  accuracyScore * 0.4 +
  relevanceScore * 0.3 +
  consensusScore * 0.2 +
  noveltyScore * 0.1
);
```

### Usage Multiplier

```javascript
const usageMultiplier = Math.log(1 + totalUsage) / Math.log(10);
```

## Detailed Calculation Examples

### 1. Atom Creation Reward

```javascript
const atomReward = await calculateAtomReward({
  atom: {
    id: "did:ethr:mainnet:0x...",
    content: "Machine Learning",
    creator: userDid,
    stake: 1000
  },
  metrics: {
    views: 250,
    references: 15,
    accuracy: 0.95,
    consensus: 0.88
  },
  timeframe: "30d"
});

// Reward calculation:
// Base: 1000 TRUST (stake)
// Quality: 0.95 * 0.4 + 0.88 * 0.2 = 0.556
// Usage: log(1 + 265) / log(10) = 2.42
// Total: (1000 * 0.556 * 2.42) / 10000 = 134.6 TRUST
```

### 2. Triple Creation Reward

```javascript
const tripleReward = await calculateTripleReward({
  triple: {
    id: "did:ethr:mainnet:0x...",
    subject: "did:ethr:mainnet:0x...", // Ethereum
    predicate: "did:ethr:mainnet:0x...", // is
    object: "did:ethr:mainnet:0x...", // decentralized
    creator: userDid,
    stake: 500
  },
  metrics: {
    usage: 120,
    confidence: 0.92,
    consensus: 0.85
  }
});
```

### 3. Staking Reward

```javascript
const stakingReward = await calculateStakingReward({
  userId: userDid,
  stakedAtoms: [
    { atomId: "did:ethr:mainnet:0x...", amount: 2000, quality: 0.9 },
    { atomId: "did:ethr:mainnet:0x...", amount: 1500, quality: 0.85 }
  ],
  duration: 60, // days
  totalEcosystemStake: 100000
});
```

## Reward Distribution

### 1. Daily Distribution

```javascript
const dailyRewards = await distributeDailyRewards({
  date: "2024-01-15",
  totalPool: 10000, // TRUST tokens
  participants: activeUsers,
  metrics: dailyMetrics
});
```

### 2. Weekly Bonuses

```javascript
const weeklyBonus = await calculateWeeklyBonus({
  userId: userDid,
  week: "2024-W03",
  activities: {
    atomsCreated: 5,
    triplesCreated: 12,
    interactions: 150,
    quality: 0.92
  }
});
```

### 3. Monthly Milestones

```javascript
const monthlyMilestone = await calculateMonthlyMilestone({
  userId: userDid,
  month: "2024-01",
  achievements: {
    topContributor: true,
    qualityExcellence: true,
    communityLeader: true
  }
});
```

## Reward Optimization Strategies

### 1. Quality-First Approach

```javascript
// Focus on creating high-quality content
const qualityStrategy = {
  research: true,
  verification: true,
  communityFeedback: true,
  iterativeImprovement: true
};
```

### 2. Strategic Staking

```javascript
// Stake on promising atoms early
const stakingStrategy = {
  earlyAdoption: true,
  diversification: true,
  qualityAssessment: true,
  activeMonitoring: true
};
```

### 3. Network Building

```javascript
// Create valuable connections
const networkStrategy = {
  meaningfulTriples: true,
  crossReferences: true,
  communityEngagement: true,
  knowledgeSharing: true
};
```

## Reward Analytics

### 1. Personal Analytics

```javascript
const personalAnalytics = await getPersonalRewardAnalytics({
  userId: userDid,
  timeframe: "90d",
  metrics: ['totalEarned', 'qualityScore', 'usageRate', 'stakeROI']
});
```

### 2. Comparative Analysis

```javascript
const comparison = await compareRewardPerformance({
  users: [userDid1, userDid2, userDid3],
  timeframe: "30d",
  metrics: ['rewardRate', 'qualityScore', 'efficiency']
});
```

### 3. Predictive Modeling

```javascript
const prediction = await predictRewardGrowth({
  userId: userDid,
  timeframe: "7d",
  factors: ['currentQuality', 'usageTrend', 'stakeGrowth']
});
```

## Reward Claiming

### 1. Automatic Claims

```javascript
// Set up automatic claiming
await setupAutoClaim({
  userId: userDid,
  threshold: 100, // TRUST tokens
  frequency: "weekly"
});
```

### 2. Manual Claims

```javascript
// Manually claim rewards
const claim = await claimRewards({
  userId: userDid,
  amount: 500, // TRUST tokens
  gasEstimate: true
});
```

### 3. Batch Claims

```javascript
// Claim multiple reward types at once
const batchClaim = await batchClaimRewards({
  userId: userDid,
  types: ['creation', 'usage', 'staking', 'quality'],
  gasOptimization: true
});
```

## Reward Security

### 1. Fraud Prevention

```javascript
const fraudCheck = await detectRewardFraud({
  userId: userDid,
  patterns: ['artificial_inflation', 'sock_puppets', 'collusion']
});
```

### 2. Dispute Resolution

```javascript
const dispute = await createRewardDispute({
  rewardId: "did:ethr:mainnet:0x...",
  reason: "inaccurate_information",
  evidence: ["source1", "source2"],
  stake: 1000
});
```

### 3. Appeal Process

```javascript
const appeal = await appealRewardDecision({
  disputeId: "did:ethr:mainnet:0x...",
  newEvidence: ["additional_source"],
  communityVote: true
});
```

## Best Practices

### 1. Content Quality
- Research thoroughly before creating atoms
- Verify information from multiple sources
- Update content as new information becomes available
- Engage with the community for feedback

### 2. Strategic Participation
- Focus on high-value, underserved topics
- Build meaningful connections between atoms
- Stake tokens on quality content
- Participate in community governance

### 3. Continuous Learning
- Monitor reward performance analytics
- Adapt strategies based on results
- Learn from successful contributors
- Stay updated on protocol changes

### 4. Community Engagement
- Help other users improve their content
- Participate in discussions and feedback
- Share knowledge and best practices
- Contribute to protocol governance

## Integration Examples

### Web Application

```javascript
// React component for reward tracking
function RewardTracker({ userId }) {
  const [rewards, setRewards] = useState(null);
  
  useEffect(() => {
    const fetchRewards = async () => {
      const userRewards = await getUserRewards({
        userId,
        timeframe: "30d"
      });
      setRewards(userRewards);
    };
    
    fetchRewards();
  }, [userId]);

  return (
    <div>
      <h3>Your Rewards</h3>
      <p>Total Earned: {rewards?.total} TRUST</p>
      <p>Quality Score: {rewards?.qualityScore}</p>
      <button onClick={() => claimRewards(userId)}>
        Claim Rewards
      </button>
    </div>
  );
}
```

### Mobile Application

```javascript
// React Native reward tracking
const trackRewardActivity = async (activity) => {
  await logRewardActivity({
    userId: userDid,
    activity,
    timestamp: new Date().toISOString(),
    metadata: {
      platform: 'mobile',
      appVersion: '1.2.0'
    }
  });
};
```

## Next Steps

Now that you understand reward calculation, explore:

- [Atoms](./atoms.md) - Learn how to create valuable atoms
- [Triples](./triples.md) - Understand how to build meaningful relationships
- [Capturing Signal](./capturing-signal.md) - Discover how signal drives rewards

---

### File: docs/guides/introduction/the-primitives/structuring/capturing-signal.md


# Capturing Signal

Signal capture is the process of measuring and quantifying how users interact with atoms and triples in the Intuition ecosystem. This data drives the reward system and helps identify the most valuable and relevant information.

## What is Signal?

Signal represents the collective behavior and preferences of users interacting with the Intuition protocol. It includes:

- **Usage Patterns**: How often atoms and triples are accessed
- **User Engagement**: Time spent, interactions, and feedback
- **Quality Indicators**: Accuracy, relevance, and usefulness
- **Network Effects**: How data spreads and influences other users

## Signal Types

### 1. Direct Signal
Explicit user actions that directly indicate value.

```javascript
// User explicitly rates an atom
const rating = await rateAtom({
  atomId: "did:ethr:mainnet:0x...",
  rating: 5, // 1-5 scale
  userId: userDid,
  timestamp: new Date().toISOString()
});
```

### 2. Implicit Signal
Inferred from user behavior patterns.

```javascript
// User searches for and views an atom
const view = await trackAtomView({
  atomId: "did:ethr:mainnet:0x...",
  userId: userDid,
  duration: 45, // seconds
  context: "search_result"
});
```

### 3. Network Signal
Signal derived from how data flows through the network.

```javascript
// Atom is referenced in a triple
const reference = await trackAtomReference({
  atomId: "did:ethr:mainnet:0x...",
  tripleId: "did:ethr:mainnet:0x...",
  context: "subject"
});
```

## Signal Metrics

### Usage Metrics

#### Frequency
```javascript
const frequency = await calculateAtomFrequency({
  atomId: "did:ethr:mainnet:0x...",
  timeframe: "30d",
  metric: "views"
});
```

#### Duration
```javascript
const avgDuration = await calculateAverageDuration({
  atomId: "did:ethr:mainnet:0x...",
  timeframe: "7d"
});
```

#### Reach
```javascript
const reach = await calculateAtomReach({
  atomId: "did:ethr:mainnet:0x...",
  timeframe: "24h"
});
```

### Quality Metrics

#### Accuracy Score
```javascript
const accuracy = await calculateAccuracyScore({
  atomId: "did:ethr:mainnet:0x...",
  method: "community_consensus"
});
```

#### Relevance Score
```javascript
const relevance = await calculateRelevanceScore({
  atomId: "did:ethr:mainnet:0x...",
  context: "search_query",
  userProfile: userProfile
});
```

#### Consensus Score
```javascript
const consensus = await calculateConsensusScore({
  atomId: "did:ethr:mainnet:0x...",
  metric: "agreement_rate"
});
```

## Signal Collection Methods

### 1. Event Tracking (Conceptual)

Event collection endpoints are not exposed as an SDK API. The signals you see in the UI are derived from on-chain deposits/redemptions and graph events. Use GraphQL to query signals data.

### 2. Query Signals (GraphQL)

```ts
import { configureClient, createServerClient, API_URL_DEV, GetSignalsDocument } from '@0xintuition/graphql'

configureClient({ apiUrl: API_URL_DEV })
const client = createServerClient({})

const data = await client.request(GetSignalsDocument, { limit: 10 })
console.log('Signals returned:', data.signals.length)
```

### 3. Real-time Streaming

Real-time streams are not part of the public SDK; poll GraphQL or subscribe via your own infra.

## Signal Processing

### 1. Aggregation

Aggregation helpers shown below are conceptual. Use GraphQL aggregations where available.

### 2. Normalization

Normalization is application-specific. No public SDK function currently exists.

### 3. Weighting

Weighting strategies are left to the integrator.

## Signal Analytics

### 1. Trend Analysis

```javascript
const trends = await analyzeSignalTrends({
  atomId: "did:ethr:mainnet:0x...",
  timeframe: "30d",
  metrics: ['usage', 'quality', 'reach']
});
```

### 2. Comparative Analysis

```javascript
const comparison = await compareSignals({
  atoms: ["did:ethr:mainnet:0x...", "did:ethr:mainnet:0x..."],
  metrics: ['engagement', 'accuracy', 'consensus']
});
```

### 3. Predictive Modeling

```javascript
const prediction = await predictSignalGrowth({
  atomId: "did:ethr:mainnet:0x...",
  timeframe: "7d",
  factors: ['current_trend', 'network_effects', 'quality_score']
});
```

## Signal Quality Assurance

### 1. Spam Detection

```javascript
const isSpam = await detectSignalSpam({
  userId: userDid,
  signalType: 'atom_view',
  patterns: ['bot_behavior', 'artificial_inflation']
});
```

### 2. Sybil Resistance

```javascript
const sybilScore = await calculateSybilResistance({
  userId: userDid,
  factors: ['stake_amount', 'reputation_score', 'behavior_patterns']
});
```

### 3. Quality Validation

```javascript
const qualityScore = await validateSignalQuality({
  signal: userSignal,
  criteria: ['authenticity', 'relevance', 'consistency']
});
```

## Signal Visualization

### 1. Real-time Dashboards

Build dashboards using GraphQL queries and your preferred charting library.

### 2. Historical Analysis

Use GraphQL date filters and ordering to build historical views.

### 3. Network Mapping

No public helper exists; derive network relationships via triples queries.

## Best Practices

### 1. Privacy-First Design
- Anonymize user data when possible
- Use differential privacy techniques
- Respect user consent and preferences

### 2. Efficient Processing
- Implement real-time processing where needed
- Use batch processing for historical analysis
- Optimize for scale and performance

### 3. Quality Over Quantity
- Focus on meaningful signal patterns
- Filter out noise and spam
- Prioritize high-quality interactions

### 4. Continuous Improvement
- Regularly update signal models
- Incorporate user feedback
- Adapt to changing patterns

## Integration Examples

### Web Application

Use the `useGetSignalsQuery` React hook from `@0xintuition/graphql` for UI displays.

### Mobile Application

Mobile integrations query the same GraphQL endpoints; no mobile-specific SDK is required.

## Next Steps

Now that you understand signal capture, explore:

- [Calculating Rewards](./calculating-rewards.md) - Learn how signal translates into rewards
- [Atoms](./atoms.md) - Review atom structure fundamentals
- [Triples](./triples.md) - Understand triple relationships

---

### File: docs/guides/introduction/the-primitives/structuring/index.md


# Structuring

Learn advanced techniques for working with Atoms and Triples in real-world applications. This section covers practical approaches to structuring data, capturing signal, and calculating rewards within the Intuition ecosystem.

## Explore Structuring Techniques

<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(280px, 1fr))', gap: '1.5rem', marginTop: '2rem', marginBottom: '2rem' }}>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Atoms</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
Advanced techniques for creating and managing Atoms, including best practices for identifier design and data organization.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Design</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Management</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Best Practices</span>
</div>
<a href="/docs/introduction/the-primitives/structuring/atoms" style={{ color: 'var(--ifm-color-primary)', textDecoration: 'none', fontWeight: '500' }}>
Learn about Atom Structuring ‚Üí
</a>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Triples</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
Discover how to effectively structure relationships using Triples, including complex nested structures and semantic modeling.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Relationships</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Nested</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Semantic</span>
</div>
<a href="/docs/introduction/the-primitives/structuring/triples" style={{ color: 'var(--ifm-color-primary)', textDecoration: 'none', fontWeight: '500' }}>
Learn about Triple Structuring ‚Üí
</a>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Capturing Signal</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
Learn how to effectively capture and structure signal data, including user interactions, preferences, and behavioral patterns.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Interactions</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Preferences</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Behavioral</span>
</div>
<a href="/docs/introduction/the-primitives/structuring/capturing-signal" style={{ color: 'var(--ifm-color-primary)', textDecoration: 'none', fontWeight: '500' }}>
Learn about Signal Capture ‚Üí
</a>
</div>

<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '8px', padding: '1.5rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Calculating Rewards</h3>
<p style={{ marginBottom: '1rem', color: 'var(--ifm-color-emphasis-700)' }}>
Understand the mathematical and economic principles behind reward calculation in the Intuition ecosystem.
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginBottom: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Mathematics</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Economics</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem' }}>Algorithms</span>
</div>
<a href="/docs/introduction/the-primitives/structuring/calculating-rewards" style={{ color: 'var(--ifm-color-primary)', textDecoration: 'none', fontWeight: '500' }}>
Learn about Reward Calculation ‚Üí
</a>
</div>

</div>

## Structuring Principles

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Key Principles</h3>
<div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', gap: '1rem' }}>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Modularity</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Design structures that can be easily combined and reused across different contexts.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Scalability</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Ensure your data structures can grow and evolve without breaking existing relationships.
</p>
</div>
<div style={{ border: '1px solid var(--ifm-color-emphasis-300)', borderRadius: '6px', padding: '1rem', backgroundColor: 'var(--ifm-background-color)' }}>
<h4 style={{ marginTop: 0, marginBottom: '0.5rem' }}>Interoperability</h4>
<p style={{ margin: 0, fontSize: '0.9rem' }}>
Create structures that work seamlessly with other systems and data sources.
</p>
</div>
</div>
</div>

## Learning Path

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', marginTop: '2rem' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Recommended Learning Order</h3>
<ol style={{ margin: 0, paddingLeft: '1.5rem' }}>
<li><strong>Atoms</strong> - Master the building blocks of data structure</li>
<li><strong>Triples</strong> - Learn to create meaningful relationships</li>
<li><strong>Capturing Signal</strong> - Understand how to gather user input</li>
<li><strong>Calculating Rewards</strong> - Explore the economic mechanisms</li>
</ol>
</div>

## Prerequisites

Before diving into structuring techniques, make sure you have a solid understanding of the [Fundamentals](/docs/introduction/the-primitives/fundamentals) section, particularly:

- Basic concepts of Atoms, Triples, and Signal
- Understanding of the economic model (Fees & Rewards)
- Familiarity with state interpretation approaches

## Next Steps

After mastering structuring techniques, explore the [Developer Tools](/docs/developer-tools) section to learn how to implement these concepts in your applications. 

---

### File: docs/guides/introduction/the-primitives/structuring/triples.md


# Triples

Triples are the fundamental way to create relationships between atoms in Intuition. They follow a subject-predicate-object structure that enables rich, interconnected knowledge graphs.

## What are Triples?

A triple consists of three atoms connected in a specific relationship:
- **Subject**: The entity being described
- **Predicate**: The relationship or property
- **Object**: The value or target of the relationship

## Basic Triple Structure

```json
{
  "id": "did:ethr:mainnet:0x...",
  "subject": "did:ethr:mainnet:0x...", // Subject atom
  "predicate": "did:ethr:mainnet:0x...", // Predicate atom
  "object": "did:ethr:mainnet:0x...", // Object atom
  "metadata": {
    "created": "2024-01-15T10:30:00Z",
    "creator": "did:ethr:mainnet:0x...",
    "confidence": 0.95
  }
}
```

## Triple Categories

### 1. Property Triples
Describe attributes or characteristics of entities.

**Example**: "Ethereum is decentralized"
- Subject: Ethereum atom
- Predicate: "is" atom
- Object: "decentralized" atom

```json
{
  "subject": "did:ethr:mainnet:0x...", // Ethereum
  "predicate": "did:ethr:mainnet:0x...", // is
  "object": "did:ethr:mainnet:0x...", // decentralized
  "type": "property"
}
```

### 2. Relationship Triples
Connect entities through specific relationships.

**Example**: "Vitalik Buterin created Ethereum"
- Subject: Vitalik Buterin atom
- Predicate: "created" atom
- Object: Ethereum atom

```json
{
  "subject": "did:ethr:mainnet:0x...", // Vitalik Buterin
  "predicate": "did:ethr:mainnet:0x...", // created
  "object": "did:ethr:mainnet:0x...", // Ethereum
  "type": "relationship"
}
```

### 3. Classification Triples
Establish hierarchical or categorical relationships.

**Example**: "Machine Learning is a subset of AI"
- Subject: Machine Learning atom
- Predicate: "is a subset of" atom
- Object: AI atom

```json
{
  "subject": "did:ethr:mainnet:0x...", // Machine Learning
  "predicate": "did:ethr:mainnet:0x...", // is a subset of
  "object": "did:ethr:mainnet:0x...", // AI
  "type": "classification"
}
```

## Creating Triples

### Using the SDK (copy‚Äëpaste ready)

```ts
import { createAtomFromString, createTripleStatement } from '@0xintuition/sdk'
import { createPublicClient, createWalletClient, http } from 'viem'
import { privateKeyToAccount } from 'viem/accounts'
import { sepolia } from 'viem/chains'
import { getEthMultiVaultAddressFromChainId } from '@0xintuition/sdk'

// 1) Configure viem clients (example uses Sepolia)
const account = privateKeyToAccount(process.env.PRIVATE_KEY as `0x${string}`)
const walletClient = createWalletClient({ account, chain: sepolia, transport: http() })
const publicClient = createPublicClient({ chain: sepolia, transport: http() })

// 2) MultiVault address for current chain
const multivaultAddress = getEthMultiVaultAddressFromChainId(sepolia.id)

// 3) Create three atoms
const a = await createAtomFromString({ walletClient, publicClient, address: multivaultAddress }, 'Ethereum')
const b = await createAtomFromString({ walletClient, publicClient, address: multivaultAddress }, 'is')
const c = await createAtomFromString({ walletClient, publicClient, address: multivaultAddress }, 'decentralized')

// 4) Create the triple (uses vaultIds from the created atoms)
const triple = await createTripleStatement(
  { walletClient, publicClient, address: multivaultAddress },
  { args: [a.state.vaultId, b.state.vaultId, c.state.vaultId] },
)

console.log('Created triple vaultId:', triple.state[0].vaultId)
```

### Validation Rules

- **Required Fields**: `subject`, `predicate`, `object`, `metadata.creator`
- **Unique Relationships**: Each subject-predicate-object combination should be unique
- **Valid Atoms**: All three components must be valid, existing atoms
- **Confidence Score**: Must be between 0 and 1

## Advanced Triple Patterns

### 1. Temporal Triples
Include time-based information.

```json
{
  "subject": "did:ethr:mainnet:0x...", // Ethereum
  "predicate": "did:ethr:mainnet:0x...", // launched in
  "object": "did:ethr:mainnet:0x...", // 2015
  "temporal": {
    "validFrom": "2015-07-30T00:00:00Z",
    "validTo": null
  }
}
```

### 2. Weighted Triples
Include confidence or weight information.

```json
{
  "subject": "did:ethr:mainnet:0x...", // Bitcoin
  "predicate": "did:ethr:mainnet:0x...", // is similar to
  "object": "did:ethr:mainnet:0x...", // Gold
  "weight": 0.85,
  "evidence": ["market behavior", "store of value"]
}
```

### 3. Contextual Triples
Include specific context or conditions.

```json
{
  "subject": "did:ethr:mainnet:0x...", // Python
  "predicate": "did:ethr:mainnet:0x...", // is popular for
  "object": "did:ethr:mainnet:0x...", // Machine Learning
  "context": {
    "domain": "programming",
    "timeframe": "2020-2024",
    "geographic": "global"
  }
}
```

## Triple Composition Patterns

### 1. Chain Composition
Connect multiple triples in a chain.

```
A ‚Üí B ‚Üí C ‚Üí D
```

**Example**: "Ethereum is a blockchain" + "Blockchain is decentralized" ‚Üí "Ethereum is decentralized"

### 2. Tree Composition
Create hierarchical structures.

```
        Root
       /    \
   Child1  Child2
   /    \     |
Leaf1  Leaf2 Leaf3
```

### 3. Graph Composition
Create complex interconnected networks.

```
A ‚Üê‚Üí B ‚Üê‚Üí C
‚Üì    ‚Üì    ‚Üì
D ‚Üê‚Üí E ‚Üê‚Üí F
```

## Best Practices

### 1. Consistent Predicates
- Use standardized predicate atoms
- Maintain consistent terminology
- Avoid ambiguous relationships

### 2. Meaningful Relationships
- Ensure relationships add value
- Avoid redundant or obvious triples
- Focus on non-trivial connections

### 3. Quality Control
- Verify accuracy of relationships
- Include appropriate confidence scores
- Provide evidence when possible

### 4. Scalability
- Design for extensibility
- Consider performance implications
- Plan for complex queries

## Querying Triples

### Basic Queries (GraphQL)

```ts
import { configureClient, createServerClient, API_URL_DEV, GetTriplesDocument } from '@0xintuition/graphql'

configureClient({ apiUrl: API_URL_DEV })
const client = createServerClient({})

// Find triples where object label contains "decentralized"
const data = await client.request(GetTriplesDocument, {
  limit: 10,
  where: {
    object: { label: { _ilike: '%decentralized%' } },
  },
})

console.log(data.triples.length)
```

### Complex Queries (GraphQL)

```ts
import { configureClient, createServerClient, API_URL_DEV, GetTriplesDocument } from '@0xintuition/graphql'

configureClient({ apiUrl: API_URL_DEV })
const client = createServerClient({})

// Find AI subsets
const aiSubsets = await client.request(GetTriplesDocument, {
  limit: 20,
  where: {
    predicate: { label: { _ilike: '%is a subset of%' } },
    object: { label: { _ilike: '%AI%' } },
  },
})

console.log(aiSubsets.triples.length)
```

## Triple Analytics

### Usage Metrics
- **Frequency**: How often a triple is referenced
- **Confidence**: Average confidence score
- **Consensus**: Agreement level among contributors

### Network Analysis
- **Centrality**: Importance of atoms in the network
- **Clustering**: Groups of related atoms
- **Path Analysis**: Shortest paths between atoms

## Next Steps

Now that you understand how to structure triples, explore:

- [Capturing Signal](./capturing-signal.md) - Learn how to measure triple usage and relevance
- [Calculating Rewards](./calculating-rewards.md) - Discover how triple interactions generate rewards
- [Atoms](./atoms.md) - Review atom structure fundamentals

---

### File: docs/guides/introduction/why-intuition.md


# Why Intuition?

> **Every interaction online is an attestation.**
> A review or a purchase on Amazon, a comment on Reddit, the watching of a show on Netflix, a retweet, a LinkedIn endorsement, a 'follow', a bookmark, the ordering of an Uber, even a "like" ‚Äî all are forms of attestations: claims made by things about things.

But attestations today are fragmented, unverifiable, and platform-locked. They don't move with you. They don't carry weight. They aren't semantically structured and unambiguously consumable by machines.

**Intuition changes that.** We've rebuilt attestations as first-class, tokenized primitives ‚Äî structured, portable, and economically backed. _Attestations on steroids._

## Decentralizing Information with Attestations

**Blockchains decentralized money.
Intuition decentralizes information ‚Äî by offering next-generation attestation infrastructure.**

An attestation in Intuition isn't just a line of text. It's:

- **Verifiable** ‚Äî signed and attributable
- **Ownable** ‚Äî belongs to the creator, not a platform
- **Discoverable** ‚Äî structured as a Triple (subject ‚Üí predicate ‚Üí object)
- **Valuable** ‚Äî backed by economic incentives through bonding curves

This turns the messy stream of human expression into a global knowledge substrate that's actually useful to developers, communities, and AI agents.

## Information Finance: Attestations as Assets

Intuition pioneers **Information Finance (InfoFi)**: the idea that information can be valued and exchanged just like money.

- **Ideas become assets** ‚Äî an attestation isn't just data, it's collateralized
- **Reputation becomes capital** ‚Äî your attestations are your portfolio of credibility
- **Knowledge flows freely** ‚Äî attestations aren't siloed; they're cross-platform and composable

Attestations are no longer passive byproducts of online activity ‚Äî they're programmable building blocks for apps and agents.

## The $200 Trillion Problem

The global knowledge economy is worth over **$200 trillion**, yet:

- Most of its value is created by individuals
- Less than 1% of that value flows back to the creators
- Instead, tech monopolies capture and silo it

**The result:** broken rails, misinformation, and AI systems consuming oceans of low-quality data without provenance.

Attestations are the missing rails. When data becomes signed, tokenized, and portable, it allows value to flow back to contributors and trust to flow into the systems that need it most.

## Rebuilding the Rails of Knowledge

Intuition makes attestations first-class protocol objects. That means:

- **Facts, claims, and perspectives** are all structured as attestations
- **Credibility is collateralized** ‚Äî good attestations earn rewards; bad ones cost you stake
- **Distribution is programmatic** ‚Äî attestations move frictionlessly across apps, chains, and agents

Think of it as the Ethereum moment for knowledge: where attestations flow as freely as tokens, powering new classes of decentralized infrastructure.

## Programmatic Monetization and Distribution

Attestations aren't just portable ‚Äî they're **monetizable**.

With Intuition, every attestation can plug into programmatic distribution rails:

- Censorship-resistant search and discovery
- Verifiable knowledge bases
- Open data marketplaces
- Training sets for AI agents

Each attestation carries weight, liquidity, and discoverability, ensuring no single platform can gate what's visible or valuable.

## From Information ‚Üí Intuition

Why does this matter? Because **raw information without provenance is noise.**

Attestations, structured and economically backed, create a higher-resolution understanding of the world. They transform scattered data into collective intuition ‚Äî fueling smarter AI, safer markets, and more confident human decision-making.

## Reviving the Semantic Web with Crypto-Economic Consensus

The Semantic Web failed because it required global consensus on standards without incentives to achieve it. Different organizations created competing schemas, vocabularies fragmented, and there was no mechanism to converge on shared identifiers.

**Intuition solves this with crypto-economics** ‚Äî the same force that achieves distributed consensus in blockchains now drives semantic standardization:

- **Incentivized identifiers** ‚Äî stake on canonical IDs for entities, creating economic pressure toward convergence
- **Market-driven standards** ‚Äî the most useful data structures attract the most stake and become de facto standards
- **Emergent interoperability** ‚Äî economic incentives naturally align participants toward compatible schemas
- **Consensus through collateralization** ‚Äî disagreements resolve through staking, not committees

Where the Semantic Web asked the world to voluntarily agree on standards, Intuition makes consensus profitable. Attestations become the economic glue that binds distributed actors to shared semantic structures.

## How It Works: Skin in the Game

On Intuition, every attestation has consequences:

- **Publish a useful attestation** ‚Üí earn reputation and rewards
- **Publish misinformation** ‚Üí lose your stake and credibility
- **Signal strong conviction** ‚Üí stake more on your attestation
- **Build trust** ‚Üí accumulate a reputation that travels with you
- **Use consensus identifiers** ‚Üí earn more by aligning with the network
- **Fork data structures** ‚Üí lose money by fragmenting liquidity

This flips today's internet incentives: no longer "reward the loudest," but reward the most credible and interoperable attestations.

### The Fork Choice Rule for Data

Just like blockchains have fork choice rules that determine the canonical chain, Intuition creates economic pressure toward canonical identifiers and data structures. **When you use consensus identifiers, you tap into existing liquidity pools and network effects. When you create competing forks, you isolate yourself economically.**

**Example:** Imagine two identifiers for "Ethereum":
- **Identifier A**: Used by 10,000 attestations with $1M total stake
- **Identifier B**: Used by 50 attestations with $5K total stake

If you make an attestation about Ethereum:
- Using **Identifier A** ‚Üí Your attestation joins a liquid market, benefits from network effects, earns higher rewards
- Using **Identifier B** ‚Üí Your attestation is isolated, has minimal visibility, earns negligible rewards

The economic incentive is clear: converge on consensus or pay the price. This same dynamic applies to data structures, schemas, and semantic relationships. The network naturally evolves toward maximum interoperability because **consensus literally pays.**

## Digital Sovereignty and Data Ownership

**Your attestations are yours.** Not Facebook's, not LinkedIn's, not OpenAI's.

- You **own** them
- You **control** who can access them
- You **capture** the value they generate
- They **travel** with you across every app, chain, or agent

Attestations become the backbone of digital sovereignty.

## The Trust Layer for AI

AI doesn't just need more data ‚Äî it needs **verifiable attestations about data**:

- Who said it
- With what reputation
- With what conviction

Intuition provides the trust graph of attestations. AI systems can finally ground themselves in data with provenance, weights, and economic signals ‚Äî not just raw text.

This makes AI more reliable while ensuring humans share in the value of the knowledge they produce.

## What You Can Build

By treating attestations as programmable primitives, you can create:

- **Verifiable identity systems**
- **Reputation networks** powered by attestations
- **Decentralized fact-checking** with stakes
- **AI agents** that reason over attestations as context
- **Information markets** where attestations themselves are the assets

## Join the Movement

Intuition is about reclaiming the internet by giving attestations real weight.

Whether you're a developer, researcher, or community builder, your contributions aren't just ephemeral posts ‚Äî they're portable, valuable attestations that strengthen the global knowledge graph.

**Together, we can rebuild the web around truth, attribution, and trust.**

---

### File: docs/guides/intuition-ai/index.mdx


# Intuition AI

Intuition AI enables powerful integrations between AI models and the Intuition knowledge graph, allowing AI systems to query, create, and interact with decentralized trust data.

## What is Intuition AI?

Intuition AI bridges the gap between artificial intelligence and decentralized knowledge systems, enabling:

- **Semantic Queries**: AI models can query the knowledge graph using natural language
- **Knowledge Creation**: Programmatically create Atoms and Triples through AI analysis
- **Trust Analysis**: Leverage AI for intelligent signal attestation and pattern recognition
- **Context Enhancement**: Enrich AI responses with verified on-chain data

## Model Context Protocol (MCP) Integration

The cornerstone of Intuition AI is our MCP server, which provides a standardized way for AI models to interact with the Intuition protocol through the Model Context Protocol specification.

### Key Capabilities

- **Extract Triples**: Convert natural language into structured knowledge triples
- **Search Entities**: Find atoms, accounts, and concepts across the knowledge graph
- **Account Information**: Retrieve detailed information about accounts and their connections
- **Social Graphs**: Explore following/follower relationships and recommendations
- **List Management**: Search and manage curated lists of entities

## Getting Started

Ready to integrate AI with Intuition? Check out our MCP server:

- **[Intuition MCP Server](/guides/intuition-ai/mcp-server)** - Complete guide to setting up and using the MCP server for AI integrations

## Use Cases

### Knowledge Graph Queries
AI models can ask questions like "What are the most trusted DeFi protocols?" and receive structured data from the knowledge graph.

### Automated Knowledge Creation
Transform unstructured data and natural language into structured Atoms and Triples automatically.

### Trust Signal Analysis
Use AI to analyze patterns in trust signals and provide insights about entity reliability.

### Enhanced AI Context
Enrich AI model responses with verified, on-chain data about entities and relationships.

## Open Source

All Intuition AI components are open source and available on GitHub. The MCP server is actively maintained and welcomes community contributions. 

---

### File: docs/guides/intuition-ai/mcp-server.md


# Intuition MCP Server

The Intuition MCP Server is an HTTP stream server designed to interact with the Intuition knowledge graph, enabling AI models and applications to query and manage data through powerful tools built on the Model Context Protocol.

## Overview

The Intuition MCP Server acts as a bridge between AI applications and the Intuition protocol, providing:

- **Structured data extraction** from natural language using triple extraction
- **Comprehensive search** for entities (atoms), accounts, and concepts
- **Social graph exploration** with followers and following relationships
- **Account information** retrieval with detailed connection data
- **List management** for curated entity collections

This server supports both modern Streamable HTTP and legacy Server-Sent Events (SSE) transports for maximum compatibility.

## GitHub Repository

<div style={{
  padding: '2rem',
  borderRadius: '12px',
  background: 'linear-gradient(135deg, #6B73FF 0%, #000DFF 100%)',
  textAlign: 'center',
  margin: '2rem 0'
}}>
  <h3 style={{ color: 'white', marginBottom: '1rem' }}>
    Intuition MCP Server
  </h3>
  <p style={{ color: 'rgba(255,255,255,0.9)', marginBottom: '1.5rem' }}>
    Open-source Model Context Protocol server for knowledge graph interactions
  </p>
  <a
    href="https://github.com/0xIntuition/intuition-mcp-server"
    target="_blank"
    rel="noopener noreferrer"
    style={{
      display: 'inline-block',
      padding: '12px 32px',
      backgroundColor: 'white',
      color: '#6B73FF',
      borderRadius: '8px',
      textDecoration: 'none',
      fontWeight: 'bold',
      fontSize: '1.1rem',
      transition: 'transform 0.2s',
    }}
    onMouseOver={(e) => e.currentTarget.style.transform = 'scale(1.05)'}
    onMouseOut={(e) => e.currentTarget.style.transform = 'scale(1)'}
  >
    View on GitHub ‚Üí
  </a>
</div>

## Getting Started

### Prerequisites
- Node.js 14+
- pnpm (install globally with `npm install -g pnpm`)

### Installation

1. **Clone the repository**:
```bash
git clone https://github.com/0xIntuition/intuition-mcp-server
cd intuition-mcp-server
```

2. **Install dependencies**:
```bash
pnpm install
```

3. **Start the server**:
```bash
pnpm run start:http
```

The server will be available at the configured host and port (e.g., http://localhost:3001).

## Available Tools

The MCP Server provides several powerful tools for interacting with the Intuition knowledge graph. All tools return responses sorted by relevance and include comprehensive information.

### search_atoms
Searches for entities (accounts, concepts, people) by name, description, URL, or ENS domain.

**Input Schema**:
```json
{
  "queries": ["ethereum", "vitalik.eth", "defi protocols"]
}
```

**Usage**: Find atoms related to your search terms with detailed information and connections.

### get_account_info
Retrieves detailed information about an account using its address or identifier.

**Input Schema**:
```json
{
  "identifier": "0x1234567890123456789012345678901234567890"
}
```

**Usage**: Get comprehensive account details including connections and activity.

### search_lists
Searches for curated lists of entities by name or description.

**Input Schema**:
```json
{
  "query": "top defi protocols"
}
```

**Usage**: Find organized collections of related entities with ranking and metadata.

### get_following
Retrieves atoms that an account follows, optionally filtered by predicate.

**Input Schema**:
```json
{
  "account_id": "0x3e2178cf851a0e5cbf84c0ff53f820ad7ead703b",
  "predicate": "recommend"
}
```

**Usage**: Explore what entities an account follows or recommends.

### get_followers
Retrieves followers of an account, optionally filtered by predicate.

**Input Schema**:
```json
{
  "account_id": "0x3e2178cf851a0e5cbf84c0ff53f820ad7ead703b",
  "predicate": "follow"
}
```

**Usage**: See who follows or recommends a specific account.

### search_account_ids
Resolves identifiers (like ENS domains) to account addresses.

**Input Schema**:
```json
{
  "identifier": "vitalik.eth"
}
```

**Usage**: Convert ENS names or other identifiers to blockchain addresses.

## Client Integration

### Using the MCP SDK

The server uses the Model Context Protocol SDK for client interactions. Here's a basic client setup:

```typescript
import { Client } from '@modelcontextprotocol/sdk/client/index.js';
import { StreamableHTTPClientTransport } from '@modelcontextprotocol/sdk/client/streamableHttp.js';

async function connectToMcpServer(url: string) {
  const client = new Client({
    name: 'intuition-client',
    version: '1.0.0',
  });

  const transport = new StreamableHTTPClientTransport(new URL(url));
  await client.connect(transport);

  return client;
}

// Usage
const client = await connectToMcpServer('http://localhost:3001');
const response = await client.callTool('search_atoms', {
  queries: ['ethereum']
});
```

### API Endpoints

The server provides these endpoints:
- `/mcp` - Streamable HTTP transport (recommended)
- `/sse` - Server-Sent Events transport (legacy support)

## Architecture

The MCP Server operates as an HTTP stream server, leveraging the Model Context Protocol to handle streaming requests and responses. This makes it ideal for real-time applications and large-scale data queries.

### Request Flow

1. **Client Request**: Application sends request to MCP endpoint
2. **Tool Processing**: Server processes the request using appropriate tool
3. **Knowledge Graph Query**: Server queries Intuition protocol
4. **Response Streaming**: Results are streamed back to client
5. **Client Processing**: Application handles streaming response data

## Deployment

The repository includes deployment configuration:

- **Dockerfile**: Ready for deployment to services like Render or any Docker-compatible host
- **render.yaml**: Configuration for Render deployment
- **Environment setup**: Configurable for different deployment environments

### Environment Variables

Configure these environment variables for your deployment:
- `PORT`: Server port (default: 3001)
- `HOST`: Server host (default: localhost)
- API credentials and other service-specific configurations

## Contributing

We welcome contributions to the Intuition MCP Server! To contribute:

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/your-feature`)
3. Commit your changes (`git commit -m "Add your feature"`)
4. Push to the branch (`git push origin feature/your-feature`)
5. Open a pull request

Please ensure your code follows the project's coding standards and includes tests.

## Support and Resources

- **[GitHub Repository](https://github.com/0xIntuition/intuition-mcp-server)**: Source code, issues, and contributions
- **[Model Context Protocol](https://modelcontextprotocol.io)**: Learn more about the MCP specification
- **[Intuition Protocol](https://docs.intuition.systems)**: Comprehensive protocol documentation

## License

The Intuition MCP Server is open-source software licensed under the MIT License. See the [LICENSE](https://github.com/0xIntuition/intuition-mcp-server/blob/main/LICENSE) file for details.

---

### File: docs/guides/intuition-node/backup.md


# Run a Node

Learn how to set up and run your own Intuition node to participate in the network using the official Rust implementation.

## Overview

The `intuition-rs` workspace is a comprehensive Rust workspace for blockchain data indexing and processing, featuring a modular architecture with multiple specialized services. This implementation provides high performance, memory safety, and reliability for running Intuition nodes and backend services.

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '1.5rem', borderRadius: '8px', margin: '1.5rem 0', border: '1px solid var(--ifm-color-emphasis-300)' }}>
<p style={{ margin: '0 0 0.5rem 0', fontWeight: '600', color: 'var(--ifm-color-emphasis-900)', fontSize: '1.1rem' }}>Node Requirements</p>
<p style={{ margin: 0, fontSize: '1rem', color: 'var(--ifm-color-emphasis-800)', lineHeight: '1.6' }}>
Running an Intuition node requires Docker, Rust toolchain, and proper environment configuration. This guide provides comprehensive setup instructions for local development and production deployments.
</p>
</div>

## Architecture

This workspace contains the following core services:

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5rem', marginBottom: '2rem' }}>

<div className="uniform-card">
<h3 className="uniform-card-title">Core Services</h3>
<p className="uniform-card-content">
<strong>CLI:</strong> Terminal UI client for interacting with the Intuition system<br/>
<strong>Consumer:</strong> Event processing pipeline using Redis Streams (RAW, DECODED, and RESOLVER consumers)<br/>
<strong>Models:</strong> Domain models and data structures for the Intuition system
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>CLI</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Consumer</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Models</span>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Infrastructure Services</h3>
<p className="uniform-card-content">
<strong>Hasura:</strong> GraphQL API with database migrations and configuration<br/>
<strong>Image Guard:</strong> Image processing and validation service<br/>
<strong>RPC Proxy:</strong> RPC call proxy with caching for eth_call methods
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>GraphQL</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Proxy</span>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Supporting Services</h3>
<p className="uniform-card-content">
<strong>Histocrawler:</strong> Historical data crawler<br/>
<strong>Shared Utils:</strong> Common utilities and shared code<br/>
<strong>Migration Scripts:</strong> Database migration utilities
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Crawler</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Utils</span>
</div>
</div>

</div>

## Prerequisites

### Required Tools

<div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem', marginBottom: '2rem' }}>
<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
<div style={{ width: '20px', height: '20px', borderRadius: '50%', backgroundColor: 'var(--ifm-color-success)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="white"><path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/></svg>
</div>
<span><strong>Rust toolchain:</strong> Install with <code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></span>
</div>
<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
<div style={{ width: '20px', height: '20px', borderRadius: '50%', backgroundColor: 'var(--ifm-color-success)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="white"><path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/></svg>
</div>
<span><strong>cargo-make:</strong> Install with <code>cargo install --force cargo-make</code></span>
</div>
<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
<div style={{ width: '20px', height: '20px', borderRadius: '50%', backgroundColor: 'var(--ifm-color-success)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="white"><path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/></svg>
</div>
<span><strong>Hasura CLI:</strong> Install with <code>curl -L https://github.com/hasura/graphql-engine/raw/stable/cli/get.sh | bash</code></span>
</div>
<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
<div style={{ width: '20px', height: '20px', borderRadius: '50%', backgroundColor: 'var(--ifm-color-success)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="white"><path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/></svg>
</div>
<span><strong>Node.js:</strong> For integration tests (install pnpm dependencies)</span>
</div>
</div>

### Environment Configuration

You'll need to set up environment variables for various services. Create a `.env` file based on the `.env.sample` template with the following required variables:

| Variable | Description | Source |
|----------|-------------|---------|
| `OPENAI_API_KEY` | OpenAI API key for AI features | [OpenAI Platform](https://platform.openai.com/api-keys) |
| `PINATA_GATEWAY_TOKEN` | Pinata gateway token for IPFS | [Pinata Dashboard](https://app.pinata.cloud/developers/gateway-settings) |
| `PINATA_API_JWT` | Pinata API JWT for IPFS uploads | [Pinata Dashboard](https://app.pinata.cloud/developers/api-keys) |
| `BASE_MAINNET_RPC_URL` | Base mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `BASE_SEPOLIA_RPC_URL` | Base sepolia testnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `ETHEREUM_MAINNET_RPC_URL` | Ethereum mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `LINEA_MAINNET_RPC_URL` | Linea mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `LINEA_SEPOLIA_RPC_URL` | Linea sepolia testnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `TRUST_TESTNET_RPC_URL` | Trust testnet RPC endpoint (local geth) | Local development |
| `TRUST_MAINNET_RPC_URL` | Trust mainnet RPC endpoint (local geth) | Local development |
| `INDEXER_SCHEMA` | Database schema for indexer (set to "local") | Local development |
| `INTUITION_CONTRACT_ADDRESS` | Intuition contract address | Contract deployment |

## Running the System

**Note**: All scripts are located in the `scripts/` directory and should be run from the project root.

### Option 1: Using Published Docker Images (Recommended)

```bash
# Start with local Ethereum node
cargo make start-local
```

### Option 2: Building from Source

```bash
# Build all Docker images from source
cargo make build-docker-images

# Start the system
cargo make start-local
```

### Option 3: Running with Integration Tests

```bash
# Start with tests enabled
cargo make start-local test
```

## Testing

### Run All Tests
```bash
cargo nextest run
```

### Run Integration Tests
```bash
cd integration-tests
export VITE_INTUITION_CONTRACT_ADDRESS=0x....
pnpm test src/follow.test.ts
```

### Run Specific Test Suites
```bash
# Test account operations
pnpm test src/create-person.test.ts

# Test vault operations
pnpm test src/vaults.test.ts

# Test AI agents
pnpm test src/ai-agents.test.ts
```

## Development

### CLI Tool
```bash
# Run the CLI to verify latest data
./scripts/cli.sh
```

### Code Quality
```bash
# Format code
cargo make fmt

# Run linter
cargo make clippy

# Run all checks
cargo make check
```

### Database Operations
```bash
# Start services and run migrations
cargo make start-docker-and-migrate

# Manual migration (if needed)
cp .env.sample .env
source .env
```

## Local Development Setup

### Using Local Ethereum Node

Add to your `.env` file:
```bash
INTUITION_CONTRACT_ADDRESS=0xB92EA1B47E4ABD0a520E9138BB59dBd1bC6C475B
START_BLOCK=0
```

Create local test data:
```bash
cd integration-tests
npm install
npm run create-predicates
```

### Manual Service Management

```bash
# Start all services
docker-compose -f docker/docker-compose-apps.yml up -d

# Stop all services
./scripts/stop.sh

# View logs
docker-compose -f docker/docker-compose-apps.yml logs -f
```

## Project Structure

```
intuition-rs/
‚îú‚îÄ‚îÄ apps/                 # Custom Rust applications
‚îÇ   ‚îú‚îÄ‚îÄ cli/             # Terminal UI client
‚îÇ   ‚îú‚îÄ‚îÄ consumer/        # Event processing pipeline (Redis Streams)
‚îÇ   ‚îú‚îÄ‚îÄ histocrawler/    # Historical data crawler
‚îÇ   ‚îú‚îÄ‚îÄ image-guard/     # Image processing service
‚îÇ   ‚îú‚îÄ‚îÄ models/          # Domain models & data structures
‚îÇ   ‚îú‚îÄ‚îÄ rpc-proxy/       # RPC proxy with caching
‚îÇ   ‚îî‚îÄ‚îÄ shared-utils/    # Common utilities
‚îú‚îÄ‚îÄ infrastructure/      # Infrastructure components
‚îÇ   ‚îú‚îÄ‚îÄ hasura/         # GraphQL API & migrations
‚îÇ   ‚îú‚îÄ‚îÄ blockscout/     # Blockchain explorer
‚îÇ   ‚îú‚îÄ‚îÄ drizzle/        # Database schema management
‚îÇ   ‚îú‚îÄ‚îÄ geth/           # Local Ethereum node config
‚îÇ   ‚îú‚îÄ‚îÄ indexer-and-cache-migrations/  # Database migrations
‚îÇ   ‚îú‚îÄ‚îÄ migration-scripts/  # Migration utilities
‚îÇ   ‚îî‚îÄ‚îÄ prometheus/     # Monitoring configuration
‚îú‚îÄ‚îÄ docker/             # Docker configuration
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose-apps.yml   # Application services
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose-shared.yml # Shared infrastructure
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile      # Multi-stage build
‚îú‚îÄ‚îÄ scripts/            # Shell scripts
‚îÇ   ‚îú‚îÄ‚îÄ start.sh        # System startup
‚îÇ   ‚îú‚îÄ‚îÄ stop.sh         # System shutdown
‚îÇ   ‚îú‚îÄ‚îÄ cli.sh          # CLI runner
‚îÇ   ‚îú‚îÄ‚îÄ init-dbs.sh     # Database initialization
‚îú‚îÄ‚îÄ integration-tests/  # End-to-end tests
‚îî‚îÄ‚îÄ README.md          # This file
```

## Event Processing Pipeline

The system processes blockchain events through multiple stages:

1. **RAW** - Raw event ingestion from blockchain
2. **DECODED** - Event decoding and parsing
3. **RESOLVER** - Data resolution and enrichment
4. **IPFS-UPLOAD** - Upload images to IPFS and track them in the local DB

### Supported Contract Versions
- Multivault v2.0

## Monitoring and Observability

### Logging

The system includes comprehensive logging capabilities:

**Features:**
- **Structured JSON Logging**: All services output machine-readable logs
- **Container Logs**: Direct access to service logs via Docker
- **Log Filtering**: Easy filtering by log level and service

**Benefits:**
- **Debugging**: Quickly find and analyze issues across services
- **Performance Monitoring**: Track service performance and bottlenecks
- **Audit Trail**: Complete visibility into system operations

**Getting Started:**
1. Start the system: `cargo make start-local`
2. View logs: `docker logs <service_name>`
3. Filter logs: `docker logs <service_name> | grep '"level":"INFO"'`

**JSON Logging:**
All consumer services output structured JSON logs with the following fields:
- `timestamp`: ISO 8601 timestamp
- `level`: Log level (INFO, WARN, ERROR, DEBUG)
- `fields.message`: Log message content
- `target`: Module path
- `filename`: Source file name
- `line_number`: Line number in source file
- `threadId`: Thread identifier

**Viewing Logs:**
```bash
# View container logs directly
docker logs decoded_consumer | grep '"level":"INFO"'
docker logs resolver_consumer | grep '"level":"ERROR"'
docker logs ipfs_upload_consumer | grep '"level":"WARN"'
```

## Troubleshooting

### Common Issues

1. **Database connection errors**: Ensure PostgreSQL is running and credentials are correct
2. **RPC endpoint issues**: Verify your Alchemy endpoints are valid and have sufficient quota
3. **Docker resource limits**: Ensure Docker has sufficient memory and CPU allocation

### Getting Help

- Check the [intuition-rs repository](https://github.com/0xIntuition/intuition-rs) for latest updates
- Review the [DeepWiki documentation](https://deepwiki.com/0xIntuition/intuition-rs) for detailed technical information
- Join the Intuition community for support

## How to Run Intuition in a Kubernetes Cluster

A comprehensive Kubernetes-based deployment infrastructure for blockchain indexing and data services, managed with ArgoCD and Terraform.

### Architecture Overview

This project deploys a complete blockchain indexing platform on Google Cloud Platform (GCP) using:

- **GKE Cluster**: Multi-node pool Kubernetes cluster
- **ArgoCD**: GitOps-based continuous deployment
- **Terraform**: Infrastructure as Code for GCP resources
- **Kustomize**: Kubernetes manifest management

### Core Services

#### Data Layer
- **TimescaleDB**: Time-series database with PostgreSQL extensions and AI capabilities
- **Indexer Database**: Dedicated database for blockchain indexing operations

#### Application Services
- **GraphQL Engine**: Hasura GraphQL API for data access
- **IPFS Node**: InterPlanetary File System for decentralized storage
- **Safe Content Service**: Content validation and processing
- **TimescaleDB Vectorizer Worker**: Vector processing for AI/ML workloads
- **Histocrawler**: Historical data crawling and indexing service
- **Image Guard**: Image validation and security service
- **RPC Proxy**: Blockchain RPC request routing and caching

#### Consumer Services
- **Decoded Consumer**: Blockchain event decoding and processing
- **IPFS Upload Consumer**: IPFS content upload and management
- **Resolver Consumer**: Data resolution and lookup services

#### Management Tools
- **pgAdmin**: PostgreSQL administration interface
- **Ingress Controller**: Traffic routing and load balancing

### Infrastructure Components

#### GKE Cluster Suggested Configuration
- **Region**: `us-west2`
- **Project**: `be-cluster`
- **Network**: Custom VPC with private/public subnets
- **Node Pools**:
  - `db-pool`: n2-standard-16 (dedicated for databases)
  - `app-pool`: e2-standard-2 (application services)
  - `consumer-pool`: custom-4-8192 (data processing)

#### Storage
- **Persistent Volumes**: GCP Persistent Disk with resizable storage class
- **IPFS Storage**: 50Gi persistent volume for IPFS data
- **Database Storage**: 50Gi for TimescaleDB

### Project Structure

```
gcp-deployment/
‚îú‚îÄ‚îÄ apps/                    # Kubernetes applications
‚îÇ   ‚îú‚îÄ‚îÄ consumers/          # Data processing consumers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decoded/        # Blockchain event decoder
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ipfs-upload/    # IPFS upload processor
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resolver/       # Data resolver service
‚îÇ   ‚îú‚îÄ‚îÄ graphql/            # Hasura GraphQL engine
‚îÇ   ‚îú‚îÄ‚îÄ histocrawler/       # Historical data crawler
‚îÇ   ‚îú‚îÄ‚îÄ image-guard/        # Image validation service
‚îÇ   ‚îú‚îÄ‚îÄ indexer-db/         # Indexer database
‚îÇ   ‚îú‚îÄ‚îÄ ipfs/               # IPFS node
‚îÇ   ‚îú‚îÄ‚îÄ pgadmin/            # PostgreSQL admin
‚îÇ   ‚îú‚îÄ‚îÄ rpc-proxy/          # RPC request proxy
‚îÇ   ‚îú‚îÄ‚îÄ safe-content/       # Content validation service
‚îÇ   ‚îú‚îÄ‚îÄ timescale_db/       # TimescaleDB instance
‚îÇ   ‚îú‚îÄ‚îÄ timescale_db_vectorizer/  # Vector processing
‚îÇ   ‚îî‚îÄ‚îÄ ingress/            # Ingress configuration
‚îú‚îÄ‚îÄ argocd/                 # ArgoCD configuration
‚îÇ   ‚îú‚îÄ‚îÄ coreapps/           # Core application definitions
‚îÇ   ‚îú‚îÄ‚îÄ namespacedapps/     # Namespace-specific apps
‚îÇ   ‚îú‚îÄ‚îÄ projects/           # ArgoCD project definitions
‚îÇ   ‚îî‚îÄ‚îÄ repos/              # Repository secrets
‚îú‚îÄ‚îÄ terraform/              # Infrastructure as Code
‚îÇ   ‚îî‚îÄ‚îÄ debug-gke/          # GKE cluster provisioning
‚îî‚îÄ‚îÄ test-kustomize/         # Kustomize testing
```

### Quick Start

#### Prerequisites
- Google Cloud SDK
- Terraform >= 1.0
- kubectl
- ArgoCD CLI

#### 1. Deploy Infrastructure
```bash
cd terraform/debug-gke
terraform init
terraform plan
terraform apply
```

#### 2. Configure ArgoCD
```bash
# Get GKE credentials
gcloud container clusters get-credentials debug-cluster --region us-west2

# Install ArgoCD
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# Apply ArgoCD configuration
kubectl apply -f argocd/
```

#### 3. Deploy Applications
Applications are automatically deployed via ArgoCD GitOps. The system monitors the Git repository and applies changes automatically.

### Configuration

#### Environment Variables
Key services require environment-specific configuration:

- **GraphQL Engine**: Database connection, CORS settings
- **TimescaleDB**: PostgreSQL credentials, AI extensions
- **IPFS**: Storage paths, network configuration
- **Safe Content**: Content validation rules
- **Histocrawler**: Blockchain endpoints, indexing parameters
- **Image Guard**: Image scanning policies, security rules
- **RPC Proxy**: Upstream RPC endpoints, caching configuration
- **Consumers**: Event processing queues, database connections

#### Secrets Management
Secrets are managed through Kubernetes secrets and external secret providers:
- Database credentials
- API keys
- Service account tokens

### Monitoring & Observability

#### Health Checks
- Liveness probes configured for all services
- Readiness probes for database services
- Custom health endpoints for GraphQL and IPFS

#### Logging
- Structured logging enabled for GraphQL engine
- Query logging for debugging
- WebSocket and HTTP request logging

### Security

#### Network Security
- Private GKE cluster with private nodes
- VPC-native networking
- NAT gateway for outbound internet access
- Ingress controller for external access

#### Access Control
- Workload Identity for GCP service accounts
- Kubernetes RBAC
- ArgoCD project-based access control

### Development

#### Local Development
```bash
# Test Kustomize configurations
cd test-kustomize
kubectl kustomize . | kubectl apply --dry-run=client

# Validate manifests
kubectl kustomize apps/graphql/ | kubectl apply --dry-run=client
```

#### Adding New Services
1. Create service directory in `apps/`
2. Add Kubernetes manifests (deployment, service, etc.)
3. Create ArgoCD application definition
4. Update project permissions if needed

### CI/CD Pipeline

The deployment follows GitOps principles:
1. Code changes pushed to Git repository
2. ArgoCD detects changes automatically
3. Applications updated in Kubernetes cluster
4. Health checks validate deployment

### Scaling

#### Horizontal Scaling
- Application services can scale horizontally via HPA
- Database services use StatefulSets for data persistence
- IPFS and GraphQL support multiple replicas

#### Vertical Scaling
- Node pools can be resized via Terraform
- Storage volumes support online resizing
- Resource limits configured per service

### Troubleshooting

#### Common Issues
1. **Database Connection**: Check TimescaleDB service and secrets
2. **IPFS Storage**: Verify PVC and storage class
3. **GraphQL Health**: Check liveness probe and database connectivity
4. **ArgoCD Sync**: Verify repository access and permissions
5. **Consumer Processing**: Check event queue connectivity and processing status
6. **Histocrawler**: Verify blockchain endpoint accessibility
7. **Image Guard**: Check image scanning service health
8. **RPC Proxy**: Validate upstream RPC endpoint connectivity

#### Debug Commands
```bash
# Check pod status
kubectl get pods -A

# View logs
kubectl logs -f deployment/graphql-engine

# Check ArgoCD applications
argocd app list

# Validate Terraform state
terraform plan
```

### Additional Resources

- [GKE Documentation](https://cloud.google.com/kubernetes-engine/docs)
- [ArgoCD User Guide](https://argo-cd.readthedocs.io/)
- [TimescaleDB Documentation](https://docs.timescale.com/)
- [Hasura GraphQL Engine](https://hasura.io/docs/)
- [Hasura Documentation](https://hasura.io/docs/)
- [Alchemy Dashboard](https://dashboard.alchemy.com/)
- [Pinata Documentation](https://docs.pinata.cloud/)

### Next Steps

Once your node is running successfully:

1. **Monitor the logs** to ensure all services are healthy
2. **Test the CLI tool** to verify data ingestion
3. **Configure monitoring** for production deployments
4. **Join the network** and start contributing to the Intuition ecosystem

The node implementation is under active development, so check the repository regularly for updates and new features. 

---

### File: docs/guides/intuition-node/kubernetes-deployment.md


# Run on Kubernetes Cluster

A comprehensive Kubernetes-based deployment infrastructure for blockchain indexing and data services, managed with ArgoCD and Terraform.

## Architecture Overview

This project deploys a complete blockchain indexing platform on Google Cloud Platform (GCP) using:

- **GKE Cluster**: Multi-node pool Kubernetes cluster
- **ArgoCD**: GitOps-based continuous deployment
- **Terraform**: Infrastructure as Code for GCP resources
- **Kustomize**: Kubernetes manifest management

## Core Services

### Data Layer
- **TimescaleDB**: Time-series database with PostgreSQL extensions and AI capabilities
- **Indexer Database**: Dedicated database for blockchain indexing operations

### Application Services
- **GraphQL Engine**: Hasura GraphQL API for data access
- **IPFS Node**: InterPlanetary File System for decentralized storage
- **Safe Content Service**: Content validation and processing
- **TimescaleDB Vectorizer Worker**: Vector processing for AI/ML workloads
- **Histocrawler**: Historical data crawling and indexing service
- **Image Guard**: Image validation and security service
- **RPC Proxy**: Blockchain RPC request routing and caching

### Consumer Services
- **Decoded Consumer**: Blockchain event decoding and processing
- **IPFS Upload Consumer**: IPFS content upload and management
- **Resolver Consumer**: Data resolution and lookup services

### Management Tools
- **pgAdmin**: PostgreSQL administration interface
- **Ingress Controller**: Traffic routing and load balancing

## Infrastructure Components

### GKE Cluster Suggested Configuration
- **Region**: `us-west2`
- **Project**: `be-cluster`
- **Network**: Custom VPC with private/public subnets
- **Node Pools**:
  - `db-pool`: n2-standard-16 (dedicated for databases)
  - `app-pool`: e2-standard-2 (application services)
  - `consumer-pool`: custom-4-8192 (data processing)

### Storage
- **Persistent Volumes**: GCP Persistent Disk with resizable storage class
- **IPFS Storage**: 50Gi persistent volume for IPFS data
- **Database Storage**: 50Gi for TimescaleDB

## Project Structure

```
gcp-deployment/
‚îú‚îÄ‚îÄ apps/                    # Kubernetes applications
‚îÇ   ‚îú‚îÄ‚îÄ consumers/          # Data processing consumers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ decoded/        # Blockchain event decoder
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ipfs-upload/    # IPFS upload processor
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ resolver/       # Data resolver service
‚îÇ   ‚îú‚îÄ‚îÄ graphql/            # Hasura GraphQL engine
‚îÇ   ‚îú‚îÄ‚îÄ histocrawler/       # Historical data crawler
‚îÇ   ‚îú‚îÄ‚îÄ image-guard/        # Image validation service
‚îÇ   ‚îú‚îÄ‚îÄ indexer-db/         # Indexer database
‚îÇ   ‚îú‚îÄ‚îÄ ipfs/               # IPFS node
‚îÇ   ‚îú‚îÄ‚îÄ pgadmin/            # PostgreSQL admin
‚îÇ   ‚îú‚îÄ‚îÄ rpc-proxy/          # RPC request proxy
‚îÇ   ‚îú‚îÄ‚îÄ safe-content/       # Content validation service
‚îÇ   ‚îú‚îÄ‚îÄ timescale_db/       # TimescaleDB instance
‚îÇ   ‚îú‚îÄ‚îÄ timescale_db_vectorizer/  # Vector processing
‚îÇ   ‚îî‚îÄ‚îÄ ingress/            # Ingress configuration
‚îú‚îÄ‚îÄ argocd/                 # ArgoCD configuration
‚îÇ   ‚îú‚îÄ‚îÄ coreapps/           # Core application definitions
‚îÇ   ‚îú‚îÄ‚îÄ namespacedapps/     # Namespace-specific apps
‚îÇ   ‚îú‚îÄ‚îÄ projects/           # ArgoCD project definitions
‚îÇ   ‚îî‚îÄ‚îÄ repos/              # Repository secrets
‚îú‚îÄ‚îÄ terraform/              # Infrastructure as Code
‚îÇ   ‚îî‚îÄ‚îÄ debug-gke/          # GKE cluster provisioning
‚îî‚îÄ‚îÄ test-kustomize/         # Kustomize testing
```

## Quick Start

### Prerequisites
- Google Cloud SDK
- Terraform >= 1.0
- kubectl
- ArgoCD CLI

### 1. Deploy Infrastructure
```bash
cd terraform/debug-gke
terraform init
terraform plan
terraform apply
```

### 2. Configure ArgoCD
```bash
# Get GKE credentials
gcloud container clusters get-credentials debug-cluster --region us-west2

# Install ArgoCD
kubectl create namespace argocd
kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml

# Apply ArgoCD configuration
kubectl apply -f argocd/
```

### 3. Deploy Applications
Applications are automatically deployed via ArgoCD GitOps. The system monitors the Git repository and applies changes automatically.

## Configuration

### Environment Variables
Key services require environment-specific configuration:

- **GraphQL Engine**: Database connection, CORS settings
- **TimescaleDB**: PostgreSQL credentials, AI extensions
- **IPFS**: Storage paths, network configuration
- **Safe Content**: Content validation rules
- **Histocrawler**: Blockchain endpoints, indexing parameters
- **Image Guard**: Image scanning policies, security rules
- **RPC Proxy**: Upstream RPC endpoints, caching configuration
- **Consumers**: Event processing queues, database connections

### Secrets Management
Secrets are managed through Kubernetes secrets and external secret providers:
- Database credentials
- API keys
- Service account tokens

## Monitoring & Observability

### Health Checks
- Liveness probes configured for all services
- Readiness probes for database services
- Custom health endpoints for GraphQL and IPFS

### Logging
- Structured logging enabled for GraphQL engine
- Query logging for debugging
- WebSocket and HTTP request logging

## Security

### Network Security
- Private GKE cluster with private nodes
- VPC-native networking
- NAT gateway for outbound internet access
- Ingress controller for external access

### Access Control
- Workload Identity for GCP service accounts
- Kubernetes RBAC
- ArgoCD project-based access control

## Development

### Local Development
```bash
# Test Kustomize configurations
cd test-kustomize
kubectl kustomize . | kubectl apply --dry-run=client

# Validate manifests
kubectl kustomize apps/graphql/ | kubectl apply --dry-run=client
```

### Adding New Services
1. Create service directory in `apps/`
2. Add Kubernetes manifests (deployment, service, etc.)
3. Create ArgoCD application definition
4. Update project permissions if needed

## CI/CD Pipeline

The deployment follows GitOps principles:
1. Code changes pushed to Git repository
2. ArgoCD detects changes automatically
3. Applications updated in Kubernetes cluster
4. Health checks validate deployment

## Scaling

### Horizontal Scaling
- Application services can scale horizontally via HPA
- Database services use StatefulSets for data persistence
- IPFS and GraphQL support multiple replicas

### Vertical Scaling
- Node pools can be resized via Terraform
- Storage volumes support online resizing
- Resource limits configured per service

## Troubleshooting

### Common Issues
1. **Database Connection**: Check TimescaleDB service and secrets
2. **IPFS Storage**: Verify PVC and storage class
3. **GraphQL Health**: Check liveness probe and database connectivity
4. **ArgoCD Sync**: Verify repository access and permissions
5. **Consumer Processing**: Check event queue connectivity and processing status
6. **Histocrawler**: Verify blockchain endpoint accessibility
7. **Image Guard**: Check image scanning service health
8. **RPC Proxy**: Validate upstream RPC endpoint connectivity

### Debug Commands
```bash
# Check pod status
kubectl get pods -A

# View logs
kubectl logs -f deployment/graphql-engine

# Check ArgoCD applications
argocd app list

# Validate Terraform state
terraform plan
```

## Additional Resources

- [GKE Documentation](https://cloud.google.com/kubernetes-engine/docs)
- [ArgoCD User Guide](https://argo-cd.readthedocs.io/)
- [TimescaleDB Documentation](https://docs.timescale.com/)
- [Hasura GraphQL Engine](https://hasura.io/docs/)
- [Hasura Documentation](https://hasura.io/docs/)
- [Alchemy Dashboard](https://dashboard.alchemy.com/)
- [Pinata Documentation](https://docs.pinata.cloud/)

---

### File: docs/guides/intuition-node/local-development-setup.md


Set up your local environment for developing and testing Intuition node services.

### Using Local Ethereum Node

Add to your `.env` file:
```bash
INTUITION_CONTRACT_ADDRESS=0xB92EA1B47E4ABD0a520E9138BB59dBd1bC6C475B
START_BLOCK=0
```

Create local test data:
```bash
cd integration-tests
npm install
npm run create-predicates
```

### Manual Service Management

```bash
# Start all services
docker-compose -f docker/docker-compose-apps.yml up -d

# Stop all services
./scripts/stop.sh

# View logs
docker-compose -f docker/docker-compose-apps.yml logs -f
```

---

### File: docs/guides/intuition-node/overview.md


# Overview

Learn how to set up and run your own Intuition node to participate in the network using the official Rust implementation.

## What is an Intuition Node?

The `intuition-rs` workspace is a comprehensive Rust workspace for blockchain data indexing and processing, featuring a modular architecture with multiple specialized services. This implementation provides high performance, memory safety, and reliability for running Intuition nodes and backend services.

:::warning Node Requirements
Running an Intuition node requires Docker, Rust toolchain, and proper environment configuration. This guide provides comprehensive setup instructions for local development and production deployments.
:::

### Supported Contract Versions
- Multivault v2.0

## Why Run a Node?

Running your own Intuition node provides several key benefits:

- **Full Data Access**: Direct access to all blockchain data without relying on third-party services
- **Network Participation**: Actively contribute to the decentralization and resilience of the Intuition network
- **Custom Indexing**: Tailor data indexing and processing to your specific needs
- **Performance Control**: Optimize performance and resource allocation based on your requirements
- **Enhanced Privacy**: Process and query data without exposing your queries to external services
- **Development Freedom**: Ideal for building and testing applications in a controlled environment

## Architecture

This workspace contains the following core services:

<div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '1.5rem', marginBottom: '2rem' }}>

<div className="uniform-card">
<h3 className="uniform-card-title">Core Services</h3>
<p className="uniform-card-content">
<strong>CLI:</strong> Terminal UI client for interacting with the Intuition system<br/>
<strong>Consumer:</strong> Event processing pipeline using Redis Streams (RAW, DECODED, and RESOLVER consumers)<br/>
<strong>Models:</strong> Domain models and data structures for the Intuition system
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>CLI</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Consumer</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Models</span>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Infrastructure Services</h3>
<p className="uniform-card-content">
<strong>Hasura:</strong> GraphQL API with database migrations and configuration<br/>
<strong>Image Guard:</strong> Image processing and validation service<br/>
<strong>RPC Proxy:</strong> RPC call proxy with caching for eth_call methods
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>GraphQL</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Proxy</span>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Supporting Services</h3>
<p className="uniform-card-content">
<strong>Histocrawler:</strong> Historical data crawler<br/>
<strong>Shared Utils:</strong> Common utilities and shared code<br/>
<strong>Migration Scripts:</strong> Database migration utilities
</p>
<div style={{ display: 'flex', gap: '0.5rem', flexWrap: 'wrap', marginTop: '1rem' }}>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Crawler</span>
<span style={{ backgroundColor: 'var(--ifm-color-emphasis-100)', padding: '0.25rem 0.5rem', borderRadius: '4px', fontSize: '0.875rem', color: 'var(--ifm-color-emphasis-700)' }}>Utils</span>
</div>
</div>

</div>

### Event Processing Pipeline

The system processes blockchain events through multiple stages:

1. **RAW** - Raw event ingestion from blockchain
2. **DECODED** - Event decoding and parsing
3. **RESOLVER** - Data resolution and enrichment
4. **IPFS-UPLOAD** - Upload images to IPFS and track them in the local DB

## Prerequisites

### Required Tools

<div style={{ display: 'flex', flexDirection: 'column', gap: '0.75rem', marginBottom: '2rem' }}>
<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
<div style={{ width: '20px', height: '20px', borderRadius: '50%', backgroundColor: 'var(--ifm-color-success)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="white"><path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/></svg>
</div>
<span><strong>Rust toolchain:</strong> Install with <code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></span>
</div>
<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
<div style={{ width: '20px', height: '20px', borderRadius: '50%', backgroundColor: 'var(--ifm-color-success)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="white"><path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/></svg>
</div>
<span><strong>cargo-make:</strong> Install with <code>cargo install --force cargo-make</code></span>
</div>
<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
<div style={{ width: '20px', height: '20px', borderRadius: '50%', backgroundColor: 'var(--ifm-color-success)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="white"><path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/></svg>
</div>
<span><strong>Hasura CLI:</strong> Install with <code>curl -L https://github.com/hasura/graphql-engine/raw/stable/cli/get.sh | bash</code></span>
</div>
<div style={{ display: 'flex', alignItems: 'center', gap: '0.5rem' }}>
<div style={{ width: '20px', height: '20px', borderRadius: '50%', backgroundColor: 'var(--ifm-color-success)', display: 'flex', alignItems: 'center', justifyContent: 'center', flexShrink: 0 }}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="white"><path d="M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z"/></svg>
</div>
<span><strong>Node.js:</strong> For integration tests (install pnpm dependencies)</span>
</div>
</div>

### Environment Configuration

You'll need to set up environment variables for various services. Create a `.env` file based on the `.env.sample` template with the following required variables:

| Variable | Description | Source |
|----------|-------------|---------|
| `OPENAI_API_KEY` | OpenAI API key for AI features | [OpenAI Platform](https://platform.openai.com/api-keys) |
| `PINATA_GATEWAY_TOKEN` | Pinata gateway token for IPFS | [Pinata Dashboard](https://app.pinata.cloud/developers/gateway-settings) |
| `PINATA_API_JWT` | Pinata API JWT for IPFS uploads | [Pinata Dashboard](https://app.pinata.cloud/developers/api-keys) |
| `BASE_MAINNET_RPC_URL` | Base mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `BASE_SEPOLIA_RPC_URL` | Base sepolia testnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `ETHEREUM_MAINNET_RPC_URL` | Ethereum mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `LINEA_MAINNET_RPC_URL` | Linea mainnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `LINEA_SEPOLIA_RPC_URL` | Linea sepolia testnet RPC endpoint | [Alchemy Dashboard](https://dashboard.alchemy.com/apps) |
| `TRUST_TESTNET_RPC_URL` | Trust testnet RPC endpoint (local geth) | Local development |
| `TRUST_MAINNET_RPC_URL` | Trust mainnet RPC endpoint (local geth) | Local development |
| `INDEXER_SCHEMA` | Database schema for indexer (set to "local") | Local development |
| `INTUITION_CONTRACT_ADDRESS` | Intuition contract address | Contract deployment |

## Next Steps

Once you understand the architecture and have the prerequisites ready:

1. Learn about [why we chose Rust](rust-backend.md) for the backend implementation
2. Follow the [Running a Node](run-an-intuition-node.md) guide to start your node
3. Explore [Local Development Setup](local-development-setup.md) for development workflows
4. Check [Kubernetes Deployment](kubernetes-deployment.md) for production deployments

---

### File: docs/guides/intuition-node/run-an-intuition-node.md


# Get Started

**Note**: All scripts are located in the `scripts/` directory and should be run from the project root.

## Running the System

### Option 1: Using Published Docker Images (Recommended)

```bash
# Start with local Ethereum node
cargo make start-local
```

### Option 2: Building from Source

```bash
# Build all Docker images from source
cargo make build-docker-images

# Start the system
cargo make start-local
```

### Option 3: Running with Integration Tests

```bash
# Start with tests enabled
cargo make start-local test
```

## Testing

### Run All Tests
```bash
cargo nextest run
```

### Run Integration Tests
```bash
cd integration-tests
export VITE_INTUITION_CONTRACT_ADDRESS=0x....
pnpm test src/follow.test.ts
```

### Run Specific Test Suites
```bash
# Test account operations
pnpm test src/create-person.test.ts

# Test vault operations
pnpm test src/vaults.test.ts

# Test AI agents
pnpm test src/ai-agents.test.ts
```

### Development Testing

#### CLI Tool
```bash
# Run the CLI to verify latest data
./scripts/cli.sh
```

#### Code Quality
```bash
# Format code
cargo make fmt

# Run linter
cargo make clippy

# Run all checks
cargo make check
```

#### Database Operations
```bash
# Start services and run migrations
cargo make start-docker-and-migrate

# Manual migration (if needed)
cp .env.sample .env
source .env
```

## Monitoring and Observability

### Logging

The system includes comprehensive logging capabilities:

**Features:**
- **Structured JSON Logging**: All services output machine-readable logs
- **Container Logs**: Direct access to service logs via Docker
- **Log Filtering**: Easy filtering by log level and service

**Benefits:**
- **Debugging**: Quickly find and analyze issues across services
- **Performance Monitoring**: Track service performance and bottlenecks
- **Audit Trail**: Complete visibility into system operations

**Getting Started:**
1. Start the system: `cargo make start-local`
2. View logs: `docker logs <service_name>`
3. Filter logs: `docker logs <service_name> | grep '"level":"INFO"'`

**JSON Logging:**
All consumer services output structured JSON logs with the following fields:
- `timestamp`: ISO 8601 timestamp
- `level`: Log level (INFO, WARN, ERROR, DEBUG)
- `fields.message`: Log message content
- `target`: Module path
- `filename`: Source file name
- `line_number`: Line number in source file
- `threadId`: Thread identifier

**Viewing Logs:**
```bash
# View container logs directly
docker logs decoded_consumer | grep '"level":"INFO"'
docker logs resolver_consumer | grep '"level":"ERROR"'
docker logs ipfs_upload_consumer | grep '"level":"WARN"'
```

## Troubleshooting

### Common Issues

1. **Database connection errors**: Ensure PostgreSQL is running and credentials are correct
2. **RPC endpoint issues**: Verify your Alchemy endpoints are valid and have sufficient quota
3. **Docker resource limits**: Ensure Docker has sufficient memory and CPU allocation

### Getting Help

- Check the [intuition-rs repository](https://github.com/0xIntuition/intuition-rs) for latest updates
- Review the [DeepWiki documentation](https://deepwiki.com/0xIntuition/intuition-rs) for detailed technical information
- Join the Intuition community for support

## Next Steps

Once your node is running successfully:

1. **Monitor the logs** to ensure all services are healthy
2. **Test the CLI tool** to verify data ingestion
3. **Configure monitoring** for production deployments
4. **Join the network** and start contributing to the Intuition ecosystem

The node implementation is under active development, so check the repository regularly for updates and new features.

---

### File: docs/guides/intuition-node/rust-backend.md


# Rust Backend

## Why Rust?

The Intuition backend is built with Rust, a systems programming language that offers unique advantages for blockchain infrastructure:

<div className="uniform-card-grid">

<div className="uniform-card">
<h3 className="uniform-card-title">Performance and Efficiency</h3>
<p className="uniform-card-content">
<strong>Zero-cost abstractions</strong>: Write high-level code without runtime overhead<br/>
<strong>Memory efficiency</strong>: Minimal memory footprint compared to garbage-collected languages<br/>
<strong>Concurrent processing</strong>: Built-in support for safe concurrent operations<br/>
<strong>Native performance</strong>: Compiles to machine code for maximum speed
</p>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Safety and Reliability</h3>
<p className="uniform-card-content">
<strong>Memory safety</strong>: Eliminates entire classes of bugs (null pointer dereferences, buffer overflows, data races)<br/>
<strong>Type safety</strong>: Strong static typing catches errors at compile time<br/>
<strong>Error handling</strong>: Explicit error handling through Result types<br/>
<strong>No runtime crashes</strong>: Memory safety guarantees prevent unexpected crashes
</p>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Developer Experience</h3>
<p className="uniform-card-content">
<strong>Modern tooling</strong>: Cargo package manager and build system<br/>
<strong>Rich ecosystem</strong>: Growing library ecosystem for blockchain and web services<br/>
<strong>Documentation</strong>: Built-in documentation tools and testing framework<br/>
<strong>Community</strong>: Active and supportive open-source community
</p>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Blockchain-Specific Benefits</h3>
<p className="uniform-card-content">
<strong>Predictable performance</strong>: No garbage collection pauses during critical operations<br/>
<strong>Resource optimization</strong>: Efficient resource usage for indexing large amounts of blockchain data<br/>
<strong>WebAssembly support</strong>: Can compile to WASM for cross-platform compatibility<br/>
<strong>Security</strong>: Memory safety is crucial when handling financial transactions and user data
</p>
</div>

</div>

## The Intuition Rust Monorepo

The `intuition-rs` repository is organized as a Rust workspace, which provides several key benefits:

### Monorepo Architecture
A monorepo (monolithic repository) consolidates all backend services and shared code in a single repository, offering:

- **Code sharing**: Common utilities and models shared across all services
- **Unified versioning**: All services stay in sync with compatible versions
- **Atomic changes**: Update multiple services in a single commit
- **Simplified dependencies**: Internal dependencies managed through workspace
- **Consistent tooling**: Shared build, test, and lint configurations

### Workspace Organization
The workspace is structured into logical layers:

#### Applications Layer (`apps/`)
Independent services that can be deployed separately:
- Each app has its own binary
- Shared dependencies managed at workspace level
- Services communicate through well-defined interfaces

#### Infrastructure Layer
Supporting services for data storage and APIs:
- Database migrations and schema management
- GraphQL API configuration
- Monitoring and observability tools

#### Shared Libraries
Common code used across multiple services:
- Domain models
- Utility functions
- Shared business logic

### Development Benefits
- **Faster builds**: Cargo caches dependencies and only rebuilds what changed
- **Type safety across services**: Shared types ensure compatibility
- **Easier refactoring**: Changes to shared code immediately show impact
- **Consistent testing**: Run all tests with a single command

## Project Structure

```
intuition-rs/
‚îú‚îÄ‚îÄ apps/                 # Custom Rust applications
‚îÇ   ‚îú‚îÄ‚îÄ cli/             # Terminal UI client
‚îÇ   ‚îú‚îÄ‚îÄ consumer/        # Event processing pipeline (Redis Streams)
‚îÇ   ‚îú‚îÄ‚îÄ histocrawler/    # Historical data crawler
‚îÇ   ‚îú‚îÄ‚îÄ image-guard/     # Image processing service
‚îÇ   ‚îú‚îÄ‚îÄ models/          # Domain models & data structures
‚îÇ   ‚îú‚îÄ‚îÄ rpc-proxy/       # RPC proxy with caching
‚îÇ   ‚îî‚îÄ‚îÄ shared-utils/    # Common utilities
‚îú‚îÄ‚îÄ infrastructure/      # Infrastructure components
‚îÇ   ‚îú‚îÄ‚îÄ hasura/         # GraphQL API & migrations
‚îÇ   ‚îú‚îÄ‚îÄ blockscout/     # Blockchain explorer
‚îÇ   ‚îú‚îÄ‚îÄ drizzle/        # Database schema management
‚îÇ   ‚îú‚îÄ‚îÄ geth/           # Local Ethereum node config
‚îÇ   ‚îú‚îÄ‚îÄ indexer-and-cache-migrations/  # Database migrations
‚îÇ   ‚îú‚îÄ‚îÄ migration-scripts/  # Migration utilities
‚îÇ   ‚îî‚îÄ‚îÄ prometheus/     # Monitoring configuration
‚îú‚îÄ‚îÄ docker/             # Docker configuration
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose-apps.yml   # Application services
‚îÇ   ‚îú‚îÄ‚îÄ docker-compose-shared.yml # Shared infrastructure
‚îÇ   ‚îî‚îÄ‚îÄ Dockerfile      # Multi-stage build
‚îú‚îÄ‚îÄ scripts/            # Shell scripts
‚îÇ   ‚îú‚îÄ‚îÄ start.sh        # System startup
‚îÇ   ‚îú‚îÄ‚îÄ stop.sh         # System shutdown
‚îÇ   ‚îú‚îÄ‚îÄ cli.sh          # CLI runner
‚îÇ   ‚îú‚îÄ‚îÄ init-dbs.sh     # Database initialization
‚îú‚îÄ‚îÄ integration-tests/  # End-to-end tests
‚îî‚îÄ‚îÄ README.md          # Project documentation
```

### Core Applications

<div className="uniform-card-grid">

<div className="uniform-card">
<h3 className="uniform-card-title">CLI</h3>
<div className="uniform-card-content">
Terminal UI client for interacting with the Intuition system
<ul>
<li>Interactive command-line interface</li>
<li>Real-time data verification</li>
<li>Development and debugging tool</li>
</ul>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Consumer</h3>
<div className="uniform-card-content">
Event processing pipeline using Redis Streams
<ul>
<li><strong>RAW Consumer</strong>: Ingests raw blockchain events</li>
<li><strong>DECODED Consumer</strong>: Decodes and parses events</li>
<li><strong>RESOLVER Consumer</strong>: Resolves and enriches data</li>
<li><strong>IPFS-UPLOAD Consumer</strong>: Manages IPFS content uploads</li>
</ul>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Histocrawler</h3>
<div className="uniform-card-content">
Historical data crawler for blockchain indexing
<ul>
<li>Fetches historical blockchain data</li>
<li>Processes past events</li>
<li>Builds complete data history</li>
</ul>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Image Guard</h3>
<div className="uniform-card-content">
Image processing and validation service
<ul>
<li>Image validation and security scanning</li>
<li>Format conversion and optimization</li>
<li>Content moderation</li>
</ul>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">RPC Proxy</h3>
<div className="uniform-card-content">
RPC call proxy with intelligent caching
<ul>
<li>Caches eth_call method results</li>
<li>Reduces load on upstream RPC providers</li>
<li>Improves query performance</li>
</ul>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Models</h3>
<div className="uniform-card-content">
Domain models and data structures
<ul>
<li>Shared data types</li>
<li>Business logic models</li>
<li>Database entity definitions</li>
</ul>
</div>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Shared Utils</h3>
<div className="uniform-card-content">
Common utilities used across services
<ul>
<li>Helper functions</li>
<li>Shared configurations</li>
<li>Reusable components</li>
</ul>
</div>
</div>

</div>

### Infrastructure Components

The infrastructure layer provides essential services:

- **Hasura**: GraphQL API engine with database migrations
- **Blockscout**: Blockchain explorer for network transparency
- **Drizzle**: Type-safe database schema management
- **Geth**: Local Ethereum node for development
- **Prometheus**: Metrics collection and monitoring

### Development Tools

The repository includes comprehensive tooling:

- **Docker Compose**: Orchestrates all services for local development
- **Cargo Make**: Task automation and build scripts
- **Integration Tests**: End-to-end testing with pnpm
- **Shell Scripts**: Quick commands for common operations

---

### File: docs/guides/network/index.md


<a href="https://intuition-testnet.hub.caldera.xyz/" target="_blank" rel="noopener noreferrer" className="hub-hero">
  <h1 className="hub-hero-title">
    Intuition Network
  </h1>
  <p className="hub-hero-description">
    Essential tools and applications for interacting with the Intuition ecosystem on the L3 network. From exploring the knowledge graph to bridging assets across networks.
  </p>
  <div className="hub-hero-button">
    Enter
  </div>
</a>

## What You'll Find Inside

Everything you need to build and test on Intuition's L3 network:

<div className="grid-3-cols">

<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '20px',
  padding: '2.5rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 4px 16px rgba(0, 0, 0, 0.08)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<div style={{
  width: '48px',
  height: '48px',
  borderRadius: '12px',
  backgroundColor: 'var(--ifm-color-primary)',
  color: 'white',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: '1.5rem',
  fontSize: '1.25rem',
  fontWeight: 'bold'
}}>üõ†Ô∏è</div>
<h3 style={{
  marginTop: 0,
  marginBottom: '1rem',
  color: 'var(--ifm-color-emphasis-900)',
  fontSize: '1.3rem',
  fontWeight: '600'
}}>
Build & Deploy
</h3>
<p style={{
  margin: 0,
  fontSize: '1rem',
  lineHeight: '1.6',
  color: 'var(--ifm-color-emphasis-700)',
  flexGrow: 1
}}>
Deploy smart contracts, test transactions, and monitor your applications in a safe environment.
</p>
</div>

<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '20px',
  padding: '2.5rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 4px 16px rgba(0, 0, 0, 0.08)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<div style={{
  width: '48px',
  height: '48px',
  borderRadius: '12px',
  backgroundColor: 'var(--ifm-color-primary)',
  color: 'white',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: '1.5rem',
  fontSize: '1.25rem',
  fontWeight: 'bold'
}}>üîó</div>
<h3 style={{
  marginTop: 0,
  marginBottom: '1rem',
  color: 'var(--ifm-color-emphasis-900)',
  fontSize: '1.3rem',
  fontWeight: '600'
}}>
Connect & Test
</h3>
<p style={{
  margin: 0,
  fontSize: '1rem',
  lineHeight: '1.6',
  color: 'var(--ifm-color-emphasis-700)',
  flexGrow: 1
}}>
Test APIs, validate SDK integrations, and explore the GraphQL playground with real data.
</p>
</div>

<div style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '20px',
  padding: '2.5rem',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 4px 16px rgba(0, 0, 0, 0.08)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  transition: 'all 0.3s ease',
  cursor: 'pointer'
}}>
<div style={{
  width: '48px',
  height: '48px',
  borderRadius: '12px',
  backgroundColor: 'var(--ifm-color-primary)',
  color: 'white',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  marginBottom: '1.5rem',
  fontSize: '1.25rem',
  fontWeight: 'bold'
}}>‚ö°</div>
<h3 style={{
  marginTop: 0,
  marginBottom: '1rem',
  color: 'var(--ifm-color-emphasis-900)',
  fontSize: '1.3rem',
  fontWeight: '600'
}}>
Monitor & Optimize
</h3>
<p style={{
  margin: 0,
  fontSize: '1rem',
  lineHeight: '1.6',
  color: 'var(--ifm-color-emphasis-700)',
  flexGrow: 1
}}>
Track performance, monitor network health, and get test tokens to fuel your development.
</p>
</div>

</div>

## Getting Started

Ready to start building on Intuition? Follow these steps:

<div className="getting-started-grid">

<a href="/docs/resources/faq#how-do-i-connect-to-the-intuition-testnet" style={{
  textDecoration: 'none',
  color: 'inherit',
  display: 'block',
  transition: 'all 0.3s ease'
}}>

<div style={{
  padding: '2rem',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  textAlign: 'center',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'flex-start',
  cursor: 'pointer'
}}>
<div style={{
  width: '60px',
  height: '60px',
  borderRadius: '50%',
  backgroundColor: 'var(--ifm-color-emphasis-200)',
  color: '#000000',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  margin: '0 auto 1.5rem auto',
  fontSize: '1.5rem',
  fontWeight: 'bold',
  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
}}>1</div>
<h4 style={{ marginBottom: '1rem', fontSize: '1.1rem', fontWeight: '600' }}>Connect Your Wallet</h4>
<p style={{ margin: 0, fontSize: '0.95rem', color: 'var(--ifm-color-emphasis-600)', lineHeight: '1.6', marginBottom: '1rem' }}>
Use MetaMask or any Web3 wallet to connect to the testnet
</p>

</div>
</a>

<a href="https://intuition-testnet.hub.caldera.xyz/" target="\_blank" rel="noopener noreferrer" style={{
  textDecoration: 'none',
  color: 'inherit',
  display: 'block',
  transition: 'all 0.3s ease'
}}>

<div style={{
  padding: '2rem',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  textAlign: 'center',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'flex-start',
  cursor: 'pointer'
}}>
<div style={{
  width: '60px',
  height: '60px',
  borderRadius: '50%',
  backgroundColor: 'var(--ifm-color-emphasis-200)',
  color: '#000000',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  margin: '0 auto 1.5rem auto',
  fontSize: '1.5rem',
  fontWeight: 'bold',
  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
}}>2</div>
<h4 style={{ marginBottom: '1rem', fontSize: '1.1rem', fontWeight: '600' }}>Get Test Tokens</h4>
<p style={{ margin: 0, fontSize: '0.95rem', color: 'var(--ifm-color-emphasis-600)', lineHeight: '1.6', marginBottom: '1rem' }}>
Use the built-in faucet to obtain test tokens for transactions
</p>

</div>
</a>

<a href="/docs/network/testnet/explorer" style={{
  textDecoration: 'none',
  color: 'inherit',
  display: 'block',
  transition: 'all 0.3s ease'
}}>

<div style={{
  padding: '2rem',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  textAlign: 'center',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'flex-start',
  cursor: 'pointer'
}}>
<div style={{
  width: '60px',
  height: '60px',
  borderRadius: '50%',
  backgroundColor: 'var(--ifm-color-emphasis-200)',
  color: '#000000',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  margin: '0 auto 1.5rem auto',
  fontSize: '1.5rem',
  fontWeight: 'bold',
  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
}}>3</div>
<h4 style={{ marginBottom: '1rem', fontSize: '1.1rem', fontWeight: '600' }}>Explore Services</h4>
<p style={{ margin: 0, fontSize: '0.95rem', color: 'var(--ifm-color-emphasis-600)', lineHeight: '1.6', marginBottom: '1rem' }}>
Access all testnet tools and services from the centralized dashboard
</p>

</div>
</a>

<a href="/docs/developer-tools" style={{
  textDecoration: 'none',
  color: 'inherit',
  display: 'block',
  transition: 'all 0.3s ease'
}}>

<div style={{
  padding: '2rem',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '16px',
  textAlign: 'center',
  backgroundColor: 'var(--ifm-background-color)',
  boxShadow: '0 2px 8px rgba(0, 0, 0, 0.04)',
  height: '100%',
  display: 'flex',
  flexDirection: 'column',
  justifyContent: 'flex-start',
  cursor: 'pointer'
}}>
<div style={{
  width: '60px',
  height: '60px',
  borderRadius: '50%',
  backgroundColor: 'var(--ifm-color-emphasis-200)',
  color: '#000000',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  margin: '0 auto 1.5rem auto',
  fontSize: '1.5rem',
  fontWeight: 'bold',
  boxShadow: '0 4px 12px rgba(0, 0, 0, 0.15)'
}}>4</div>
<h4 style={{ marginBottom: '1rem', fontSize: '1.1rem', fontWeight: '600' }}>Start Building</h4>
<p style={{ margin: 0, fontSize: '0.95rem', color: 'var(--ifm-color-emphasis-600)', lineHeight: '1.6', marginBottom: '1rem' }}>
Deploy your first smart contract or create your first atom
</p>

</div>
</a>

</div>

## Network Details

<div className="network-details-container">

<table className="network-details-table">
<thead>
<tr>
<th>Parameter</th>
<th>Value</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Chain ID</strong></td>
<td>13579</td>
<td>Unique identifier for the Intuition testnet</td>
</tr>
<tr>
<td><strong>Native Token</strong></td>
<td>$TTRUST</td>
<td>Native token for transactions and gas fees</td>
</tr>
<tr>
<td><strong>Settlement Layer</strong></td>
<td>Base Sepolia</td>
<td>Layer 1 settlement and data availability</td>
</tr>
<tr>
<td><strong>Data Availability</strong></td>
<td>Arbitrum AnyTrust</td>
<td>Data availability and security layer</td>
</tr>
<tr>
<td><strong>Rollup Stack</strong></td>
<td>Arbitrum Nitro</td>
<td>Optimistic rollup technology stack</td>
</tr>
<tr>
<td><strong>RPC (HTTP)</strong></td>
<td colspan="2"><code className="rpc-endpoint">https://testnet.rpc.intuition.systems/http</code></td>
</tr>
<tr>
<td><strong>RPC (WebSocket)</strong></td>
<td colspan="2"><code className="rpc-endpoint">wss://testnet.rpc.intuition.systems/ws</code></td>
</tr>
</tbody>
</table>

</div>

## Key Features

<div className="key-features-grid">

<div className="key-feature-card">
<h3 className="key-feature-title">Centralized Dashboard</h3>
<p className="key-feature-description">
All testnet services are accessible from a single, intuitive interface that provides:
</p>
<ul className="green-checklist">
<li>Service status monitoring</li>
<li>Quick navigation to tools</li>
<li>Real-time network metrics</li>
<li>Developer notifications</li>
</ul>
</div>

<div className="key-feature-card">
<h3 className="key-feature-title">Seamless Integration</h3>
<p className="key-feature-description">
The hub integrates with all Intuition testnet services:
</p>
<ul className="green-checklist">
<li><a href="/docs/network/testnet/bridge">Bridge</a> for cross-chain transfers</li>
<li><a href="/docs/network/testnet/explorer">Explorer</a> for blockchain exploration</li>
<li><a href="/docs/resources/network-health">Network Status</a> for service monitoring</li>
</ul>
</div>

<div className="key-feature-card">
<h3 className="key-feature-title">Developer-Friendly</h3>
<p className="key-feature-description">
Built with developers in mind:
</p>
<ul className="green-checklist">
<li>Clear documentation links</li>
<li>Code examples and snippets</li>
<li>Testing best practices</li>
<li>Troubleshooting guides</li>
</ul>
</div>

</div>

## Core Applications

<div style={{
  display: 'flex',
  flexDirection: 'column',
  gap: '1.5rem',
  marginTop: '2rem',
  marginBottom: '3rem'
}}>

<a href="https://intuition-testnet.hub.caldera.xyz/" target="_blank" rel="noopener noreferrer" className="core-app-card clickable-card">
<div className="core-app-icon">
<svg width="32" height="32" viewBox="0 0 24 24" fill="white">
<path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"/>
</svg>
</div>
<div className="core-app-content">
<h3 className="core-app-title">Hub</h3>
<p className="core-app-description">
Development environment hub for the Intuition testnet. Access all testnet services, tools, and resources in one centralized location.
</p>
<div className="core-app-tags">
<span className="core-app-tag">Testnet</span>
<span className="core-app-tag">Development</span>
<span className="core-app-tag">Testing</span>
</div>
</div>
</a>

<a href="/docs/network/testnet/bridge" className="core-app-card clickable-card">
<div className="core-app-icon">
<svg width="32" height="32" viewBox="0 0 24 24" fill="white">
<path d="M6 6v2h8.59L5 17.59 6.41 19 16 9.41V18h2V6z"/>
</svg>
</div>
<div className="core-app-content">
<h3 className="core-app-title">Bridge</h3>
<p className="core-app-description">
Bridge assets between Ethereum testnets and Intuition testnet. Secure cross-chain transfers for testing and development purposes.
</p>
<div className="core-app-tags">
<span className="core-app-tag">Bridge</span>
<span className="core-app-tag">Cross-chain</span>
<span className="core-app-tag">Testing</span>
</div>
</div>
</a>

<a href="/docs/resources/network-health" className="core-app-card clickable-card">
<div className="core-app-icon">
<svg width="32" height="32" viewBox="0 0 24 24" fill="white">
<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
</svg>
</div>
<div className="core-app-content">
<h3 className="core-app-title">Network Status</h3>
<p className="core-app-description">
Real-time status monitoring for the Intuition network. Check service availability, network health, and uptime statistics.
</p>
<div className="core-app-tags">
<span className="core-app-tag">Status</span>
<span className="core-app-tag">Monitoring</span>
<span className="core-app-tag">Uptime</span>
</div>
</div>
</a>

<a href="/docs/network/testnet/portal" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', alignItems: 'center', marginBottom: '1rem' }}>
<div style={{ width: '40px', height: '40px', borderRadius: '8px', backgroundColor: '#6366F1', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '1rem' }}>
<svg width="20" height="20" viewBox="0 0 24 24" fill="white">
<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
</svg>
</div>
<h3 style={{ margin: 0 }}>Portal</h3>
</div>
<p className="uniform-card-content">
The main interface for creating identities, making claims, and staking on the Intuition knowledge graph. Your gateway to the decentralized social network. Perfect for new users - start here to create your first identity and make claims.
</p>
</div>
</a>

<a href="/docs/network/testnet/explorer" className="core-app-card clickable-card">
<div className="core-app-icon">
<svg width="32" height="32" viewBox="0 0 24 24" fill="white">
<path d="M9.5 3A6.5 6.5 0 0116 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 019.5 16 6.5 6.5 0 013 9.5 6.5 6.5 0 019.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/>
</svg>
</div>
<div className="core-app-content">
<h3 className="core-app-title">Explorer</h3>
<p className="core-app-description">
Blockchain explorer for the Intuition testnet. View transactions, blocks, and network activity. Monitor testnet performance and verify test transactions.
</p>
<div className="core-app-tags">
<span className="core-app-tag">Explorer</span>
<span className="core-app-tag">Transactions</span>
<span className="core-app-tag">Analytics</span>
</div>
</div>
</a>

<a href="/docs/network/testnet/rpc" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', alignItems: 'center', marginBottom: '1rem' }}>
<div style={{ width: '40px', height: '40px', borderRadius: '8px', backgroundColor: '#EF4444', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '1rem' }}>
<svg width="20" height="20" viewBox="0 0 24 24" fill="white">
<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
</svg>
</div>
<h3 style={{ margin: 0 }}>RPC</h3>
</div>
<p className="uniform-card-content">
Programmatic access to the Intuition network. Query blockchain data, submit transactions, and interact with smart contracts. Ideal for developers - use for programmatic access to the network.
</p>
</div>
</a>

</div>

## Support

Need help with any of these tools? Check out our [Community & Support](/docs/resources/community-and-support) page or [FAQ](/docs/resources/faq) for answers to common questions.

---

### File: docs/guides/network/mainnet/index.md


# Intuition Mainnet

:::info Coming Soon
The Intuition Mainnet is currently under development. Please use the [Testnet](/guides/network/testnet) for development and testing.
:::

## Stay Updated

Follow our progress and get notified when mainnet launches:

- [Twitter/X](https://x.com/0xintuition)
- [Discord](https://discord.gg/RgBenkX4mx)
- [GitHub](https://github.com/0xIntuition)

## Prepare for Mainnet

While you wait for mainnet, you can:

1. **Build on Testnet** - Develop and test your applications on our [testnet environment](/guides/network/testnet)
2. **Learn the Protocol** - Explore our [documentation](/guides) to understand the Intuition protocol
3. **Join the Community** - Connect with other developers in our [Discord](https://discord.gg/0xintuition)

---

### File: docs/guides/network/testnet/bridge.md


# Bridge

<div className="bridge-intro">
Secure cross-chain transfers between Ethereum testnets and the Intuition testnet. Built for testing and development, move assets safely between networks during the development process.
</div>

<div className="bridge-access-card">
<div className="bridge-access-content">
<h3>Access Bridge</h3>
<p>Start bridging assets between networks</p>
<a href="https://intuition-testnet.hub.caldera.xyz/" target="_blank" rel="noopener noreferrer" className="bridge-access-button">
Open Bridge ‚Üí
</a>
</div>
</div>

## Powered by Caldera's Metalayer

Intuition leverages **Caldera's Metalayer** infrastructure to provide seamless cross-chain bridging capabilities. As part of Caldera's **Internet of Chains**, we benefit from a robust, interconnected ecosystem of blockchain networks.

### What is Caldera's Metalayer?

The Metalayer is Caldera's innovative cross-chain infrastructure that enables:

- **Unified Bridging**: A single interface for transferring assets across multiple chains in the Caldera ecosystem
- **Shared Security**: Leveraging collective security models across interconnected chains
- **Interoperability**: Native communication between different blockchain networks without complex integrations
- **Simplified UX**: One-click bridging experiences that abstract away technical complexity

### The Internet of Chains

Caldera's Internet of Chains represents a new paradigm in blockchain connectivity:

- **Network Effects**: Each new chain added to the ecosystem increases the value for all participants
- **Composability**: Applications can seamlessly interact across different chains without friction
- **Shared Liquidity**: Assets can flow freely between chains, improving capital efficiency
- **Unified Standards**: Common protocols and standards across all connected chains

### Benefits for Intuition Users

By being part of this ecosystem, Intuition users gain:

- **Access to Multiple Networks**: Bridge assets from any chain in the Caldera network
- **Lower Costs**: Shared infrastructure reduces operational costs
- **Enhanced Security**: Battle-tested bridge infrastructure used by multiple production networks
- **Future Connectivity**: Automatic access to new chains as they join the ecosystem

### How It Works

The Metalayer uses advanced cryptographic techniques and consensus mechanisms to ensure:

1. **Asset Security**: Multi-signature validation and fraud proofs protect bridged assets
2. **Fast Finality**: Optimized confirmation times for cross-chain transfers
3. **Reliability**: Redundant infrastructure ensures high availability
4. **Transparency**: All bridge operations are verifiable on-chain

### Learn More

- [Caldera Documentation](https://docs.caldera.xyz)
- [Internet of Chains Overview](https://caldera.xyz/internet-of-chains)
- [Bridge Technical Specifications](https://docs.caldera.xyz/metalayer) 

---

### File: docs/guides/network/testnet/data-populator.mdx


# Data Populator

The **Intuition Data Populator** is a specialized tool designed to help users and developers efficiently populate the Intuition knowledge graph with high-quality, structured data. This application streamlines the process of creating atoms, triples, and establishing meaningful relationships within the decentralized knowledge network.

## Why did we create the Data Populator?

Do you have a large amount of data you want to add to the Intuition System, but not enough time or patience to manually create each data point as an atom or triple in the Portal? Look no further! The Data Populator V1 is here!

## What it does, in brief

You can use the Data Populator to load CSV files which contain long lists of atom data. The user interface will allow you to perform some basic proofreading of the data, and when you're ready you can submit it to the Intuition System in one fell swoop. This works by batching all of the atom data together into very large EVM transactions, after automatically pinning and filtering the metadata onto IPFS. This is very similar to the behavior in the Portal App, except it's designed to work with much larger volumes of data.

## Where you can access it

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-100)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '2rem 0',
  borderLeft: '4px solid var(--ifm-color-primary)'
}}>

There are two deployments for the Data Populator - one for testing, which runs on Base Sepolia, and one for production which runs on Base.

- **Testnet Data Populator**: [https://data-populator-dev.onrender.com](https://data-populator-dev.onrender.com)
- **Mainnet Data Populator**: [https://upload.intuition.systems](https://upload.intuition.systems)

It's strongly recommended, especially for first time users, to start off with the **Testnet** version to verify everything looks good with your data before spending real Base Ethereum on populating it.

</div>

## Overview

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-100)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '2rem 0',
  borderLeft: '4px solid var(--ifm-color-primary)'
}}>

The Data Populator serves as a bridge between traditional data sources and the Intuition ecosystem, enabling users to:

- **Bulk import data** - Efficiently create multiple atoms and triples from structured datasets
- **Validate data quality** - Ensure imported data meets Intuition's standards and requirements
- **Establish relationships** - Create meaningful connections between imported entities
- **Maintain data integrity** - Preserve the semantic structure and provenance of imported information

</div>

## Key Features

<div style={{ 
  display: 'grid', 
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', 
  gap: '1.5rem', 
  margin: '2rem 0'
}}>

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem'
}}>

### üîÑ **Bulk Data Import**
- Import large datasets in various formats (CSV, JSON, XML)
- Automated atom and triple creation from structured data
- Batch processing for efficient handling of large datasets
- Progress tracking and error reporting

</div>

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem'
}}>

### ‚úÖ **Data Validation**
- Automatic validation of data structure and format
- Quality checks for imported atoms and triples
- Duplicate detection and resolution
- Semantic consistency verification

</div>

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem'
}}>

### üîó **Relationship Mapping**
- Automatic creation of triples based on imported relationships
- Support for complex relationship structures
- Mapping of traditional data schemas to Intuition's semantic model
- Preservation of data provenance and metadata

</div>

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem'
}}>

### üéØ **Quality Assurance**
- Data quality scoring and reporting
- Conflict resolution for conflicting claims
- Automated tagging and categorization
- Integration with Intuition's trust mechanisms

</div>

</div>

## Use Cases

<div style={{ 
  display: 'grid', 
  gridTemplateColumns: 'repeat(3, 1fr)', 
  gap: '1.5rem', 
  margin: '2rem 0'
}}>

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem'
}}>

### üéì **Academic Research**
- Import research datasets and establish connections between findings
- Create atoms for research entities, methodologies, and conclusions
- Build knowledge graphs for specific research domains
- Enable collaborative research through shared knowledge structures

</div>

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem'
}}>

### üíº **Business Intelligence**
- Import organizational data and establish entity relationships
- Create comprehensive knowledge graphs for business domains
- Enable data-driven decision making through structured insights
- Facilitate cross-organizational knowledge sharing

</div>

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem'
}}>

### üìö **Content Curation**
- Import content from various sources and establish semantic relationships
- Create comprehensive knowledge graphs for specific domains
- Enable content discovery and recommendation systems
- Build curated collections of related information

</div>

</div>

## Instruction Guide

### Authentication

The first thing you will need to do, if you haven't already, is authenticate and log into the system. If you are not authenticated yet, you will be shown a **Connect** button. Click the connect button and authorize using your method of choice. Follow the prompts shown on screen to complete the log-in process.

### User Interface Overview

After logging in, you'll see the main interface with:

- **Top menu bar**: Contains a helpful tooltip toggle button and a history button
- **Version indicator**: Shows which version of the Data Populator app you're using (TESTNET or MAINNET)
- **Four main tabs**: Select Atom Type, Load CSV, Publish Atoms, and Tag Atoms

### Select Atom Type

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

As of right now, you have 3 options here. Most users can stick with the default value of **Schema.org &lt;Thing&gt;** to create and tag basic metadata atoms. If you want to populate **CAIP-10** atoms or **Raw URI** atoms, you can select either option from the drop-down before pressing **Continue**.

#### **Schema.org &lt;Thing&gt;**

We currently support 1 type from schema.org, the **&lt;Thing&gt;**. Most of the atoms in the Intuition Portal are **&lt;Thing&gt;**s. The **&lt;Thing&gt;** has 6 fields:

| Field | Description |
|-------|-------------|
| @context | This will always be [https://schema.org](https://schema.org/) - it's used to identify where the metadata type is defined |
| @type | This will always be **&lt;Thing&gt;** - it's used to determine which metadata type is being used |
| name | This is the name of your atom. This could be the name of an article, person, place, or thing |
| description | A description of your atom. This is a more in-depth blob of text which helps people understand the thing being referenced |
| image | A URL pointing to an image for your atom. This might point to a logo, a twitter avatar, or anything which visually demonstrates the thing being referenced |
| url | A URL pointing to a website for your atom. This could be a social media profile, the website for a business, an article, or anything else on the web |

#### **CAIP-10**

A `CAIP-10` is a string of text which is used to reference smart contracts. `CAIP-10` atoms comprise of only one variable, the `CAIP-10` itself. The `CAIP-10` identifier is comprised of 4 `:` delimited values:

`CAIP10` `:` `[NAMESPACE]` `:` `[CHAIN_ID]` `:` `[ADDRESS]`

**Examples:**
```
# Ethereum mainnet (canonicalized with EIP-55 checksum)
CAIP10:eip155:1:0xab16a96D359eC26a11e2C2b3d8f8B8942d5Bfcdb

# Bitcoin mainnet
CAIP10:bip122:000000000019d6689c085ae165831e93:128Lkh3S7CkDTBZ8W7BbpsN3YYizJMp8p6

# Cosmos Hub
CAIP10:cosmos:cosmoshub-3:cosmos1t2uflqwqe0fsj0shcfkrvpukewcw40yjj6hdc0
```

You can read more about the `CAIP-10` standard here: [https://chainagnostic.org/CAIPs/caip-10](https://chainagnostic.org/CAIPs/caip-10)

#### **Raw URI**

The `Intuition System` also uses `Raw URI`s. These cannot be proofread, and are for advanced users only. One example use case for these is the [https://schema.org/keywords](https://schema.org/keywords) `Raw URI`. The `Intuition Portal` uses this as a `Predicate` in `Semantic Triples` in order to denote that something has a `Tag Keyword`.

</div>

### Load CSV

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

The `Load CSV` box allows you to load a `.csv` file from your PC which contains numerous `Atom`s. 

#### **Schema.org &lt;Thing&gt; CSV Example:**

```csv
@context,@type,name,url,description,image
https://schema.org,Thing,Google,https://www.google.com,"A website where you can search for stuff.",https://google.com/google_logo.jpg
https://schema.org,Thing,Facebook,https://www.facebook.com,"A social media website.",https://facebook.com/facebook_logo.jpg
```

#### **CAIP-10 CSV Example:**

```csv
CAIP10
eip155:1:0x1234567890abcdef1234567890aBcdef12345678
eip155:1:0x1234567890abcfeF1234567890aBCDEf12345675
eip155:1:0x1234567890aBcdeF1234567890AbcDef12345672
```

**Important Notes:**
- The column order, capitalization, and naming is crucial - ensure it matches the specification before exporting
- If there's anything weird going on with your `.csv` file, the Data Populator will show you a `Proofreading` window which flags any unusual characters or errors
- The application will attempt to fix any errors on its own, and can automatically checksum Ethereum addresses

</div>

### Publish Atoms

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

The `Publish Atoms` tab shows you some basic information about the `Atoms` you have loaded. Once you've reviewed them, you can select them and `publish` them using the `Publish Selected Atoms` button.

**Publishing Process:**
1. Select atoms using the checkbox on the left of their rows
2. Press `Publish Selected Atoms`
3. Confirm the transaction in the dialog
4. Approve the EVM transaction in your wallet
5. Wait for confirmation and see green "Atom Already Exists" icons

</div>

### Atoms View

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

The `Atoms View` appears below all four tabs in the application, and displays the `Atoms` you currently have loaded. It has several features:

- **Edit and Preview**: Cells can be selected and freely edited
- **Sort Data**: Click on any column header to sort the data
- **Duplicate Detection**: Identify partial duplicates before publishing
- **Delete Rows**: Select unwanted rows and press `Delete Row`
- **Save CSV**: Save a new copy to your PC after making edits
- **Add New Row**: Manually enter atom data directly into the Data Populator

</div>

### Tag Atoms

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

If you want to add your newly published `Atoms` to a `List`, you can use the `Tag Atoms` feature:

1. **Create the Tag**: Fill out the tag metadata fields and press `Create Tag`
2. **Publish Tag**: The tag will be published as another `Atom` in the system
3. **Tag Selected Atoms**: Once the tag exists, press `Tag Selected Atoms` to associate your atoms with it

**Important**: Be precise while entering metadata. Each `Atom's` uniqueness is determined by the exact contents of its data.

</div>

### History Window

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

If you press the `View Your History` button near the top-right corner of the screen, a new window will appear showing:

- History of all the `Atoms`, `Triples` (`Tags`), and `Requests` that you've submitted
- Ability to `Save` `.csv` files that you've previously submitted
- Helpful when working on multiple machines or collaborating with others

</div>

## Getting Started

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-100)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '2rem 0',
  borderLeft: '4px solid var(--ifm-color-primary)'
}}>

### **Prerequisites**
- Access to the Intuition network
- Structured data in supported formats
- Understanding of Intuition's atom and triple concepts
- Familiarity with the data you want to import

### **Installation**
The Data Populator is available as a web application and can be accessed through the Intuition ecosystem.

</div>

### **Basic Workflow**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

1. **Prepare your data** - Ensure your data is in a supported format and properly structured
2. **Validate data** - Use the built-in validation tools to check data quality
3. **Map relationships** - Define how your data relationships should be represented as triples
4. **Import data** - Execute the import process with appropriate settings
5. **Review results** - Check the imported atoms and triples for accuracy
6. **Iterate** - Refine your import process based on results

</div>

## Data Formats

<div style={{ 
  display: 'grid', 
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))', 
  gap: '1.5rem', 
  margin: '2rem 0'
}}>

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem'
}}>

### üìÑ **Supported Formats**
- **CSV** - Comma-separated values with headers
- **JSON** - Structured JSON objects and arrays
- **XML** - Extensible Markup Language documents
- **Excel** - Microsoft Excel spreadsheets

</div>

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem'
}}>

### üìã **Data Structure Requirements**
- Clear entity identification
- Relationship definitions
- Metadata and provenance information
- Quality indicators and confidence scores

</div>

</div>

## Best Practices

### Data Preparation
- Clean and normalize your data before import
- Ensure consistent naming conventions
- Validate data quality and completeness
- Document data sources and transformation processes

### Relationship Mapping
- Clearly define how traditional relationships map to triples
- Consider the semantic meaning of relationships
- Plan for relationship validation and verification
- Account for relationship confidence and uncertainty

### Quality Control
- Implement comprehensive validation checks
- Monitor import success rates and error patterns
- Establish feedback loops for continuous improvement
- Maintain data provenance and audit trails

## Integration

### With Intuition Portal
- Imported data appears in the Portal for user interaction
- Users can stake on imported atoms and triples
- Integration with Portal's tagging and list features
- Support for Portal's social features and user interactions

### With Developer Tools
- Programmatic access to imported data through APIs
- Integration with custom applications and workflows
- Support for automated data processing and analysis
- Compatibility with Intuition's developer ecosystem

## Advanced Features

### Custom Mappings
- Define custom mapping rules for complex data structures
- Support for domain-specific ontologies and schemas
- Flexible relationship mapping and transformation
- Integration with external data sources and APIs

### Automated Processing
- Scheduled data imports and updates
- Real-time data synchronization
- Automated quality monitoring and reporting
- Integration with external data pipelines

### Analytics and Reporting
- Import statistics and success rates
- Data quality metrics and trends
- Usage analytics and impact assessment
- Performance monitoring and optimization

## Development

The Data Populator is part of the Intuition ecosystem and follows the same development principles:

- **Open source** - Available for community contribution and improvement
- **Modular design** - Flexible architecture for custom extensions
- **API-first** - Programmatic access for integration with other tools
- **Community-driven** - Development guided by user needs and feedback

## Getting Help

For support with the Data Populator:

- Check the [Intuition documentation](/guides) for detailed guides
- Visit the [GitHub repository](https://github.com/0xIntuition) for technical details
- Join the [community discussions](https://discord.gg/intuition) for user support
- Review the [API documentation](/guides/developer-tools) for integration help

## Getting Started

<div style={{ 
  backgroundColor: 'var(--ifm-color-primary-lightest)', 
  border: '1px solid var(--ifm-color-primary-light)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '2rem 0',
  textAlign: 'center'
}}>

### üöÄ **Ready to populate your data?**

<div style={{ 
  display: 'grid', 
  gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', 
  gap: '1rem', 
  marginTop: '1rem'
}}>

<div style={{ 
  border: '1px solid var(--ifm-color-primary-light)', 
  borderRadius: '6px', 
  padding: '1rem', 
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[Testnet Data Populator](https://data-populator-dev.onrender.com)** - Start here for testing

</div>

<div style={{ 
  border: '1px solid var(--ifm-color-primary-light)', 
  borderRadius: '6px', 
  padding: '1rem', 
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[Mainnet Data Populator](https://upload.intuition.systems)** - Production environment

</div>

</div>

</div>

## Related Resources

<div style={{ 
  display: 'grid', 
  gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', 
  gap: '1rem', 
  marginTop: '2rem'
}}>

<div style={{ 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '6px', 
  padding: '1rem', 
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[Portal](/guides/network/testnet/portal)** - Main interface for interacting with the knowledge graph

</div>

<div style={{ 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '6px', 
  padding: '1rem', 
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[Explorer](/guides/network/testnet/explorer)** - Network exploration and transaction monitoring

</div>

<div style={{ 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '6px', 
  padding: '1rem', 
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[Developer Tools](/guides/developer-tools)** - Programmatic access and integration

</div>

<div style={{ 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '6px', 
  padding: '1rem', 
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[API Documentation](/guides/developer-tools/graphql-api)** - Technical integration guides

</div>

</div> 

---

### File: docs/guides/network/testnet/explorer.md


# Explorer

The Intuition Explorer is a comprehensive blockchain explorer built on Blockscout, providing detailed insights into all network activity on the Intuition testnet. Monitor transactions, explore blocks, and analyze network performance with this powerful exploration tool.

## Quick Access

Access the Explorer directly at: [https://intuition-testnet.hub.caldera.xyz/](https://intuition-testnet.hub.caldera.xyz/)

## Overview

The Explorer serves as your window into the Intuition testnet blockchain, offering:

- Real-time transaction monitoring
- Block exploration and analysis
- Smart contract verification
- Network statistics and metrics
- Token tracking and transfers

## Key Features

### **Transaction Monitoring**
- View all network transactions in real-time
- Search transactions by hash, address, or block
- Monitor transaction status and confirmations
- Analyze gas usage and fees
- Track internal transactions and contract calls

### **Block Exploration**
- Browse the latest blocks
- View block details and included transactions
- Monitor network utilization
- Track block production times
- Analyze block rewards and fees

### **Smart Contract Features**
- Verify and publish smart contract source code
- Read contract state and interact with functions
- View contract creation and deployment history
- Monitor contract events and logs
- Track contract token transfers

### **Network Analytics**
- Real-time network statistics
- Gas price tracking and recommendations
- Network utilization metrics
- Transaction volume analysis
- Active address monitoring

## Navigation Guide

### **Homepage Dashboard**
The explorer homepage provides:
- Latest blocks and transactions
- Network utilization status
- Gas tracker with current prices
- Key network statistics
- Quick search functionality

### **Transaction Details**
Each transaction page shows:
- Transaction hash and status
- Block number and position
- Gas used and gas price
- Input data and logs
- Token transfers (if applicable)

### **Block Information**
Block pages display:
- Block hash and parent hash
- Block height and timestamp
- Transaction count and gas used
- Miner/validator information
- Block rewards and fees

### **Address Pages**
Address exploration includes:
- Balance and transaction history
- Token holdings and transfers
- Contract code (if applicable)
- Internal transactions
- Analytics and statistics

## Search Functionality

### **Supported Searches**
- Transaction hashes
- Block numbers or hashes
- Wallet addresses
- Contract addresses
- Token contract addresses

### **Advanced Filters**
- Filter transactions by type
- Sort by timestamp, value, or gas
- Filter by token transfers
- Search within specific time ranges

## API Access

### **REST API**
The explorer provides REST API access for:
- Transaction data retrieval
- Block information queries
- Address balance checks
- Contract interaction history
- Network statistics

### **GraphQL API**
Advanced querying capabilities through GraphQL:
- Complex data relationships
- Batch queries
- Real-time subscriptions
- Custom data aggregations

### **RPC Endpoints**
Standard Ethereum RPC methods:
- `eth_getBalance`
- `eth_getTransactionByHash`
- `eth_getBlockByNumber`
- Custom Intuition-specific methods

## Monitoring Network Health

### **Network Status Indicators**
- Green: All systems operational
- Yellow: Some delays or issues
- Red: Network problems detected

### **Performance Metrics**
Track important network health indicators:
- Average block time
- Transaction throughput
- Gas price trends
- Network congestion levels

### **Gas Tracker**
Monitor gas prices for optimal transaction timing:
- Current gas prices
- Historical gas trends
- Gas price recommendations
- Network congestion impact

## Developer Tools

### **Contract Verification**
Submit your smart contracts for verification:
1. Navigate to "Verify contract" section
2. Upload source code and compilation details
3. Provide constructor arguments
4. Submit for verification
5. View verified contract on explorer

### **API Integration**
Integrate explorer data into your applications:
- Real-time transaction monitoring
- Address balance tracking
- Contract event listening
- Network analytics integration

### **Testing and Debugging**
Use the explorer for development:
- Verify transaction execution
- Debug failed transactions
- Monitor contract interactions
- Track token transfers

## Common Use Cases

### **Transaction Verification**
- Confirm transaction completion
- Check transaction details and status
- Verify gas usage and fees
- Review transaction logs and events

### **Contract Monitoring**
- Track smart contract interactions
- Monitor contract state changes
- Verify contract deployments
- Debug contract execution

### **Network Analysis**
- Study network performance trends
- Analyze transaction patterns
- Monitor network congestion
- Track validator performance

## Integration with Other Tools

### **Bridge**
- View bridge transactions
- Track cross-chain transfers
- Monitor bridge contract interactions
- Verify asset movements

### **Hub**
- Quick access from hub dashboard
- Integrated transaction links
- Real-time status updates
- Development workflow integration

### **Developer Tools**
- SDK transaction verification
- API testing and validation
- Smart contract debugging
- Performance optimization

## Support and Resources

### **Getting Help**
- [Community & Support](/guides/resources/community-and-support) for explorer questions
- [FAQ](/guides/resources/faq) for common issues
- [Developer Tools](/guides/developer-tools) for technical integration

### **Additional Resources**
- Blockscout documentation
- API reference guides
- Integration examples
- Best practices for monitoring

## Next Steps

- Monitor your transactions and contracts
- Integrate explorer APIs into your applications
- Use with [Bridge](/guides/network/testnet/bridge) for cross-chain verification
- Check [Network Health](/guides/resources/network-health) for service health 

---

### File: docs/guides/network/testnet/farcaster-frames.mdx


# Farcaster Frames

The **Intuition Farcaster Frames** integration brings the power of Intuition's knowledge graph directly into the Farcaster social network. This integration enables users to create, verify, and interact with Intuition atoms and triples through interactive frames embedded in Farcaster posts, creating a seamless bridge between social media and decentralized knowledge.

## Overview

Farcaster Frames provide an interactive way for users to engage with Intuition's knowledge graph without leaving the Farcaster platform. Users can:

- **Create identities** - Generate Intuition atoms directly from Farcaster posts
- **Make claims** - Create triples and assertions through interactive frames
- **Stake on content** - Participate in the Token Curated Registry via frame interactions
- **Verify information** - Check the authenticity of claims and identities
- **Build reputation** - Establish credibility through social interactions

## Key Features

### Interactive Identity Creation

- Create Intuition atoms through simple frame interactions
- Add metadata and descriptions to identities
- Link Farcaster profiles to Intuition identities
- Build reputation through social validation

### Claim Verification

- Verify claims and assertions through frame interactions
- Stake on claims to express agreement or disagreement
- View community sentiment and staking activity
- Access detailed claim analytics and provenance

### Social Integration

- Seamless integration with Farcaster's social features
- Cross-platform identity and reputation building
- Social proof through community interactions
- Viral content discovery and sharing

### Trust Network Building

- Connect Farcaster users through Intuition's trust network
- Build reputation through social interactions
- Access personalized recommendations based on your network
- Establish credibility through community validation

## How It Works

### Frame Structure

Farcaster Frames are interactive HTML elements embedded in Farcaster posts that enable users to:

1. **View Information** - Display Intuition data and claims
2. **Take Actions** - Create atoms, make claims, or stake on content
3. **Get Results** - Receive confirmation and view outcomes
4. **Share Results** - Post outcomes back to Farcaster

### Integration Flow

1. **Frame Creation** - Developers create frames with Intuition functionality
2. **User Interaction** - Users interact with frames in Farcaster posts
3. **Blockchain Action** - Frame triggers Intuition blockchain transactions
4. **Result Display** - Frame shows transaction results and next steps
5. **Social Sharing** - Users can share results back to Farcaster

## Use Cases

### Content Creators

- **Create Brand Identities** - Establish verified identities for your content
- **Make Claims** - Assert expertise and achievements through frames
- **Build Reputation** - Earn reputation through community validation
- **Monetize Content** - Stake on your own content and earn rewards

### Researchers and Academics

- **Share Research** - Create atoms for research findings and methodologies
- **Verify Claims** - Use frames to verify research claims and relationships
- **Build Credibility** - Establish academic reputation through community validation
- **Collaborate** - Connect with other researchers through the trust network

### Business and Organizations

- **Establish Credibility** - Create verified organizational identities
- **Share Achievements** - Make claims about partnerships and accomplishments
- **Build Trust** - Leverage social proof for business relationships
- **Network** - Connect with partners and customers through the trust network

### Developers and Builders

- **Integrate Intuition** - Add Intuition functionality to your Farcaster apps
- **Build Frames** - Create custom frames with Intuition features
- **Access Data** - Use Intuition data in your applications
- **Contribute** - Help build the Intuition ecosystem

## Frame Types

### Identity Creation Frames

- **Simple Identity** - Basic atom creation with minimal metadata
- **Rich Identity** - Detailed atom creation with extensive metadata
- **Profile Linking** - Link Farcaster profiles to Intuition identities
- **Verification** - Verify existing identities through social proof

### Claim Creation Frames

- **Simple Claim** - Basic triple creation with three atom references
- **Rich Claim** - Detailed claim creation with evidence and context
- **Claim Discovery** - Search and discover existing claims
- **Claim Verification** - Verify claims through community validation

### Staking Frames

- **Positive Staking** - Stake on claims to express agreement
- **Negative Staking** - Stake against claims to express disagreement
- **Vault Overview** - View vault statistics and your position
- **Performance Tracking** - Monitor staking performance and returns

### Social Frames

- **Follow User** - Follow other users and build your network
- **Reputation Check** - View reputation scores and trust relationships
- **Recommendations** - Get personalized content recommendations
- **Network Analysis** - Analyze your trust network and connections

## Technical Implementation

### Frame Development

Frames are built using standard web technologies:

```html
<!-- Example Intuition Frame -->
<html>
  <head>
    <title>Intuition Identity Creation</title>
  </head>
  <body>
    <div class="intuition-frame">
      <h2>Create Your Identity</h2>
      <form id="identity-form">
        <input type="text" placeholder="Identity Name" required />
        <textarea placeholder="Description"></textarea>
        <button type="submit">Create Identity</button>
      </form>
    </div>
    <script src="intuition-frame-sdk.js"></script>
  </body>
</html>
```

### SDK Integration

The Intuition Frame SDK provides easy integration:

```javascript
// Initialize the Intuition Frame SDK
const intuitionFrame = new IntuitionFrame({
  network: 'mainnet',
  wallet: 'metamask',
});

// Create an atom (identity)
const result = await intuitionFrame.createAtom({
  name: 'Alice Johnson',
  description: 'Software Engineer at Tech Corp',
  metadata: {
    profession: 'Software Engineer',
    company: 'Tech Corp',
  },
});

// Display the result
frame.postMessage({
  type: 'identity-created',
  atomId: result.atomId,
  transactionHash: result.transactionHash,
});
```

### Frame Validation

All frames must meet Farcaster's validation requirements:

- **Security** - Secure implementation with proper input validation
- **Performance** - Fast loading and responsive interaction
- **Accessibility** - Accessible to users with disabilities
- **Compliance** - Follow Farcaster's content and behavior guidelines

## Best Practices

### Frame Design

- **Simple Interface** - Keep frames simple and easy to use
- **Clear Actions** - Make it obvious what actions users can take
- **Immediate Feedback** - Provide immediate feedback for user actions
- **Error Handling** - Gracefully handle errors and edge cases

### Content Strategy

- **Valuable Content** - Create frames that provide real value to users
- **Social Sharing** - Encourage users to share frame results
- **Community Building** - Use frames to build and engage communities
- **Reputation Building** - Help users build reputation through frame interactions

### Technical Considerations

- **Performance** - Optimize frames for fast loading and interaction
- **Security** - Implement proper security measures and input validation
- **Scalability** - Design frames to handle high user volumes
- **Monitoring** - Track frame usage and performance metrics

## Integration Examples

### Identity Verification Frame

```javascript
// Frame for verifying user identity
const verificationFrame = {
  title: 'Verify Your Identity',
  description: 'Create a verified identity on Intuition',
  actions: [
    {
      label: 'Create Identity',
      action: 'create-atom',
      parameters: {
        name: '{{user.name}}',
        description: 'Farcaster user: {{user.username}}',
      },
    },
  ],
};
```

### Claim Verification Frame

```javascript
// Frame for verifying claims
const claimFrame = {
  title: 'Verify This Claim',
  description: 'Stake on whether this claim is true',
  actions: [
    {
      label: 'Agree',
      action: 'stake-positive',
      parameters: {
        claimId: '{{claim.id}}',
        amount: '0.01',
      },
    },
    {
      label: 'Disagree',
      action: 'stake-negative',
      parameters: {
        claimId: '{{claim.id}}',
        amount: '0.01',
      },
    },
  ],
};
```

## Analytics and Metrics

### Frame Performance

- **Usage Statistics** - Track frame views and interactions
- **Conversion Rates** - Measure frame completion rates
- **User Engagement** - Monitor user engagement and retention
- **Social Sharing** - Track frame sharing and viral spread

### Intuition Integration

- **Atom Creation** - Track atoms created through frames
- **Claim Activity** - Monitor claim creation and staking activity
- **User Growth** - Measure user acquisition through frames
- **Network Effects** - Track network growth and engagement

## Development Resources

### Documentation

- [Farcaster Frames Documentation](https://docs.farcaster.xyz/developers/frames)
- [Intuition API Documentation](/guides/developer-tools/graphql-api)
- [Frame SDK Documentation](https://github.com/0xIntuition/intuition-frame)

### Tools and SDKs

- **Intuition Frame SDK** - Official SDK for building Intuition frames
- **Frame Templates** - Pre-built templates for common use cases
- **Testing Tools** - Tools for testing frames in development
- **Analytics Dashboard** - Dashboard for tracking frame performance

### Community

- **Developer Community** - Join the Intuition developer community
- **Frame Showcase** - Browse examples of Intuition frames
- **Support Channels** - Get help with frame development
- **Contribution Guidelines** - Guidelines for contributing to the ecosystem

## Related Resources

- [Portal](/guides/network/testnet/portal) - Main web interface for Intuition
- [MetaMask Snap](/guides/network/testnet/metamask-snap) - MetaMask integration
- [Browser Extension](/guides/network/testnet/browser-extension) - Chrome extension
- [Developer Tools](/guides/developer-tools) - Programmatic access
- [API Documentation](/guides/developer-tools/graphql-api) - Technical guides
- [Community](https://discord.gg/0xintuition) - Join the Intuition community

---

### File: docs/guides/network/testnet/index.md


# Intuition Testnet

Welcome to the Intuition Testnet - your development and testing environment for building on the Intuition Network.

## Network Configuration

| Parameter | Value |
|-----------|-------|
| **Network Name** | Intuition Testnet |
| **Chain ID** | 13579 |
| **Native Token** | $TTRUST |
| **RPC URL** | `https://testnet.rpc.intuition.systems/http` |
| **WebSocket URL** | `wss://testnet.rpc.intuition.systems/ws` |
| **Block Explorer** | [https://explorer.intuition.systems](https://explorer.intuition.systems) |

## Available Tools

The testnet provides all the tools you need for development:

- [**Bridge**](./bridge) - Transfer assets between networks
- [**Explorer**](./explorer) - View transactions and blocks
- [**Portal**](./portal) - Create identities and make claims
- [**RPC Endpoints**](./rpc) - Connect your applications
- [**Data Populator**](./data-populator) - Generate test data
- [**Farcaster Frames**](./farcaster-frames) - Social integration tools
- [**MetaMask Snap**](./metamask-snap) - Wallet integration

## Getting Started

1. **Connect to the Network** - Add the testnet to your wallet using the network configuration above
2. **Get Test Tokens** - Visit the faucet to receive test $TTRUST tokens
3. **Start Building** - Use the tools and documentation to build your application

## Support

Need help? Join our [Discord](https://discord.gg/RgBenkX4mx) community for support.

---

### File: docs/guides/network/testnet/metamask-snap.mdx


# MetaMask Snap

The **Intuition MetaMask Snap** extends MetaMask's functionality to seamlessly integrate with the Intuition knowledge graph. This Snap enables users to interact with Intuition's decentralized identity and reputation system directly through their MetaMask wallet, providing a familiar and secure interface for managing atoms, triples, and staking operations.

## Overview

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-100)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem',
  margin: '2rem 0',
  borderLeft: '4px solid var(--ifm-color-primary)'
}}>

The MetaMask Snap serves as a bridge between traditional Web3 wallet functionality and Intuition's knowledge graph, enabling users to:

- **Manage identities** - Create and manage Intuition atoms directly from MetaMask
- **Make claims** - Create triples and assertions about entities in the knowledge graph
- **Stake on content** - Participate in the Token Curated Registry by staking on atoms and triples
- **Access trust networks** - View and interact with reputation and trust data
- **Cross-platform integration** - Use Intuition features across any dApp that supports MetaMask

</div>

## Key Features

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
  gap: '1.5rem',
  margin: '2rem 0'
}}>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem'
}}>

### üÜî **Identity Management**

- Create and manage Intuition atoms (identities) directly from MetaMask
- View your created atoms and their associated vaults
- Manage atom metadata and relationships
- Export and backup identity data

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem'
}}>

### üìù **Claim Creation**

- Create triples (claims) using the Subject-Predicate-Object structure
- Stake on existing claims to express agreement or disagreement
- View claim details and associated vault information
- Manage your claim portfolio and staking positions

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem'
}}>

### üí∞ **Staking Operations**

- Deposit ETH into atom and triple vaults
- Withdraw staked amounts and earned fees
- View staking history and performance metrics
- Monitor vault share prices and market dynamics

</div>

<div style={{
  backgroundColor: 'var(--ifm-background-color)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem'
}}>

### ü§ù **Trust Network Integration**

- View reputation scores and trust relationships
- Follow other users and build your social graph
- Access personalized recommendations based on your network
- Verify claims and identities through the trust network

</div>

</div>

## Installation

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-100)',
  border: '1px solid var(--ifm-color-emphasis-300)',
  borderRadius: '8px',
  padding: '1.5rem',
  margin: '2rem 0',
  borderLeft: '4px solid var(--ifm-color-primary)'
}}>

### **Prerequisites**

- MetaMask wallet installed in your browser
- Access to the Intuition network
- Understanding of basic Intuition concepts (atoms, triples, vaults)

</div>

### **Installation Steps**

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '6px',
  padding: '1rem',
  margin: '1rem 0'
}}>

1. **Open MetaMask** - Ensure you have MetaMask installed and unlocked
2. **Navigate to Snaps** - Go to the MetaMask Snaps directory or use the direct installation link
3. **Install Intuition Snap** - Click "Install" on the Intuition MetaMask Snap
4. **Grant Permissions** - Approve the necessary permissions for the Snap to function
5. **Connect to Intuition** - Link your MetaMask wallet to the Intuition network
6. **Start Using** - Begin creating identities, making claims, and staking on content

</div>

## Getting Started

### First-Time Setup

1. **Create Your First Identity** - Use the Snap to create your first atom (identity)
2. **Make Your First Claim** - Create a triple to make an assertion about something
3. **Stake on Content** - Deposit ETH to signal agreement with existing claims
4. **Build Your Network** - Follow other users and build your trust network

### Basic Workflow

1. **Access the Snap** - Open MetaMask and navigate to the Intuition Snap
2. **Choose an Action** - Select from Create Identity, Make Claim, or Stake
3. **Fill in Details** - Provide the necessary information for your chosen action
4. **Confirm Transaction** - Review and approve the transaction in MetaMask
5. **Monitor Results** - Track your transaction and view the results

## Features in Detail

### Identity Creation

- **Simple Interface** - Easy-to-use forms for creating atoms
- **Metadata Support** - Add rich metadata to your identities
- **IPFS Integration** - Automatic upload of identity data to IPFS
- **Vault Association** - Each identity gets its own vault for staking

### Claim Management

- **Triple Creation** - Create Subject-Predicate-Object relationships
- **Claim Discovery** - Search and discover existing claims
- **Staking Interface** - Easy staking on positive or negative vaults
- **Claim Analytics** - View claim performance and community sentiment

### Staking Interface

- **Vault Overview** - View total assets, share prices, and your position
- **Deposit/Withdraw** - Simple interface for staking and unstaking
- **Fee Tracking** - Monitor earned fees and performance
- **Market Data** - Real-time vault statistics and trends

### Trust Network

- **Reputation Scores** - View trust scores for entities and users
- **Social Connections** - Follow users and build your network
- **Recommendations** - Get personalized content recommendations
- **Verification** - Verify claims and identities through the network

## Security Features

### Wallet Integration

- **Secure Storage** - All Intuition data stored securely in MetaMask
- **Private Keys** - Your private keys never leave MetaMask
- **Transaction Signing** - All transactions signed through MetaMask's secure interface
- **Permission Management** - Granular control over Snap permissions

### Network Security

- **Blockchain Verification** - All operations verified on the Intuition blockchain
- **Immutable Records** - All atoms and triples permanently recorded
- **Audit Trail** - Complete transaction history and provenance
- **Fraud Prevention** - Built-in mechanisms to prevent malicious activity

## Use Cases

### Content Creators

- Create identities for your content and brand
- Make claims about your expertise and achievements
- Build reputation through community staking
- Monetize your knowledge and contributions

### Researchers

- Create atoms for research entities and findings
- Make claims about research relationships and conclusions
- Build collaborative knowledge graphs
- Establish credibility through community validation

### Business Users

- Create organizational identities and relationships
- Make claims about business partnerships and achievements
- Build trust networks with partners and customers
- Leverage reputation for business opportunities

### Developers

- Integrate Intuition features into your dApps
- Access trust and reputation data programmatically
- Build applications that leverage the knowledge graph
- Contribute to the Intuition ecosystem

## Advanced Features

### API Integration

- **Programmatic Access** - Use the Snap's API for custom integrations
- **Webhook Support** - Receive notifications for important events
- **Data Export** - Export your Intuition data for external use
- **Custom Interfaces** - Build custom interfaces using the Snap's capabilities

### Analytics and Reporting

- **Performance Tracking** - Monitor your staking performance and returns
- **Network Analysis** - Analyze your trust network and connections
- **Claim Analytics** - Track the performance of your claims
- **Reputation Metrics** - Monitor your reputation score and trends

### Automation

- **Automated Staking** - Set up automated staking strategies
- **Claim Monitoring** - Get alerts for important claim updates
- **Portfolio Management** - Automated portfolio rebalancing
- **Social Automation** - Automated following and network building

## Troubleshooting

### Common Issues

- **Installation Problems** - Ensure MetaMask is up to date and properly configured
- **Transaction Failures** - Check gas settings and network connectivity
- **Permission Errors** - Review and update Snap permissions as needed
- **Sync Issues** - Refresh the Snap to sync with the latest blockchain state

### Getting Help

- **Documentation** - Review this guide and related documentation
- **Community Support** - Join the Intuition community for user support
- **Technical Support** - Contact the development team for technical issues
- **GitHub Issues** - Report bugs and feature requests on GitHub

## Development

The MetaMask Snap is open source and welcomes contributions:

- **GitHub Repository** - [https://github.com/0xIntuition/intuition-snap](https://github.com/0xIntuition/intuition-snap)
- **Documentation** - Comprehensive developer documentation
- **Testing** - Extensive test suite and quality assurance
- **Community** - Active development community and support

## Related Resources

- [Portal](/guides/network/testnet/portal) - Main web interface for Intuition
- [Browser Extension](/guides/network/testnet/browser-extension) - Chrome extension for web browsing
- [Developer Tools](/guides/developer-tools) - Programmatic access and integration
- [API Documentation](/guides/developer-tools/graphql-api) - Technical integration guides
- [Community](https://discord.gg/0xintuition) - Join the Intuition community

---

### File: docs/guides/network/testnet/portal.mdx


# The Intuition Portal

The Portal is Intuition's first Explorer (akin to a block explorer), which provides users with easy access to the social and knowledge graph. Positioned at the application layer, the Portal offers an intuitive interface for users to create, manage, and interact with Identities (Atoms) and Claims (Triples). It serves as the gateway for creating decentralized identities, making claims, and managing your stake, transforming the exploration of the knowledge graph into an accessible and user-friendly experience.

While most explorers are only meant for exploring, The Portal also provides a user interface for easily interacting with the Intuition Graph in its entirety.

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-100)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '2rem 0',
  borderLeft: '4px solid var(--ifm-color-primary)'
}}>

### üìã **Covered in this guide:**

This guide provides step-by-step instructions for The Portal's core features:

- **Creating Identities** - Build your digital presence
- **Creating Claims** - Make assertions and statements
- **Staking on Identities and Claims** - Participate in the Token Curated Registry
- **Using Tags** - Organize and discover content
- **Organizing Lists** - Create curated collections
- **Following Users** - Build your social network

</div>

## 1. Creating and Managing Identities (Atoms)

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

Identities, also known as **Atoms**, are the fundamental building blocks in the Intuition system. Each Atom represents a concept, such as a person, organization, or product, and comes with a unique decentralized identifier, structured data, and an associated Vault for signaling its relevancy.

### **How to Create an Identity**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

1. **Click the "Create" action button** in the bottom left section of the menu panel
2. **Select "Create Identity"** from the dropdown menu
3. **Input data** to describe the Identity you are creating
4. **Optionally deposit ETH** to stake on your newly created Identity

</div>

### **What Happens After Creation?**

When you create an Identity, the data is uploaded to IPFS, generating an IPFS CID that is used to create an Atom in the Intuition contracts. This Atom can now be referenced universally across the web.

</div>

## 2. Making Claims (Triples)

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

**What are Claims?** Claims, or **Triples**, allow you to assert statements about anything using a **[Subject][Predicate][Object]** structure. For example, **[Alice][is][trustworthy]**. Creating a Claim does not automatically express agreement with the claim; you must stake on the Claim to do so.

### **How to Create a Claim:**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

1. **Click the "Create" action button** in the bottom left section of the menu panel
2. **Select "Create Claim"** from the dropdown menu
3. **Choose three Atoms/Identities** to form your Claim

</div>

### **Helpful Tips:**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

- **Existing Claims**: If a claim already exists, simply stake on the existing claim to express your agreement with it
- **Prerequisites**: To create a claim, Atoms must already exist for the subject, predicate and object. If any one of the 3 required Atoms does not exist, you will first need to follow step 1 above to create the necessary identities before composing your claim

</div>

</div>

## 3. Staking (Signal Conviction)

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

**What is Staking?** Staking in Intuition allows you to signal what is important or what you believe to be true by staking ETH on Identities (Atoms) or Claims (Triples). This process contributes to a **Token Curated Registry (TCR)**, where the most relevant information rises to the top.

### **Staking on an Identity:**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

- **Signals the relevancy** of the Identity
- **Grants you shares** in the Identity, earning fees from future stakes

</div>

### **Staking on a Claim:**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

- Claims have a **Positive Vault** (for supporting the Claim) and a **Negative Vault** (for opposing the Claim)
- Staking on a Claim also stakes on the Claim's underlying Identities

</div>

### **Unstaking:**

You can unstake your ETH at any time to retrieve your deposit (minus fees).

### **Staking Economics:**

Staking grants you shares that provide a proportionate amount of fee revenue accumulated by the Identity or Claim, incentivizing you to stake on high-traction items.

</div>

## 4. Using Tags

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

**What are Tags?** Tags are shortcuts to organizing and finding relevant information. Tagging is achieved by creating a Claim using the **[has tag]** Atom as the Predicate. The ability to create tags is one of the first features to leverage "special predicates" and demonstrates how functionality can be built around specific types of claims. In this case, tags are the foundation on which users can create and manage Lists.

### **Creating and Using Tags:**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

- **New Tag Creation**: To create a new Tag, you must create a new Identity for the tag you want to use if it doesn't already exist. Just like any other claim, Identities (Atoms) must exist for the Subject, Predicate, and Object of your **[has tag]** claim. When adding a new tag, we know the Subject and Predicate exist, so users only need to ensure an Object Atom exists (which represents the tag to be added)

- **Tagging Process**: Tag something by searching through "Existing Tags" or creating a new one
- **Benefits**: Tagging enhances discoverability and adds items to relevant Lists

</div>

</div>

## 5. Organizing with Lists

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

**What are Lists?** Lists allow you to group related items or data in a way that makes sense to you, helping others discover, save, and provide feedback. Lists are constructed through deterministic queries, making it easy to organize and navigate complex data.

### **Creating a List:**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

- Lists are formed by Claims with the **[has tag]** Predicate
- Tag an Identity to include it in a specific List

</div>

### **Adding to and Managing Lists:**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

- Use the **"Add to list"** and **"Save list"** buttons to manage your Lists
- Lists are **Token Curated Registries (TCR)**, where you can stake ETH to order entries within a List

</div>

</div>

## 6. Following Users

<div style={{ 
  backgroundColor: 'var(--ifm-background-color)', 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '1.5rem 0'
}}>

**What is Following?** Following in Intuition is a contextual statement made by staking on the Claim **[I][am following][User]**. This staking process reflects the strength of your connection and is part of the open data available for developers to use in building a social graph.

### **How to Follow/Unfollow:**

<div style={{ 
  backgroundColor: 'var(--ifm-color-emphasis-50)', 
  border: '1px solid var(--ifm-color-emphasis-200)', 
  borderRadius: '6px', 
  padding: '1rem', 
  margin: '1rem 0'
}}>

- **To follow**: Click on a user's profile and select "Follow," then optionally stake ETH
- **To unfollow**: Click "Following" on the user's profile and select "Unfollow." Unfollowing also redeems your staked ETH

</div>

</div>

## Getting Started

<div style={{ 
  backgroundColor: 'var(--ifm-color-primary-lightest)', 
  border: '1px solid var(--ifm-color-primary-light)', 
  borderRadius: '8px', 
  padding: '1.5rem', 
  margin: '2rem 0',
  textAlign: 'center'
}}>

### üöÄ **Ready to begin your journey?**

Visit **[portal.intuition.systems](https://portal.intuition.systems)** to start creating identities, making claims, and building your presence in the Intuition knowledge graph.

</div>

## Related Resources

<div style={{ 
  display: 'grid', 
  gridTemplateColumns: 'repeat(auto-fit, minmax(250px, 1fr))', 
  gap: '1rem', 
  marginTop: '2rem'
}}>

<div style={{ 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '6px', 
  padding: '1rem', 
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[Explorer](/guides/network/testnet/explorer)** - Network exploration tools

</div>

<div style={{ 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '6px', 
  padding: '1rem', 
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[Bridge](/guides/network/testnet/bridge)** - Cross-chain functionality

</div>

<div style={{ 
  border: '1px solid var(--ifm-color-emphasis-300)', 
  borderRadius: '6px', 
  padding: '1rem', 
  backgroundColor: 'var(--ifm-background-color)'
}}>

**[RPC](/guides/network/testnet/rpc)** - Network connectivity options

</div>

</div> 

---

### File: docs/guides/network/testnet/rpc.md


# RPC

The Intuition RPC (Remote Procedure Call) service provides programmatic access to the Intuition network.

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '12px',
  padding: '1.5rem',
  marginBottom: '2rem'
}}>

## Overview

RPC endpoints allow developers and applications to:

- Query blockchain data
- Submit transactions
- Monitor network state
- Access historical data
- Interact with smart contracts

</div>

## Available Endpoints

<div style={{
  display: 'grid',
  gridTemplateColumns: 'repeat(auto-fit, minmax(300px, 1fr))',
  gap: '1.5rem',
  marginBottom: '2rem'
}}>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '12px',
  padding: '1.5rem'
}}>

### Core RPC Methods

- **eth_getBalance**: Get account balance
- **eth_getBlockByNumber**: Retrieve block information
- **eth_getTransactionByHash**: Get transaction details
- **eth_sendRawTransaction**: Submit signed transactions
- **eth_call**: Execute contract calls
- **eth_getLogs**: Retrieve event logs

</div>

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '12px',
  padding: '1.5rem'
}}>

### Intuition-Specific Methods

- **intuition_getAtoms**: Query atom data
- **intuition_getTriples**: Retrieve triple information
- **intuition_getSignals**: Access signal data
- **intuition_getBondingCurves**: Get bonding curve data

</div>

</div>

## Authentication

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '12px',
  padding: '1.5rem',
  marginBottom: '2rem'
}}>

RPC access requires authentication for production use:

<div style={{
  display: 'flex',
  flexDirection: 'column',
  gap: '1rem',
  marginTop: '1rem'
}}>

<div style={{
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem'
}}>
<div style={{
  width: '24px',
  height: '24px',
  borderRadius: '50%',
  backgroundColor: 'var(--ifm-color-success)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexShrink: 0
}}>
<svg width="14" height="14" viewBox="0 0 24 24" fill="white">
<path d="M12,1L3,5V11C3,16.55 6.84,21.74 12,23C17.16,21.74 21,16.55 21,11V5L12,1M12,7C13.4,7 14.8,8.6 14.8,10V11.5C14.8,14.1 12.4,16.5 9.8,16.5C7.2,16.5 4.8,14.1 4.8,11.5V10C4.8,8.6 6.2,7 7.6,7H12M12,8.2C11.2,8.2 10.5,8.9 10.5,9.7V11.5C10.5,12.9 11.6,14 13,14C14.4,14 15.5,12.9 15.5,11.5V9.7C15.5,8.9 14.8,8.2 14,8.2H12Z"/>
</svg>
</div>
<span style={{ fontSize: '1rem', fontWeight: '500' }}><strong>Wallet Authentication</strong>: Secure access with wallet-based authentication</span>
</div>

<div style={{
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem'
}}>
<div style={{
  width: '24px',
  height: '24px',
  borderRadius: '50%',
  backgroundColor: 'var(--ifm-color-success)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexShrink: 0
}}>
<svg width="14" height="14" viewBox="0 0 24 24" fill="white">
<path d="M12,1L3,5V11C3,16.55 6.84,21.74 12,23C17.16,21.74 21,16.55 21,11V5L12,1M12,7C13.4,7 14.8,8.6 14.8,10V11.5C14.8,14.1 12.4,16.5 9.8,16.5C7.2,16.5 4.8,14.1 4.8,11.5V10C4.8,8.6 6.2,7 7.6,7H12M12,8.2C11.2,8.2 10.5,8.9 10.5,9.7V11.5C10.5,12.9 11.6,14 13,14C14.4,14 15.5,12.9 15.5,11.5V9.7C15.5,8.9 14.8,8.2 14,8.2H12Z"/>
</svg>
</div>
<span style={{ fontSize: '1rem', fontWeight: '500' }}><strong>Rate Limiting</strong>: Fair usage policies</span>
</div>

<div style={{
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem'
}}>
<div style={{
  width: '24px',
  height: '24px',
  borderRadius: '50%',
  backgroundColor: 'var(--ifm-color-success)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexShrink: 0
}}>
<svg width="14" height="14" viewBox="0 0 24 24" fill="white">
<path d="M12,1L3,5V11C3,16.55 6.84,21.74 12,23C17.16,21.74 21,16.55 21,11V5L12,1M12,7C13.4,7 14.8,8.6 14.8,10V11.5C14.8,14.1 12.4,16.5 9.8,16.5C7.2,16.5 4.8,14.1 4.8,11.5V10C4.8,8.6 6.2,7 7.6,7H12M12,8.2C11.2,8.2 10.5,8.9 10.5,9.7V11.5C10.5,12.9 11.6,14 13,14C14.4,14 15.5,12.9 15.5,11.5V9.7C15.5,8.9 14.8,8.2 14,8.2H12Z"/>
</svg>
</div>
<span style={{ fontSize: '1rem', fontWeight: '500' }}><strong>WebSocket Support</strong>: Real-time data streaming</span>
</div>

<div style={{
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem'
}}>
<div style={{
  width: '24px',
  height: '24px',
  borderRadius: '50%',
  backgroundColor: 'var(--ifm-color-success)',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  flexShrink: 0
}}>
<svg width="14" height="14" viewBox="0 0 24 24" fill="white">
<path d="M12,1L3,5V11C3,16.55 6.84,21.74 12,23C17.16,21.74 21,16.55 21,11V5L12,1M12,7C13.4,7 14.8,8.6 14.8,10V11.5C14.8,14.1 12.4,16.5 9.8,16.5C7.2,16.5 4.8,14.1 4.8,11.5V10C4.8,8.6 6.2,7 7.6,7H12M12,8.2C11.2,8.2 10.5,8.9 10.5,9.7V11.5C10.5,12.9 11.6,14 13,14C14.4,14 15.5,12.9 15.5,11.5V9.7C15.5,8.9 14.8,8.2 14,8.2H12Z"/>
</svg>
</div>
<span style={{ fontSize: '1rem', fontWeight: '500' }}><strong>HTTPS Only</strong>: Secure connections required</span>
</div>

</div>

</div>

## Usage Examples

<div style={{
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '12px',
  padding: '1.5rem',
  marginBottom: '2rem'
}}>

```javascript
// Connect to Intuition RPC
const provider = new ethers.providers.JsonRpcProvider(
  'https://rpc.intuition.network'
);

// Query account balance
const balance = await provider.getBalance(address);

// Get latest block
const block = await provider.getBlock('latest');
```

</div>

<div style={{
  background: 'linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%)',
  border: '1px solid #404040',
  borderRadius: '16px',
  padding: '2rem',
  textAlign: 'center',
  color: 'white',
  marginTop: '2rem'
}}>
<h3 style={{ marginTop: 0, marginBottom: '1rem', color: 'white' }}>
Ready to Connect?
</h3>
<p style={{ margin: '0 0 1.5rem 0', color: 'rgba(255, 255, 255, 0.9)', fontSize: '1.1rem' }}>
Start building with the Intuition RPC service and integrate blockchain functionality into your applications.
</p>
<div style={{ display: 'flex', gap: '1rem', justifyContent: 'center', flexWrap: 'wrap' }}>
<a href="/docs/quickstart" style={{
  backgroundColor: 'var(--ifm-color-primary)',
  color: 'white',
  padding: '0.75rem 1.5rem',
  borderRadius: '8px',
  textDecoration: 'none',
  fontWeight: '500',
  display: 'inline-flex',
  alignItems: 'center',
  gap: '0.5rem',
  transition: 'all 0.2s ease'
}}>
Get Started
</a>
<a href="/docs/developer-tools/graphql-api" style={{
  backgroundColor: 'transparent',
  color: 'white',
  padding: '0.75rem 1.5rem',
  borderRadius: '8px',
  textDecoration: 'none',
  fontWeight: '500',
  border: '1px solid rgba(255, 255, 255, 0.3)',
  display: 'inline-flex',
  alignItems: 'center',
  gap: '0.5rem',
  transition: 'all 0.2s ease'
}}>
GraphQL API
</a>
</div>
</div>

*[Placeholder content - to be expanded with actual RPC documentation and examples]* 

---

### File: docs/guides/primitives/atoms.md


import BrowserOnly from '@docusaurus/BrowserOnly';
import ExcalidrawViewer from '@site/src/components/ExcalidrawViewer';

# Atoms

Atoms are the foundational building blocks of Intuition's knowledge graph ‚Äì the words in our global dictionary. Think of Intuition as a vast, collaborative dictionary where anyone can create a new word, and each word has its own globally persistent, unique digital identifier that can be used to reference it across the entire internet!

## Understanding Atoms

In the spirit of the Semantic Web and linked data, an Atom can correspond to virtually anything:

- **People**: User identities, profiles, public figures
- **Organizations**: Companies, DAOs, institutions, projects
- **Addresses**: Cryptocurrency wallets, smart contracts, validators
- **Documents**: Files, articles, research papers, certificates
- **Temporal markers**: Dates, timestamps, time periods
- **Categories**: Tags, classifications, taxonomies
- **Concepts**: Ideas, words, phrases, abstract notions

Each Atom's unique ID is deterministically generated based on its `atomData` field ‚Äì meaning the same data will always produce the same Atom ID. This ensures that duplicate Atoms cannot be created for identical data, and anyone can independently verify an Atom's ID by hashing its data. This design makes Atoms act as a bridge between on-chain identifiers and the rich context of off-chain data ‚Äì similar to how an NFT token ID might reference metadata stored elsewhere.

## Technical Architecture

### Core Structure

Under the hood, creating a new Atom mints a tokenized record using the ERC-1155 multi-token standard that includes:

1. **Unique Atom ID**: A permanent, immutable identifier deterministically derived from the atomData
2. **Atom Data**: Can contain any arbitrary data (URIs, text, JSON, references to external resources)
3. **Associated Smart Contract Wallet**: Enabling the Atom itself to own assets and interact with contracts

Every Atom carries `atomData` which can contain any arbitrary information relevant to that entity. For example:
- An Atom for "Solar Energy" might contain a link to a Wikipedia page about solar power
- An Atom for a user's identity might contain a DID document reference or profile JSON
- An Atom for a document might contain an IPFS content hash
- An Atom for a concept might contain a simple text string or structured JSON data

### Staking Vaults and Bonding Curves

Each Atom has one or more Vaults attached to it for staking. These vaults operate on a bonding curve, meaning:

- The cost to acquire a stake (or "share") in an Atom increases as more is already staked
- Early stakers get a larger stake for their investment
- Latecomers pay a premium for popular Atoms

This mechanism incentivizes early discovery of important Atoms and creates a form of priority signaling ‚Äì the community collectively "bids up" the Atoms deemed valuable or relevant by risking capital in their vaults.

### Atom Creation Process

<BrowserOnly fallback={<p>Loading diagram...</p>}>
  {() => <ExcalidrawViewer src="/excalidraw/atom-creation-diagram.excalidraw.json" zoom={0.3} scrollX={-150} scrollY={650} />}
</BrowserOnly>

## The Problem Atoms Solve


### Universal Reference Standardization

Today's web is siloed ‚Äì the same entity might be referred to in dozens of different ways across different platforms. Consider how many separate user accounts or content IDs one person might have across various sites.

Intuition's Atoms provide:
- A single, canonical identifier for each real-world thing
- Universal reusability across any application or user
- Easy reconciliation and trust of data from disparate sources
- Automatic deduplication through deterministic ID generation

By converging on a universal set of Atoms, every piece of data about Alice can point to the same Atom `[Alice]`, rather than being scattered across unlinked profiles. Since Atom IDs are deterministically generated from their data, if two users try to create an Atom with identical data, they'll generate the same ID ‚Äì preventing duplicates at the protocol level.

### Market-Driven Ontology Management

While deterministic IDs prevent exact duplicates, similar concepts might still be represented with slightly different data (e.g., "DeFi" vs "Decentralized Finance"). The protocol employs Token Curated Registry (TCR) logic for these cases:

1. **Competition**: Users tend to stake on the Atom that others find more useful or legitimate
2. **Signal Accumulation**: One variant accrues more Signal and usage over time
3. **Natural Selection**: The preferred Atom wins out as the standard
4. **Economic Incentives**: Early backers of the "winning" Atom are rewarded through vault fees and token emissions

This market-driven approach, combined with deterministic ID generation, ensures the knowledge base converges on canonical representations while preventing exact duplicates.

## Design Principles: Atomic Granularity

### The Power of Flat Data

A crucial best practice is keeping information modular and atomic. You are economically incentivized to create "flatter" Atoms ‚Äì each representing a single, minimal concept ‚Äì rather than packing composite information into one Atom.

#### Why Granularity Matters

Consider representing the statement: **"Tiger Research was founded in 2021"**

**‚ùå Monolithic Approach** (Not Recommended):
```javascript
// One Atom containing all information
const statementAtom = {
  data: "Tiger Research was founded in 2021"
}
```

Problems with this approach:
- Hard to verify which part might be incorrect if disputed
- Cannot reuse individual components
- Difficult to update or correct specific elements
- Less composable with other data

**‚úÖ Atomic Approach** (Best Practice):
```javascript
// Three separate Atoms
const tigerResearchAtom = { data: "Tiger Research" }
const foundedInAtom = { data: "founded in" }
const year2021Atom = { data: "2021" }

// Connected via a Triple
const foundingTriple = {
  subject: tigerResearchAtom,
  predicate: foundedInAtom,
  object: year2021Atom
}
```

Benefits of this approach:
- Each piece can be independently verified and traced
- Individual components are reusable (the `[2021]` Atom can be used in countless other triples)
- Corrections can be made to specific elements without discarding everything
- Trust accrued by each Atom benefits all its usages

### Economic Incentives for Granularity

Intuition's economic model naturally guides users toward optimal granularity:

- **Reusable Atoms** accumulate more Signal as they're referenced in multiple Triples
- **High-Signal Atoms** attract more $TRUST stakes, increasing their network gravity
- **Composite Atoms** with embedded data are less likely to be reused or staked
- **Modular Design** maximizes potential for community adoption and value accrual

## Flexibility and Scope

Atoms are not limited to static concepts. They can represent:

- **Dynamic entities**: User-generated content, evolving documents
- **Abstract concepts**: Tags, categories, classifications
- **Data structures**: JSON schemas, configuration templates
- **Content chunks**: Text snippets, code fragments (via IPFS CID)

Regardless of what an Atom represents, the principles remain consistent:
1. Give it a clear, unique identity
2. Include relevant data in the atomData field
3. Keep its scope narrow for maximum verifiability and reusability

## Best Practices

### Creating Effective Atoms

1. **Leverage Deterministic IDs**: Remember that identical atomData will always produce the same Atom ID
2. **Check for Similar Atoms**: Search for canonical Atoms before creating variations
3. **Use Clear Data**: Choose descriptive, unambiguous data values
4. **Maintain Single Purpose**: Each Atom should represent one thing
5. **Consider Reusability**: Design Atoms others will want to reference

### Atom Design Patterns

Think of Atoms as **words in the Intuition dictionary**:
- They are the lego-like pieces that snap into many contexts
- Community Signal concentrates on the words that matter most
- Triples form the "sentences" that connect these dictionary words together

### Integration with Triples

Atoms gain their true power when connected via Triples:
- **Subject Atoms**: The entity being described
- **Predicate Atoms**: The relationship or property
- **Object Atoms**: The value or target of the relationship

This separation allows each component to be independently verified, updated, and trusted.

## Practical Examples

### Identity Atom
```javascript
const aliceAtom = {
  atomData: "https://alice.id/profile.json",
  id: "atom_0x123...", // Deterministically generated from atomData
  vault: "0xabc...",
  signal: 1500
}
```

### Concept Atom
```javascript
const defiAtom = {
  atomData: {
    name: "DeFi",
    definition: "Decentralized Finance",
    reference: "ipfs://QmX.../defi-definition.json"
  },
  id: "atom_0x456...", // Deterministically generated from atomData
  vault: "0xdef...",
  signal: 8500
}
```

### Relationship Atom (Predicate)
```javascript
const expertInAtom = {
  atomData: "expertIn",
  id: "atom_0x789...", // Deterministically generated from "expertIn"
  vault: "0xghi...",
  signal: 3200
}
```

## Next Steps

With Atoms as your foundation, you can:
- Learn about [Triples](./triples) to create meaningful relationships between Atoms
- Explore [Signals](./signals) to understand attestation and trust mechanics
- Review [Vaults](./vaults) for staking and economic participation
- Check the [SDK Documentation](/docs/developer-tools/sdks/overview) for implementation details

---

### File: docs/guides/primitives/atoms/best-practices.md


# Best Practices

## Creating Effective Atoms

1. **Leverage Deterministic IDs**: Remember that identical atomData will always produce the same Atom ID
2. **Check for Similar Atoms**: Search for canonical Atoms before creating variations
3. **Use Clear Data**: Choose descriptive, unambiguous data values
4. **Maintain Single Purpose**: Each Atom should represent one thing
5. **Consider Reusability**: Design Atoms others will want to reference

## Atom Design Patterns

Think of Atoms as **words in the Intuition dictionary**:
- They are the lego-like pieces that snap into many contexts
- Community Signal concentrates on the words that matter most
- Triples form the "sentences" that connect these dictionary words together

## Integration with Triples

Atoms gain their true power when connected via Triples:
- **Subject Atoms**: The entity being described
- **Predicate Atoms**: The relationship or property
- **Object Atoms**: The value or target of the relationship

This separation allows each component to be independently verified, updated, and trusted.

---

### File: docs/guides/primitives/atoms/design-principles.md


# Design Principles: Atomic Granularity

:::tip The Power of Flat Data
A crucial best practice is keeping information modular and atomic. You are economically incentivized to create "flatter" Atoms ‚Äì each representing a single, minimal concept ‚Äì rather than packing composite information into one Atom.
:::

## Why Granularity Matters

Consider representing the statement: **"Tiger Research was founded in 2021"**

### Monolithic Approach (Not Recommended)

```javascript
// One Atom containing all information
const statementAtom = {
  data: "Tiger Research was founded in 2021"
}
```

Problems with this approach:
- Hard to verify which part might be incorrect if disputed
- Cannot reuse individual components
- Difficult to update or correct specific elements
- Less composable with other data

### Atomic Approach (Best Practice)

```javascript
// Three separate Atoms
const tigerResearchAtom = { data: "Tiger Research" }
const foundedInAtom = { data: "founded in" }
const year2021Atom = { data: "2021" }

// Connected via a Triple
const foundingTriple = {
  subject: tigerResearchAtom,
  predicate: foundedInAtom,
  object: year2021Atom
}
```

Benefits of this approach:
- Each piece can be independently verified and traced
- Individual components are reusable (the `[2021]` Atom can be used in countless other triples)
- Corrections can be made to specific elements without discarding everything
- Trust accrued by each Atom benefits all its usages

## Economic Incentives for Granularity

Intuition's economic model naturally guides users toward optimal granularity:

- **Reusable Atoms** accumulate more Signal as they're referenced in multiple Triples
- **High-Signal Atoms** attract more $TRUST stakes, increasing their network gravity
- **Composite Atoms** with embedded data are less likely to be reused or staked
- **Modular Design** maximizes potential for community adoption and value accrual

## Flexibility and Scope

Atoms are not limited to static concepts. They can represent:

- **Dynamic entities**: User-generated content, evolving documents
- **Abstract concepts**: Tags, categories, classifications
- **Data structures**: JSON schemas, configuration templates
- **Content chunks**: Text snippets, code fragments (via IPFS CID)

Regardless of what an Atom represents, the principles remain consistent:
1. Give it a clear, unique identity
2. Include relevant data in the atomData field
3. Keep its scope narrow for maximum verifiability and reusability

---

### File: docs/guides/primitives/atoms/overview.md


import BrowserOnly from '@docusaurus/BrowserOnly';
import ExcalidrawViewer from '@site/src/components/ExcalidrawViewer';

# Atoms

Atoms are the foundational building blocks of Intuition's knowledge graph ‚Äì the words in our global dictionary. Think of Intuition as a vast, collaborative dictionary where anyone can create a new word, and each word has its own globally persistent, unique digital identifier that can be used to reference it across the entire internet!

## Understanding Atoms

In the spirit of the Semantic Web and linked data, an Atom can correspond to virtually anything:

- **People**: User identities, profiles, public figures
- **Organizations**: Companies, DAOs, institutions, projects
- **Addresses**: Cryptocurrency wallets, smart contracts, validators
- **Documents**: Files, articles, research papers, certificates
- **Temporal markers**: Dates, timestamps, time periods
- **Categories**: Tags, classifications, taxonomies
- **Concepts**: Ideas, words, phrases, abstract notions

Each Atom's unique ID is deterministically generated based on its `atomData` field ‚Äì meaning the same data will always produce the same Atom ID. This ensures that duplicate Atoms cannot be created for identical data, and anyone can independently verify an Atom's ID by hashing its data. This design makes Atoms act as a bridge between on-chain identifiers and the rich context of off-chain data ‚Äì similar to how an NFT token ID might reference metadata stored elsewhere.

## Technical Architecture

### Core Structure

Under the hood, creating a new Atom mints a tokenized record using the ERC-1155 multi-token standard that includes:

1. **Unique Atom ID**: A permanent, immutable identifier deterministically derived from the atomData
2. **Atom Data**: Can contain any arbitrary data (URIs, text, JSON, references to external resources)
3. **Associated Smart Contract Wallet**: Enabling the Atom itself to own assets and interact with contracts

Every Atom carries `atomData` which can contain any arbitrary information relevant to that entity. For example:
- An Atom for "Solar Energy" might contain a link to a Wikipedia page about solar power
- An Atom for a user's identity might contain a DID document reference or profile JSON
- An Atom for a document might contain an IPFS content hash
- An Atom for a concept might contain a simple text string or structured JSON data

### Staking Vaults and Bonding Curves

Each Atom has one or more Vaults attached to it for staking. These vaults operate on a bonding curve, meaning:

- The cost to acquire a stake (or "share") in an Atom increases as more is already staked
- Early stakers get a larger stake for their investment
- Latecomers pay a premium for popular Atoms

This mechanism incentivizes early discovery of important Atoms and creates a form of priority signaling ‚Äì the community collectively "bids up" the Atoms deemed valuable or relevant by risking capital in their vaults.

### Atom Creation Process

<BrowserOnly fallback={<p>Loading diagram...</p>}>
  {() => <ExcalidrawViewer src="/excalidraw/atom-creation-diagram.excalidraw.json" zoom={0.3} scrollX={-150} scrollY={650} />}
</BrowserOnly>

## Explore More

Dive deeper into Atoms with these detailed guides:

- **[The Problem Atoms Solve](./problem-atoms-solve)**: Understand how Atoms enable universal reference standardization and market-driven ontology management
- **[Design Principles: Atomic Granularity](./design-principles)**: Learn why granularity matters and how to design effective, reusable Atoms
- **[Best Practices](./best-practices)**: Discover patterns and guidelines for creating high-quality Atoms
- **[Practical Examples](./practical-examples)**: See real-world examples of Identity, Concept, and Relationship Atoms

## Next Steps

With Atoms as your foundation, you can:
- Learn about [Triples](../triples) to create meaningful relationships between Atoms
- Explore [Signals](../signals) to understand attestation and trust mechanics
- Review [Vaults](../vaults) for staking and economic participation
- Check the [SDK Documentation](/docs/developer-tools/sdks/overview) for implementation details

---

### File: docs/guides/primitives/atoms/practical-examples.md


# Practical Examples

## Identity Atom

```javascript
const aliceAtom = {
  atomData: "https://alice.id/profile.json",
  id: "atom_0x123...", // Deterministically generated from atomData
  vault: "0xabc...",
  signal: 1500
}
```

## Concept Atom

```javascript
const defiAtom = {
  atomData: {
    name: "DeFi",
    definition: "Decentralized Finance",
    reference: "ipfs://QmX.../defi-definition.json"
  },
  id: "atom_0x456...", // Deterministically generated from atomData
  vault: "0xdef...",
  signal: 8500
}
```

## Relationship Atom (Predicate)

```javascript
const expertInAtom = {
  atomData: "expertIn",
  id: "atom_0x789...", // Deterministically generated from "expertIn"
  vault: "0xghi...",
  signal: 3200
}
```

## Next Steps

With Atoms as your foundation, you can:
- Learn about [Triples](../triples) to create meaningful relationships between Atoms
- Explore [Signals](../signals) to understand attestation and trust mechanics
- Review [Vaults](../vaults) for staking and economic participation
- Check the [SDK Documentation](/docs/developer-tools/sdks/overview) for implementation details

---

### File: docs/guides/primitives/atoms/problem-atoms-solve.md


# The Problem Atoms Solve

## Universal Reference Standardization

Today's web is siloed ‚Äì the same entity might be referred to in dozens of different ways across different platforms. Consider how many separate user accounts or content IDs one person might have across various sites.

Intuition's Atoms provide:
- A single, canonical identifier for each real-world thing
- Universal reusability across any application or user
- Easy reconciliation and trust of data from disparate sources
- Automatic deduplication through deterministic ID generation

By converging on a universal set of Atoms, every piece of data about Alice can point to the same Atom `[Alice]`, rather than being scattered across unlinked profiles. Since Atom IDs are deterministically generated from their data, if two users try to create an Atom with identical data, they'll generate the same ID ‚Äì preventing duplicates at the protocol level.

## Market-Driven Ontology Management

While deterministic IDs prevent exact duplicates, similar concepts might still be represented with slightly different data (e.g., "DeFi" vs "Decentralized Finance"). The protocol employs Token Curated Registry (TCR) logic for these cases:

1. **Competition**: Users tend to stake on the Atom that others find more useful or legitimate
2. **Signal Accumulation**: One variant accrues more Signal and usage over time
3. **Natural Selection**: The preferred Atom wins out as the standard
4. **Economic Incentives**: Early backers of the "winning" Atom are rewarded through vault fees and token emissions

This market-driven approach, combined with deterministic ID generation, ensures the knowledge base converges on canonical representations while preventing exact duplicates.

---

### File: docs/guides/primitives/overview.md


import BrowserOnly from '@docusaurus/BrowserOnly';
import ExcalidrawViewer from '@site/src/components/ExcalidrawViewer';

# Primitives Overview

Intuition's data model is built on three fundamental primitives that work together to create a rich, self-regulating knowledge graph:

<div className="uniform-card-grid">

<div className="uniform-card">
<h2 className="uniform-card-title">Atoms</h2>
<p className="uniform-card-content">
The basic entities or identifiers - unique decentralized identifiers for everything in existence. Think of them as the <strong>nodes</strong> in the knowledge graph, or the <strong>words</strong> in the dictionary.
</p>
</div>

<div className="uniform-card">
<h2 className="uniform-card-title">Triples</h2>
<p className="uniform-card-content">
Structured relationships or claims linking entities together in Subject-Predicate-Object format. These are the <strong>edges</strong> in the knowledge graph / the <strong>sentences</strong> in the language of Intuition.
</p>
</div>

<div className="uniform-card">
<h2 className="uniform-card-title">Signals</h2>
<p className="uniform-card-content">
The weight of trust or consensus behind each entity or claim, determined by community staking. These represent the <strong>edge weights</strong> in the graph, or 'who is saying what about what, with what level of conviction'.
</p>
</div>

</div>


---

### File: docs/guides/primitives/signals/overview.md


# Overview

Signals represent the trust, confidence, or relevance that the community assigns to Atoms and Triples in the Intuition knowledge graph. Think of the knowledge graph as a weighted graph where Signal is the weight on each node (Atom) or edge (Triple), indicating how strongly people believe in or care about this information.

## Understanding Signals

Signals transform static data into a dynamic, trusted intelligence layer. When someone stakes $TRUST tokens on an Atom or Triple, they emit a Signal expressing that they find that piece of information important or true. Conversely, staking on a Triple's negative side signals doubt. These individual signals aggregate to form an overall weighted state for each item in the knowledge graph.

In essence, Signals are the lifeblood of Intuition's trust layer. They turn subjective judgments into quantifiable, shareable data, creating an internet where information is contextualized with trust‚Äîallowing everyone to navigate knowledge supported by transparent evidence and collective wisdom.

### The Vision

Intuition aims to create an internet where every piece of information carries its trust signature‚Äîwhere we navigate knowledge with an intuition of what to believe, supported by transparent evidence and collective wisdom rather than blind faith in centralized authorities.

## How Signals are Created

The core mechanism for creating signals is through **staking** (also called attesting). When you deposit $TRUST tokens into an Atom's vault or a Triple's vaults, you're effectively buying "shares" in that piece of information.

### Staking Mechanics

- **Atoms**: Each Atom has a single staking vault
- **Triples**: Each Triple has two vaults (positive and negative)
- **Shares**: Your stake represents proportional ownership and conviction

For example:
- Staking 100 TRUST on the Atom `[Ethereum]` gives you a fraction of total Atom Shares for `[Ethereum]`
- Staking 50 TRUST on `[Alice] is Friend Of [Bob]` in the affirmative vault gives you Triple Shares supporting that friendship claim

### Bonding Curves

The bonding curve mechanics mean share prices depend on existing stake levels:
- Early stakers get better prices
- Later stakers pay more for the same signal increment
- This creates a perpetual prediction market for information

### Continuous Markets

Staking is not a one-time vote but a continuous market:
- Add more stake to increase your signal
- Withdraw stake (with potential rewards or penalties)
- Counter-stake on opposite sides for Triples
- Market "odds" constantly adjust to reflect aggregated beliefs

## Total Value Locked and Consensus

Each Atom and Triple accrues **Total Value Locked (TVL)** in its vaults‚Äîa direct measure of tokenized trust. Higher TVL generally implies greater relevance or credibility, helping filter signal from noise.

### Consensus Calculation

The consensus score weighs multiple variables:
- Amount staked on each side
- Number of distinct attestors
- Past reliability (reputation) of attestors

For example, if a claim has:
- 10,000 TRUST staked in support (from 2 whales)
- 2,000 TRUST staked against (from 100 knowledgeable users)

The raw numbers alone don't tell the full story. The consensus algorithm factors in these nuances, which can be tuned through governance.

### Economic Incentives and Ownership

Signals create a revolutionary ownership model for information. When you stake TRUST on an Atom or Triple, you're not just voting‚Äîyou're buying ownership shares in that piece of data.

#### How Signal Economics Work

1. **Stake TRUST, Receive Tokens**: When you stake TRUST on any Atom or Triple, you receive proportional tokens representing your ownership share
   - Each Atom and Triple has its own token supply
   - The number of tokens you receive depends on the bonding curve price at the time of staking
   - Early stakers get more tokens per TRUST than later stakers

2. **Bonding Curve Pricing**: Everything operates on bonding curves, creating dynamic pricing:
   - Initial stakes are cheap (more tokens per TRUST)
   - As more people stake, the price increases
   - This rewards early discovery and conviction
   - Creates a market mechanism for information value

3. **Fee Distribution to Token Holders**: Here's where it gets powerful‚Äîtoken holders earn from all interactions:
   - When someone queries the data, fees go to token holders
   - When others stake on the same Atom/Triple, trading fees accrue to existing holders
   - When the data is traversed in graph queries, micro-fees flow to owners
   - The more useful the data, the more fees it generates

#### Signals as Data Ownership

This model transforms Signals from simple attestations into **programmatic value flows**:

```javascript
// Example: Staking creates ownership
const stake = await stakeOnAtom({
  atomId: "ethereum-atom",
  amount: 100  // 100 TRUST
});

// You now own tokens representing your share
console.log(stake);
// {
//   tokensReceived: 45,  // Based on bonding curve
//   totalSupply: 1000,    // Total tokens for this Atom
//   ownership: 0.045,     // You own 4.5% of this Atom
//   currentPrice: 2.22    // Current price per token
// }

// As the Atom generates fees, you earn proportionally
// Every query, every reference, every interaction = revenue
```

#### Value Flow Examples

Consider these scenarios:

**Popular Identity Atom**: An Atom representing "Vitalik Buterin"
- Thousands of Triples reference it
- Queries constantly traverse through it
- Early stakers earn fees from every interaction
- Acts like owning "shares" in a highly-trafficked data highway

**Valuable Triple**: "[Company X] [acquired] [Company Y]"
- News services query it
- Financial models reference it
- Trading bots check it
- Token holders earn from all this usage

**Infrastructure Data**: Common predicates like "owns" or "created"
- Used in millions of queries
- Essential graph infrastructure
- Stakers essentially own critical data infrastructure

This creates an economy where:
- **Discovery is rewarded**: Find and stake on useful data early
- **Curation has value**: Your stake helps validate quality
- **Usage generates returns**: Popular data pays dividends
- **Information becomes an asset class**: Data literally has owners who profit from its use

## Three Forms of Signal Generation

The Intuition model accounts for three distinct forms of signal generation:

### 1. Explicit Signal

Direct stakes or votes by users‚Äîthe most straightforward form:
- Users explicitly declare stance by locking tokens
- Like upvoting/downvoting with money at risk
- Ensures serious, considered assertions

### 2. Implicit Signal

Derived from usage and interaction patterns:
- Frequency of queries and references
- Inclusion in other Triples
- Application usage metrics
- Off-chain indexing tracks these metrics
- "Crowds vote with their attention/tools"

### 3. Transitive Signal

Reflects web-of-trust effects:
- Signals from trusted sources carry more weight
- If Alice stakes on a claim and you historically align with Alice, her signal counts more strongly in your view
- Trust propagates through the social graph of attestors
- Reality Tunnels use this for personalized perspectives

## Interpreting Signals

Every piece of signal data is fully transparent and on-chain, allowing anyone to inspect why an Atom/Triple has its reputation:

### Transparency Features

- View which addresses have staked
- See stake amounts and sides
- Analyze attestor profiles
- Trust but verify approach

### Meta-Information Value

The meta-layer reveals crucial context:
- A 95% consensus might have dissenting 5% from domain experts
- Highly reputable DAOs and individuals staking together lends strong credibility
- "Who trusts this and who doesn't" becomes quantifiable data

This transparency enables both users and AI agents to evaluate information with full context rather than blind trust.

## Using Signals: Filtering and Reality Tunnels

Now that we understand how signals work, let's explore their most powerful application: filtering information based on trust. In traditional databases, you can query for data that exists. In Intuition, you can query for data that is *trusted*‚Äîand define exactly what "trusted" means to you.

### Trust-Based Filtering

Think of signals as creating a trust layer over all information. Instead of getting raw, unvetted data, you can filter results based on community confidence, stake amounts, or specific attestors. This transforms queries from "what exists" to "what can I trust."

#### Filtering by Consensus and Stakes

When querying the knowledge graph, you can set minimum trust thresholds. For example, imagine you're building a DeFi aggregator that needs to identify legitimate DAO treasuries. Rather than maintaining a manual whitelist, you can query for addresses that the community has strongly validated:

```javascript
// Find DAO treasuries with strong community backing
const trustedDAOs = await query({
  pattern: "[Address] [is DAO Treasury] [True]",
  minSignal: {
    tvl: 10000,        // At least 10,000 TRUST staked
    consensus: 0.8     // At least 80% positive consensus
  }
});
```

This query returns only addresses where:
- The community has staked significant value (10,000+ TRUST) on the claim
- There's strong agreement (80%+ consensus) that it's actually a DAO treasury
- The signal data provides economic backing for the classification

#### Filtering by Specific Attestors

Sometimes you don't just want community consensus‚Äîyou want verification from specific, authoritative sources. Signal filtering allows you to require attestations from particular entities.

Consider an HR application that needs to verify employment. Instead of trusting any claim that "Alice works at Company Y," you can require that Company Y itself has attested to this relationship:

```javascript
// Get employee data that's been verified by the employer
const employees = await query({
  pattern: "[Person] [employee Of] [Company Y]",
  requireSignalFrom: "Company Y"  // Company must have attested
});
```

This ensures you're only getting employment claims that the company itself has staked on, providing authoritative verification without centralized APIs or manual verification processes.

### Reality Tunnels

Reality Tunnels take signal filtering to the next level by creating complete worldviews or perspectives through which to interpret data. Think of them as curated lenses that determine whose signals you trust and how much weight to give them.

#### What is a Reality Tunnel?

A Reality Tunnel is essentially a trust configuration that filters and weights signals according to specific criteria. Instead of seeing "raw truth," you see truth as interpreted through a particular perspective. The same underlying data can look completely different through different tunnels.

For example, when evaluating a claim like "Cryptocurrency X is a good investment":
- A **Conservative Investor Tunnel** might heavily weight signals from established financial institutions
- A **Crypto Native Tunnel** might prioritize signals from DeFi protocols and veteran traders
- A **Risk Averse Tunnel** might only show claims with near-unanimous positive consensus

#### Types of Reality Tunnels

Different tunnels serve different needs and communities:

- **Conservative Tunnel**: Weights signals from established, verified experts in traditional fields. Useful for risk-averse users who prefer institutional validation.

- **Scientific Tunnel**: Only considers claims backed by academic citations, peer review signals, or attestations from verified researchers. Filters out speculation and opinion.

- **Community Tunnel**: Follows broad majority consensus, essentially "wisdom of the crowds." Good for general-purpose queries where you want mainstream agreement.

- **Custom Tunnels**: Users or organizations can create their own trust parameters, perhaps weighting signals from specific DAOs, professional networks, or social graphs.

#### How Reality Tunnels Work

When you select a Reality Tunnel, you're essentially applying a complex filter to all signal data:

```javascript
// Example: Scientific Reality Tunnel configuration
const scientificTunnel = {
  requiredSignals: ["peer-reviewed", "has-citations"],
  minAttestors: 3,
  attestorRequirements: {
    mustInclude: ["verified-researcher", "academic-institution"]
  },
  consensusThreshold: 0.7,
  weights: {
    "university-attestor": 2.0,    // Double weight for universities
    "peer-reviewer": 1.5,          // 1.5x weight for peer reviewers
    "general-user": 0.5            // Half weight for general users
  }
};

// Query through this tunnel
const scientificFacts = await query({
  pattern: "[Study] [shows] [Result]",
  tunnel: scientificTunnel
});
```

Each tunnel adjusts which signals influence results while maintaining the same underlying data. Users can inspect or adopt any trust framework as needed.

### Protocol Neutrality

**Crucially, the Intuition protocol does not tell anyone how to interpret signals.** The protocol operates at a very low level, simply allowing things to "say things about things" without imposing any specific interpretation logic.

Key principles of protocol neutrality:
- **No Forced Interpretation**: The protocol never dictates what signals mean
- **Unopinionated Infrastructure**: Signal data exists as raw, neutral information
- **Interpretation Layer Separation**: All meaning-making happens higher up the stack
- **Multiple Valid Views**: Different applications can interpret the same signals differently
- **User Sovereignty**: You choose which interpretation framework to trust

This means:
- There may be default interpretations or Reality Tunnels provided for convenience
- Communities and trusted entities can build their own interpretation layers
- Applications can implement custom consensus algorithms
- Users are never locked into a singular worldview
- The same signal data can support contradictory but equally valid interpretations

The protocol's unopinionated nature ensures that Intuition remains a neutral substrate for trust, allowing diverse ecosystems of interpretation to flourish on top of the same underlying signal data.

## Economic Dynamics and Network Effects

### Value Flow Distribution

Whenever data is utilized (queried or referenced), fees flow to stakers:
- Early stakers earn proportionally more
- Active data generates continuous rewards
- Unused claims provide no returns
- Creates natural quality filtering

### Self-Refinement Mechanism

The economic incentives naturally drive system improvement:
1. Stakers who identify valuable data earn more rewards
2. Stakers on unused or irrelevant data earn less
3. Useful information becomes economically advantageous to support
4. Irrelevant claims naturally receive less stake
5. System quality improves through market dynamics

Importantly, the protocol itself never determines what is "true" or "false." It simply rewards participation in frequently-used data. Higher-level applications can build resolution mechanisms, prediction markets, or truth determination systems on top of this neutral substrate.

### Network Effects

As more users participate:
- Signal reliability increases
- Trust networks strengthen
- Economic incentives amplify
- Information quality improves
- Collective wisdom emerges

## Key Takeaways

### The Signal Trinity

1. **Atoms** provide the entities
2. **Triples** provide the relationships and facts
3. **Signals** tell us which facts and entities are trusted, relevant, and by whom

Together, this trinity creates a knowledge graph where:
- Information comes with trust context
- Truth emerges from collective wisdom
- Economic incentives align with accuracy
- Transparency enables verification

### Why Signals Matter

Signals transform the internet's information layer:
- **From blind trust** ‚Üí To transparent verification
- **From centralized sources** ‚Üí To decentralized consensus
- **From misinformation** ‚Üí To economically-backed truth
- **From static data** ‚Üí To dynamic, living knowledge



## Next Steps

- Understand [Atoms](./atoms) and [Triples](./triples) as signal targets
- Explore [Reality Tunnels](./reality-tunnels) for personalized trust views
- Learn about [Smart Contracts](/docs/developer-tools/contracts/contract-architecture) for on-chain signaling
- Review [Economics](/docs/guides/introduction/the-economics) for detailed tokenomics
- Check the [API Documentation](/docs/developer-tools/graphql-api/overview) for implementation details

---

### File: docs/guides/primitives/signals/practical-implementation.md


# Practical Implementation Examples

## Creating and Querying Signals

```javascript
// Stake on an Atom
const atomSignal = await stake({
  vaultId: ethereumAtom.vaultId,
  amount: 100 // 100 TRUST tokens
});

// Stake on a Triple (positive)
const tripleSignal = await stake({
  vaultId: friendshipTriple.positiveVaultId,
  amount: 50
});

// Counter-stake (negative)
const disputeSignal = await stake({
  vaultId: claimTriple.negativeVaultId,
  amount: 75
});

// Query with confidence threshold
const trustedClaims = await query({
  minConsensus: 0.7,
  minTVL: 1000
});
```

## Building Trust-Aware Applications

```javascript
// Create a trust-filtered API
class TrustAPI {
  async getVerifiedFacts(topic, minTrust = 0.8) {
    const results = await intuition.query({
      pattern: `[*] [relatesTo] [${topic}]`,
      filters: {
        consensus: { gte: minTrust },
        attestors: { gte: 10 }
      }
    });

    return results.map(r => ({
      fact: r.triple,
      trust: r.consensus,
      evidence: r.signals
    }));
  }
}
```

---

### File: docs/guides/primitives/signals/strategies-best-practices.md


# Signal Strategies and Best Practices

## Optimal Signaling Strategy

The game-theoretic optimal strategy is to:
1. Identify accurate, useful information early
2. Stake before widespread recognition
3. Earn from value flow as data gets utilized
4. Build reputation through consistent accuracy

## Risk Considerations

- **No Absolute Truth Guarantee**: Signals represent consensus and confidence, not absolute truth
- **Early Stage Risks**: Fewer participants can mean less reliable signals
- **Potential for Manipulation**: Large stakes can temporarily skew consensus
- **Opportunity Cost**: Staking on irrelevant or unused claims means missing better opportunities

## Defensive Strategies

- Always examine the trust trail behind strong signals
- Drill down into attestor profiles and motivations
- Consider contrarian positions when consensus seems wrong
- Diversify across multiple claims and domains

---

### File: docs/guides/primitives/triples.md


# Triples

If Atoms are the words in Intuition's global dictionary, Triples are the sentences we create from those words. A Triple connects three Atoms to assert a relationship or fact in the form **[Subject] ‚Äì [Predicate] ‚Äì [Object]**. You can string these sentences together to express any arbitrarily-complex concept, all while retaining a discrete, referenceable structure!

## Understanding Triples

A Triple is a fundamental data structure that expresses relationships between Atoms, following the classic RDF triple format used in semantic web technologies. This makes Intuition's data inherently machine-readable and structured.

Every Triple represents a claim‚Äîit asserts that a Subject has some relationship (Predicate) to an Object. For example:

```
[Alice] -- [livesIn] --> [Paris]
```

This Triple asserts a fact about Alice's location, where:
- **Alice** is the subject Atom
- **livesIn** is the predicate Atom (describing the type of relationship)
- **Paris** is the object Atom

Each component of a Triple is an Atom ID under the hood. The system doesn't store free-form text "Alice" or "Paris" but rather pointers to those Atom records, which might contain rich data, alternate labels, and additional metadata.

## The Graph Structure

Triples naturally form a graph of nodes and links. You can visualize:
- **Atoms as nodes** in the graph
- **Triples as directed edges** from subject to object, labeled by the predicate

This graph structure enables powerful capabilities:
- Deterministic queries like "find all objects that Alice is connected to via livesIn"
- Traversal of relationships to discover indirect connections
- Pattern matching across the knowledge graph

## Why Triples Matter

### Semantic Clarity
By expressing data in Triple format, Intuition ensures relationships are explicit and standardized. Instead of loose text statements like "Alice lives in Paris" (which computers struggle to parse), we have typed links that machines understand: `Alice ‚ÄîlivesIn‚Üí Paris`.

### Reconciliation & Interoperability
The clarity of Triples means different data sources referencing the same predicate can be merged or compared easily. This semantic structure makes data immediately useful to other systems‚Äîknowledge graphs and AI systems can ingest these subject-predicate-object triples without guessing their meaning.

### Extensibility
Triples are infinitely extensible. New information can be attached in graph form without altering the original nodes. If we later learn "Alice lives in Paris since 2015", we can introduce new Atoms and predicates to capture this additional context through supplementary Triples.

### Composability
The data model is open-ended‚Äîyou can always extend the graph by adding another Triple rather than modifying existing ones. This is analogous to how one can keep adding facts to Wikipedia.

## Nested Triples: Meta-Claims & Context

One of Intuition's most powerful features is that Triples can reference other Triples, effectively nesting statements to provide context or provenance. Intuition supports using a Triple itself as a Subject or Object in another Triple.

### Example: Disputing a Claim
Consider an initial Triple:
```
[Bob] -- [isFriendOf] --> [Alice]
```

If Alice disagrees with this claim, we can create a nested Triple:
```
[Alice] -- [disproves] --> (Bob isFriendOf Alice)
```

Here, the Object of the second Triple is not an Atom but a reference to the first Triple (identified by its Triple ID). Alice is essentially asserting that the friendship claim is false.

### Adding Evidence & Sources
You can link Triples to evidence or citations:
```
[Triple X] -- [basedOn] --> [Document Y]
```

This ability to compose Triples into higher-order statements gives the graph a fractal quality‚Äîsmall facts build into bigger facts, and complex relationships can be broken down into simpler ones.

## Positive and Negative Claims

Unlike traditional databases that store only "the one truth," Intuition allows multiple competing Triples and uses Signals (stakes) to gauge their validity.

### Two-Sided Staking Vaults
Every Triple has two logical versions:
- **YES vault**: Supporting the claim (affirmative)
- **NO vault**: Denying the claim (negative)

Users can stake on either side, effectively casting weighted votes about the truth of that Triple. This design means a Triple object encapsulates both the claim and its counter-claim within one structure.

### Example: Contested Relationships
For the Triple `[Bob] -- [isFriendOf] --> [Alice]`:
- The affirmative vault contains stakes from those who agree Bob and Alice are friends
- The negative vault contains stakes from those who disagree (potentially including Alice herself!)

### Consensus Evaluation
The network evaluates consensus by:
- Comparing signals on both sides
- Factoring in attestor reputation
- Considering the number of attestors
- Calculating confidence scores that adjust over time

Importantly, Intuition doesn't force a single authoritative truth‚Äîit records the spectrum of belief. Multiple "canonical" Triples can compete, and the TCR mechanism with staking tends to favor the most accurate representations.

## Best Practices for Structuring Triples

### Use Precise Predicates
The Predicate Atom is crucial for clarity. Guidelines:
- **Search first**: Check if a canonical predicate already exists
- **Reuse standards**: Don't create `[worksFor]` if `[employeeOf]` is widely used
- **Converge on conventions**: Using common predicates helps data link up instead of fragmenting

The Intuition community and token mechanics organically push toward standard predicates through signal accumulation.

### One Fact Per Triple
Each Triple should capture a single discrete claim:
- ‚ùå "Alice isFriendOf Bob and coworker at CompanyX"
- ‚úÖ Two separate Triples: one for friendship, another for workplace

Keeping to one relation makes staking and validation straightforward‚Äîpeople can agree with one link and not the other.

### Leverage Nesting for Context
When statements need qualification:
- Create auxiliary Triples rather than complicating the original
- Attach timeframes or sources through supporting Triples
- Use nested Triples for meta-information

Example: Time-bound relationships
```
Main Triple: [Alice] -- [isFriendOf] --> [Bob]
Context Triple: [Triple ID] -- [validSince] --> [2023]
```

### Handle Counter-Claims Wisely
Generally, you don't need to manually create "not X" Triples‚Äîthe negative staking vault handles disagreement. However, sometimes a negation has specific meaning that deserves its own predicate (e.g., `[isNotFriendOf]` as a distinct relation type).

The "Counter Triple" concept is more about how the UI and indexing organize the negative vault signal than about separate data objects.

## Core Benefits

### Semantic Clarity and Interoperability
Each Triple makes a small, clear statement that can be understood in isolation or as part of larger datasets. This semantic structure means data from Intuition is immediately useful to other systems‚Äîknowledge graphs and AI can ingest these triples without guessing their meaning.

### Flexibility & Composability
Triples can represent simple facts or be combined into complex graphs. You can always extend the graph by adding another Triple rather than modifying existing ones. Because Triples can reference other Triples, you get composability in assertions‚Äîbuilding evidence chains, tracking consensus over time, and more.

### Built-In Conflict Resolution
Triples come with a native way to handle conflicting views through the two-vault mechanism. This keeps contradictory information tethered to the original claim, improving data organization. Rather than disjointed claims floating around, everything is anchored‚Äîa false claim isn't simply deleted but gets counter-staked and remains in the graph with a low trust score.

### Context and Evolution
Knowledge in Intuition is not static. When statements become outdated or need context, you don't replace old data‚Äîyou supplement it. For example, if Alice moves from Paris to London:
1. Mark the Paris Triple as no longer current (stake against it or add an "endDate" context triple)
2. Add `[Alice] -- [livesIn] --> [London]` as a new Triple with current timestamp

The history is preserved, and queries can be time-scoped or context-aware thanks to the graph structure.

## Practical Implementation

### Creating Triples
```javascript
// Basic Triple creation
const triple = await createTriple({
  subjectId: aliceAtom.id,
  predicateId: livesInAtom.id,
  objectId: parisAtom.id
});

// With temporal context
const employmentTriple = await createTriple({
  subjectId: person.id,
  predicateId: "employed-by",
  objectId: company.id,
  metadata: {
    startDate: "2024-01-01",
    department: "Engineering"
  }
});
```

### Nested Triple Example
```javascript
// Create the base claim
const friendshipClaim = await createTriple({
  subjectId: bob.id,
  predicateId: isFriendOf.id,
  objectId: alice.id
});

// Alice disputes the claim
const dispute = await createTriple({
  subjectId: alice.id,
  predicateId: disproves.id,
  objectId: friendshipClaim.id  // Reference to the Triple itself
});
```

### Building Evidence Chains
```javascript
// Create a research finding
const researchClaim = await createTriple({
  subjectId: study.id,
  predicateId: concludes.id,
  objectId: result.id
});

// Link to supporting document
const evidence = await createTriple({
  subjectId: researchClaim.id,  // Triple as subject
  predicateId: basedOn.id,
  objectId: peerReviewedPaper.id
});
```

## Use Cases

### Knowledge Graphs
Build comprehensive knowledge networks for:
- Academic citations and research connections
- Information hierarchies and taxonomies
- Cross-referenced documentation systems

### Identity & Reputation
Create verifiable identity systems with:
- Professional credentials and certifications
- Social connections and endorsements
- Achievement records and skill attestations

### Supply Chain
Track product journeys through:
- Origin verification and authenticity
- Ownership transfers and custody chains
- Quality attestations and compliance records

### DeFi & Finance
Express financial relationships including:
- Asset ownership and portfolio composition
- Lending positions and collateralization
- Liquidity provisions and yield farming positions

## Querying Triples

### Basic Queries
```graphql
# Find all facts about Alice
query {
  triples(where: { subjectId: "alice_atom_id" }) {
    predicate
    object {
      data
    }
  }
}

# Find all friendship relationships
query {
  triples(where: { predicate: "isFriendOf" }) {
    subject { data }
    object { data }
  }
}
```

### Traversing the Graph
```graphql
# Find where Alice's friends live
query {
  triples(where: {
    subjectId: "alice_atom_id",
    predicate: "isFriendOf"
  }) {
    object {
      triples(where: { predicate: "livesIn" }) {
        object { data }
      }
    }
  }
}
```

## Integration with Other Primitives

### With Atoms
- Triples connect Atoms into meaningful relationships
- Atoms gain context through Triple connections
- Triple predicates can themselves be Atoms for maximum flexibility

### With Signals
- Signals add weight to Triple claims through staking
- Community validates Triples through Signal attestations
- Signal strength directly affects Triple credibility and consensus

## Summary

Triples allow Intuition to form a living, searchable web of knowledge. When adding Triples, the goal is to make each claim as clear and verifiable as possible, selecting the right words (Atoms) from the global dictionary, and then letting the network of users and their Signals determine validity.

With Atoms as the words in our global dictionary and Triples as the sentences we construct from them, we can express any arbitrarily-complex concept while maintaining discrete, referenceable structure. Here's where it becomes powerful: each Triple receives its own unique ID, effectively becoming a new "word" in the system that encapsulates an entire concept. This ID can then be referenced by other Triples, allowing you to build increasingly sophisticated expressions.

Think of it as linguistic compression‚Äîinstead of repeatedly expressing complex relationships, you create them once and reference them by ID. A Triple about "Alice's employment at a specific company with particular conditions" becomes a single referenceable unit. That unit can then be used in higher-order statements about employment trends, verification claims, or temporal changes. This creates a hierarchy of meaning where complex ideas are built from simpler ones, yet each level remains independently addressable and verifiable.

The result is an extraordinarily efficient knowledge transmission system. Rather than sending verbose descriptions, systems can exchange compact Triple IDs that expand into rich, contextual information. Each ID carries with it not just data, but the entire graph of relationships, evidence, and community consensus that supports it. The addition of Signals completes the picture by measuring which sentences (facts) are trusted by the community.

---

### File: docs/guides/primitives/triples/core-benefits.md

## Why Triples Matter

### Semantic Clarity
By expressing data in Triple format, Intuition ensures relationships are explicit and standardized. Instead of loose text statements like "Alice lives in Paris" (which computers struggle to parse), we have typed links that machines understand: `Alice ‚ÄîlivesIn‚Üí Paris`.

### Reconciliation & Interoperability
The clarity of Triples means different data sources referencing the same predicate can be merged or compared easily. This semantic structure makes data immediately useful to other systems‚Äîknowledge graphs and AI systems can ingest these subject-predicate-object triples without guessing their meaning.

### Extensibility
Triples are infinitely extensible. New information can be attached in graph form without altering the original nodes. If we later learn "Alice lives in Paris since 2015", we can introduce new Atoms and predicates to capture this additional context through supplementary Triples.

### Composability
The data model is open-ended‚Äîyou can always extend the graph by adding another Triple rather than modifying existing ones. This is analogous to how one can keep adding facts to Wikipedia.

# Core Benefits

## Semantic Clarity and Interoperability

Each Triple makes a small, clear statement that can be understood in isolation or as part of larger datasets. This semantic structure means data from Intuition is immediately useful to other systems‚Äîknowledge graphs and AI can ingest these triples without guessing their meaning.

By expressing data in Triple format, Intuition ensures relationships are explicit and standardized. Instead of loose text statements like "Alice lives in Paris" (which computers struggle to parse), we have typed links that machines understand: `Alice ‚ÄîlivesIn‚Üí Paris`.

## Flexibility & Composability

Triples can represent simple facts or be combined into complex graphs. You can always extend the graph by adding another Triple rather than modifying existing ones. Because Triples can reference other Triples, you get composability in assertions‚Äîbuilding evidence chains, tracking consensus over time, and more.

The data model is open-ended‚Äîyou can always extend the graph by adding another Triple rather than modifying existing ones. This is analogous to how one can keep adding facts to Wikipedia.

## Built-In Conflict Resolution

Triples come with a native way to handle conflicting views through the two-vault mechanism. This keeps contradictory information tethered to the original claim, improving data organization. Rather than disjointed claims floating around, everything is anchored‚Äîa false claim isn't simply deleted but gets counter-staked and remains in the graph with a low trust score.

## Context and Evolution

Knowledge in Intuition is not static. When statements become outdated or need context, you don't replace old data‚Äîyou supplement it. For example, if Alice moves from Paris to London:
1. Mark the Paris Triple as no longer current (stake against it or add an "endDate" context triple)
2. Add `[Alice] -- [lives In] --> [London]` as a new Triple with current timestamp

The history is preserved, and queries can be time-scoped or context-aware thanks to the graph structure.

## Reconciliation & Interoperability

The clarity of Triples means different data sources referencing the same predicate can be merged or compared easily. This semantic structure makes data immediately useful to other systems‚Äîknowledge graphs and AI systems can ingest these subject-predicate-object triples without guessing their meaning.

## Extensibility

Triples are infinitely extensible. New information can be attached in graph form without altering the original nodes. If we later learn "Alice lives in Paris since 2015", we can introduce new Atoms and predicates to capture this additional context through supplementary Triples.

---

### File: docs/guides/primitives/triples/how-to-create.md


# How to create

There are multiple ways to create Triples on the Intuition platform. Choose the method that best fits your development workflow:

## Development Options

<div className="uniform-card-grid">

<div className="uniform-card">
<h3 className="uniform-card-title">SDK</h3>
<p className="uniform-card-content">
Use the Intuition SDK for a streamlined development experience with TypeScript support and built-in helpers.
</p>
<a href="/docs/developer-tools/sdks/overview" style={{ color: 'var(--ifm-color-primary)', textDecoration: 'none', fontWeight: '500' }}>Explore SDK ‚Üí</a>
</div>

<div className="uniform-card">
<h3 className="uniform-card-title">Smart Contracts</h3>
<p className="uniform-card-content">
Interact directly with Intuition smart contracts for maximum control and customization.
</p>
<a href="/docs/developer-tools/contracts/contract-architecture" style={{ color: 'var(--ifm-color-primary)', textDecoration: 'none', fontWeight: '500' }}>View Smart Contracts ‚Üí</a>
</div>

</div>


---

### File: docs/guides/primitives/triples/nested-triples-practical-implementation.md


# Practical Implementation

## Contextualization with Nested Triples

One of the most powerful features of nested Triples is the ability to add context and nuance to claims. Rather than making broad, absolute statements, you can progressively refine claims with additional layers of context.

### Progressive Context Building

Consider how trust can be contextualized at different levels:

**Level 1: Basic Trust Statement**
```
[I] -- [trust] --> [Billy]
```
This is a simple, general claim of trust without any specific context.

**Level 2: Domain-Specific Trust**
```
[I] -- [trust] --> [Billy]
[[I trust Billy]] -- [in context of] --> [Web3]
```
Here, we've added a layer of context by creating a nested Triple that specifies the domain. The trust claim now has a qualifier: it applies specifically within the Web3 ecosystem.

**Level 3: Adding Justification**
```
[I] -- [trust] --> [Billy]
[[I trust Billy]] -- [in context of] --> [Web3]
[[[I trust Billy] in context of Web3]] -- [because] --> [Intuition]
```
We can further refine by adding justification or reasoning. This creates a rich, layered claim that captures not just what you believe, but why and in what context.

### Why This Matters

This progressive contextualization allows for:
- **Precision**: Claims can be as specific or general as needed
- **Transparency**: The reasoning behind beliefs becomes explicit and verifiable
- **Flexibility**: Context can evolve without invalidating the base claim
- **Nuance**: Complex real-world relationships aren't reduced to binary yes/no statements

Instead of creating separate, disconnected claims for each variation, nested Triples build upon each other, creating a structured hierarchy that preserves the relationships between related statements.


---

### File: docs/guides/primitives/triples/nested-triples.md


# Nested Triples: Meta-Claims & Context

One of Intuition's most powerful features is that Triples can reference other Triples, effectively nesting statements to provide context or provenance. Intuition supports using a Triple itself as a Subject or Object in another Triple.

## Example: Disputing a Claim

Consider an initial Triple:
```
[Bob] -- [isFriendOf] --> [Alice]
```

If Alice disagrees with this claim, we can create a nested Triple:
```
[Alice] -- [disproves] --> (Bob isFriendOf Alice)
```

Here, the Object of the second Triple is not an Atom but a reference to the first Triple (identified by its Triple ID). Alice is essentially asserting that the friendship claim is false.

## Adding Evidence & Sources

You can link Triples to evidence or citations:
```
[Triple X] -- [basedOn] --> [Document Y]
```

This ability to compose Triples into higher-order statements gives the graph a fractal quality‚Äîsmall facts build into bigger facts, and complex relationships can be broken down into simpler ones.

## Linguistic Compression

Think of it as linguistic compression‚Äîinstead of repeatedly expressing complex relationships, you create them once and reference them by ID. A Triple about "Alice's employment at a specific company with particular conditions" becomes a single referenceable unit. That unit can then be used in higher-order statements about employment trends, verification claims, or temporal changes.

This creates a hierarchy of meaning where complex ideas are built from simpler ones, yet each level remains independently addressable and verifiable.

---

### File: docs/guides/primitives/triples/overview.md


# Triples

If Atoms are the words in Intuition's global dictionary, Triples are the sentences we create from those words. A Triple connects three Atoms to assert a relationship or fact in the form **[Subject] ‚Äì [Predicate] ‚Äì [Object]**. You can string these sentences together to express any arbitrarily-complex concept, all while retaining a discrete, referenceable structure!

## Understanding Triples

A Triple is a fundamental data structure that expresses relationships between Atoms, following the classic RDF triple format used in semantic web technologies. This makes Intuition's data inherently machine-readable and structured.

Every Triple represents a claim‚Äîit asserts that a Subject has some relationship (Predicate) to an Object. For example:

```
[Alice] -- [lives In] --> [Paris]
```

This Triple asserts a fact about Alice's location, where:
- **Alice** is the subject Atom
- **livesIn** is the predicate Atom (describing the type of relationship)
- **Paris** is the object Atom

Each component of a Triple is an Atom ID under the hood. The system doesn't store free-form text "Alice" or "Paris" but rather pointers to those Atom records, which might contain rich data, alternate labels, and additional metadata.

## Integration with Other Primitives

### With Atoms

- Triples connect Atoms into meaningful relationships
- Atoms gain context through Triple connections
- Triple predicates can themselves be Atoms for maximum flexibility

### With Signals

- Signals add weight to Triple claims through staking
- Community validates Triples through Signal attestations
- Signal strength directly affects Triple credibility and consensus

## The Graph Structure

Triples naturally form a graph of nodes and links. You can visualize:
- **Atoms as nodes** in the graph
- **Triples as directed edges** from subject to object, labeled by the predicate

This graph structure enables powerful capabilities:
- Deterministic queries like "find all objects that Alice is connected to via livesIn"
- Traversal of relationships to discover indirect connections
- Pattern matching across the knowledge graph


## Summary

Triples allow Intuition to form a living, searchable web of knowledge. When adding Triples, the goal is to make each claim as clear and verifiable as possible, selecting the right words (Atoms) from the global dictionary, and then letting the network of users and their Signals determine validity.

With Atoms as the words in our global dictionary and Triples as the sentences we construct from them, we can express any arbitrarily-complex concept while maintaining discrete, referenceable structure. Here's where it becomes powerful: each Triple receives its own unique ID, effectively becoming a new "word" in the system that encapsulates an entire concept. This ID can then be referenced by other Triples, allowing you to build increasingly sophisticated expressions.

Think of it as linguistic compression‚Äîinstead of repeatedly expressing complex relationships, you create them once and reference them by ID. A Triple about "Alice's employment at a specific company with particular conditions" becomes a single referenceable unit. That unit can then be used in higher-order statements about employment trends, verification claims, or temporal changes. This creates a hierarchy of meaning where complex ideas are built from simpler ones, yet each level remains independently addressable and verifiable.

The result is an extraordinarily efficient knowledge transmission system. Rather than sending verbose descriptions, systems can exchange compact Triple IDs that expand into rich, contextual information. Each ID carries with it not just data, but the entire graph of relationships, evidence, and community consensus that supports it. The addition of Signals completes the picture by measuring which sentences (facts) are trusted by the community.
## Explore More

Dive deeper into Triples with these detailed guides:

- **[Nested Triples: Meta-Claims & Context](./nested-triples)**: Learn how Triples can reference other Triples for context and provenance
- **[Positive and Negative Claims](./positive-negative-claims)**: Understand the two-sided staking mechanism and consensus evaluation
- **[Best Practices for Structuring Triples](./best-practices)**: Guidelines for creating effective, reusable Triples
- **[Core Benefits](./core-benefits)**: Discover the semantic clarity, flexibility, and conflict resolution capabilities
- **[Practical Implementation](./practical-implementation)**: Code examples for creating Triples, nested claims, and evidence chains
- **[Use Cases](./use-cases)**: Explore real-world applications in knowledge graphs, identity, supply chain, and DeFi
- **[Querying Triples](./querying-triples)**: Learn how to query and traverse the knowledge graph
- **[Integration with Other Primitives](./integration)**: See how Triples work with Atoms and Signals

---

### File: docs/guides/primitives/triples/positive-negative-claims.md


# Positive and Negative Claims

Unlike traditional databases that store only "the one truth," Intuition allows multiple competing Triples and uses Signals (stakes) to gauge their validity.

## Two-Sided Staking Vaults

Every Triple has two logical versions:
- **YES vault**: Supporting the claim (affirmative)
- **NO vault**: Denying the claim (negative)

Users can stake on either side, effectively casting weighted votes about the truth of that Triple. This design means a Triple object encapsulates both the claim and its counter-claim within one structure.

## Example: Contested Relationships

For the Triple `[Bob] -- [isFriendOf] --> [Alice]`:
- The affirmative vault contains stakes from those who agree Bob and Alice are friends
- The negative vault contains stakes from those who disagree (potentially including Alice herself!)

## Consensus Evaluation

The network evaluates consensus by:
- Comparing signals on both sides
- Factoring in attestor reputation
- Considering the number of attestors
- Calculating confidence scores that adjust over time

:::warning
Importantly, Intuition doesn't force a single authoritative truth‚Äîit records the spectrum of belief. Multiple "canonical" Triples can compete, and the TCR mechanism with staking tends to favor the most accurate representations.
:::

---

### File: docs/guides/primitives/triples/querying-triples.md


# Querying Triples

## Basic Queries

```graphql
# Find all facts about Alice
query {
  triples(where: { subjectId: "alice_atom_id" }) {
    predicate
    object {
      data
    }
  }
}

# Find all friendship relationships
query {
  triples(where: { predicate: "isFriendOf" }) {
    subject { data }
    object { data }
  }
}
```

## Traversing the Graph

```graphql
# Find where Alice's friends live
query {
  triples(where: {
    subjectId: "alice_atom_id",
    predicate: "isFriendOf"
  }) {
    object {
      triples(where: { predicate: "livesIn" }) {
        object { data }
      }
    }
  }
}
```

---

### File: docs/guides/primitives/triples/use-cases.md


# Use Cases

## Knowledge Graphs

Build comprehensive knowledge networks for:
- Academic citations and research connections
- Information hierarchies and taxonomies
- Cross-referenced documentation systems

## Identity & Reputation

Create verifiable identity systems with:
- Professional credentials and certifications
- Social connections and endorsements
- Achievement records and skill attestations

## Supply Chain

Track product journeys through:
- Origin verification and authenticity
- Ownership transfers and custody chains
- Quality attestations and compliance records

## DeFi & Finance

Express financial relationships including:
- Asset ownership and portfolio composition
- Lending positions and collateralization
- Liquidity provisions and yield farming positions

---

### File: docs/guides/quickstart/getting-started.md


# Getting Started

Get started building with Intuition in minutes. This guide provides direct code snippets to create atoms, triples, and signal on them.

:::info Version Compatibility
This guide uses the v2 contract architecture and requires the following package versions:
- [`@0xintuition/sdk@^2.0.0-alpha.2`](https://www.npmjs.com/package/@0xintuition/sdk)
- [`@0xintuition/protocol@^2.0.0-alpha.2`](https://www.npmjs.com/package/@0xintuition/protocol)
- [`@0xintuition/graphql@^2.0.0-alpha.2`](https://www.npmjs.com/package/@0xintuition/graphql)
:::

## Prerequisites

- Node.js 18+ and npm/pnpm/bun
- A Web3 wallet (MetaMask, Coinbase Wallet, etc.)
- Basic knowledge of React and TypeScript

## Network Configuration

### Option 1: Using Wagmi + RainbowKit

```bash
npm install wagmi viem @rainbow-me/rainbowkit @0xintuition/protocol
```

```typescript
import { createConfig, http } from 'wagmi'
import { defineChain } from 'viem'
import { mainnet, base } from 'viem/chains'

// Define Intuition Testnet
export const intuitionTestnet = defineChain({
  id: 13579,
  name: 'Intuition Testnet',
  nativeCurrency: {
    decimals: 18,
    name: 'tTRUST',
    symbol: 'tTRUST',
  },
  rpcUrls: {
    default: {
      http: ['https://testnet.rpc.intuition.systems/'],
    },
  },
  blockExplorers: {
    default: {
      name: 'Intuition Explorer',
      url: 'https://testnet.explorer.intuition.systems',
    },
  },
})

export const config = createConfig({
  chains: [mainnet, base, intuitionTestnet],
  transports: {
    [mainnet.id]: http(),
    [base.id]: http(),
    [intuitionTestnet.id]: http(),
  },
})
```

### Option 2: Using Privy

```bash
npm install @privy-io/react-auth @privy-io/wagmi @0xintuition/protocol
```

```typescript
import { PrivyProvider } from '@privy-io/react-auth'
import { intuitionTestnet } from './wagmi-config'

function App() {
  return (
    <PrivyProvider
      appId="your-privy-app-id"
      config={{
        loginMethods: ['wallet'],
        appearance: {
          theme: 'dark',
          showWalletLoginFirst: true,
        },
        defaultChain: intuitionTestnet,
        supportedChains: [intuitionTestnet],
      }}
    >
      {/* Your app */}
    </PrivyProvider>
  )
}
```

## Install the Intuition SDK

```bash
npm install @0xintuition/sdk @0xintuition/protocol
```

## Creating Atoms

Atoms are the foundational building blocks of Intuition's knowledge graph ‚Äì the words in our global dictionary. Think of Intuition as a vast, collaborative dictionary where anyone can create a new word, and each word has its own globally persistent, unique digital identifier that can be used to reference it across the entire internet!

[Learn more about Atoms ‚Üí](/docs/primitives/atoms)

### Create an Atom from a String

```typescript
import { createAtomFromString } from '@0xintuition/sdk'
import { getMultiVaultAddressFromChainId } from '@0xintuition/protocol'
import { useWalletClient, usePublicClient, useChainId } from 'wagmi'

function CreateAtom() {
  const chainId = useChainId()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()

  const handleCreate = async () => {
    const address = getMultiVaultAddressFromChainId(chainId)

    const result = await createAtomFromString(
      { walletClient, publicClient, address },
      'My First Atom'
    )

    console.log('Atom created:', result.transactionHash)
    console.log('Atom ID:', result.state.termId)
  }

  return <button onClick={handleCreate}>Create Atom</button>
}
```

### Create an Atom from a Thing (with metadata)

```typescript
import { createAtomFromThing } from '@0xintuition/sdk'

const result = await createAtomFromThing(
  { walletClient, publicClient, address },
  {
    url: 'https://example.com',
    name: 'Example Project',
    description: 'A cool Web3 project',
    image: 'https://example.com/image.png',
  }
)
```

### Create an Atom from Ethereum Account

```typescript
import { createAtomFromEthereumAccount } from '@0xintuition/sdk'

const result = await createAtomFromEthereumAccount(
  { walletClient, publicClient, address },
  {
    address: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045',
    chainId: 1, // Mainnet
  }
)
```

## Reading Data

### Get Atom Details

Retrieve detailed information about an atom using its ID:

```typescript
import { getAtomDetails } from '@0xintuition/sdk'

const atomData = await getAtomDetails(
  '0x57d94c116a33bb460428eced262b7ae2ec6f865e7aceef6357cec3d034e8ea21'
)

console.log('Atom data:', atomData)
// Returns atom information including metadata, vault details, and more
```

### Get Triple Details

Retrieve information about a triple relationship:

```typescript
import { getTripleDetails } from '@0xintuition/sdk'

const tripleData = await getTripleDetails(
  '0x4957d3f442acc301ad71e73f26efd6af78647f57dacf2b3a686d91fa773fe0b6'
)

console.log('Triple data:', tripleData)
// Returns subject, predicate, object atoms and relationship metadata
```

### Search the Knowledge Graph

Perform a global search across atoms, triples, accounts, and collections:

```typescript
import { globalSearch } from '@0xintuition/sdk'

const results = await globalSearch('ethereum', {
  atomsLimit: 10,
  accountsLimit: 5,
  triplesLimit: 10,
  collectionsLimit: 5,
})

console.log('Search results:', results)
```

### Semantic Search

Use AI-powered semantic search to find relevant atoms:

```typescript
import { semanticSearch } from '@0xintuition/sdk'

const results = await semanticSearch(
  'decentralized identity protocols',
  { limit: 5 }
)

console.log('Semantic search results:', results)
```

### Read On-Chain Atom Data

Read atom data directly from the smart contract:

```typescript
import { getAtom } from '@0xintuition/protocol'

const atomOnChain = await getAtom(
  { publicClient, address },
  { args: [BigInt(atomId)] }
)

console.log('On-chain atom:', atomOnChain)
// Returns [walletAddress, vaultId, atomData]
```

## Creating Triples

If Atoms are the words in Intuition's global dictionary, Triples are the sentences we create from those words. A Triple connects three Atoms to assert a relationship or fact in the form **[Subject] ‚Äì [Predicate] ‚Äì [Object]**. You can string these sentences together to express any arbitrarily-complex concept, all while retaining a discrete, referenceable structure!

[Learn more about Triples ‚Üí](/docs/primitives/triples)

```typescript
import { createAtomFromString, createTripleStatement } from '@0xintuition/sdk'

// First create three atoms
const subject = await createAtomFromString(
  { walletClient, publicClient, address },
  'Alice'
)

const predicate = await createAtomFromString(
  { walletClient, publicClient, address },
  'knows'
)

const object = await createAtomFromString(
  { walletClient, publicClient, address },
  'Bob'
)

// Create the triple: "Alice knows Bob"
const triple = await createTripleStatement(
  { walletClient, publicClient, address },
  {
    args: [
      subject.state.termId,
      predicate.state.termId,
      object.state.termId
    ],
    value: 1000000000000000000n, // 1 ETH deposit in wei
  }
)

console.log('Triple created:', triple.transactionHash)
```

## Signaling (Staking on Atoms/Triples)

Signals represent the trust, confidence, or relevance that the community assigns to Atoms and Triples in the Intuition knowledge graph. Think of the knowledge graph as a weighted graph where Signal is the weight on each node (Atom) or edge (Triple), indicating how strongly people believe in or care about this information.

[Learn more about Signals ‚Üí](/docs/primitives/signals)

### Deposit (Signal Support)

```typescript
import { deposit } from '@0xintuition/protocol'

// Deposit on an atom or triple vault
const txHash = await deposit(
  { walletClient, publicClient, address },
  {
    args: [
      BigInt(vaultId), // The vault ID (atom or triple)
      BigInt(depositAmount), // Amount in wei
      walletClient.account.address // Receiver address
    ],
    value: BigInt(depositAmount),
  }
)

console.log('Deposited:', txHash)
```

### Redeem (Remove Signal)

```typescript
import { redeem } from '@0xintuition/protocol'

// Redeem from a vault
const txHash = await redeem(
  { walletClient, publicClient, address },
  {
    args: [
      BigInt(vaultId), // The vault ID
      BigInt(sharesToRedeem), // Amount of shares to redeem
      walletClient.account.address, // Receiver address
      walletClient.account.address, // Owner address
    ]
  }
)

console.log('Redeemed:', txHash)
```

### Preview Redeem

Preview how many assets you'll receive when redeeming shares:

```typescript
import { previewRedeem } from '@0xintuition/protocol'

// Preview redeem to see assets received
const assetsToReceive = await previewRedeem(
  { walletClient, publicClient, address },
  { args: [BigInt(vaultId), BigInt(sharesToRedeem)] }
)

console.log('Assets you will receive:', assetsToReceive)
```

## Complete Example Component

```typescript
import { useState } from 'react'
import { useWalletClient, usePublicClient, useChainId } from 'wagmi'
import { createAtomFromString, createTripleStatement } from '@0xintuition/sdk'
import { getMultiVaultAddressFromChainId, deposit } from '@0xintuition/protocol'

function IntuitionQuickstart() {
  const chainId = useChainId()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()
  const [atomId, setAtomId] = useState<string>('')

  const address = getMultiVaultAddressFromChainId(chainId)

  const createAtom = async () => {
    const result = await createAtomFromString(
      { walletClient, publicClient, address },
      'My Cool Idea'
    )
    setAtomId(result.state.termId)
    console.log('Created atom:', result.state.termId)
  }

  const signalAtom = async () => {
    if (!atomId) return

    const depositAmount = 100000000000000000n // 0.1 ETH
    await deposit(
      { walletClient, publicClient, address },
      {
        args: [BigInt(atomId), depositAmount, walletClient.account.address],
        value: depositAmount,
      }
    )
    console.log('Signaled support!')
  }

  return (
    <div>
      <h1>Intuition Quickstart</h1>
      <button onClick={createAtom}>Create Atom</button>
      {atomId && (
        <button onClick={signalAtom}>Signal Support</button>
      )}
    </div>
  )
}
```

## Advanced Concepts

### Batch Create Atoms

Create multiple atoms in a single transaction for efficiency and gas savings:

```typescript
import { batchCreateAtomsFromThings } from '@0xintuition/sdk'

// Batch create multiple atoms at once
const atomData = [
  {
    url: 'https://example.com/project1',
    name: 'Project 1',
    description: 'First amazing project',
    image: 'https://example.com/project1.png',
  },
  {
    url: 'https://example.com/project2',
    name: 'Project 2',
    description: 'Second amazing project',
    image: 'https://example.com/project2.png',
  },
  {
    url: 'https://example.com/project3',
    name: 'Project 3',
    description: 'Third amazing project',
    image: 'https://example.com/project3.png',
  },
]

const result = await batchCreateAtomsFromThings(
  { walletClient, publicClient, address },
  atomData,
  1000000000000000000n // Optional: 1 ETH deposit per atom
)

console.log('Created atoms:', result.state)
console.log('Transaction:', result.transactionHash)
```

### Batch Create Triples

Create multiple triple relationships in a single transaction:

```typescript
import { batchCreateTripleStatements } from '@0xintuition/sdk'

// Assuming you have atom IDs already created
const tripleData = [
  [subjectId1, predicateId1, objectId1], // Triple 1
  [subjectId2, predicateId2, objectId2], // Triple 2
  [subjectId3, predicateId3, objectId3], // Triple 3
]

const result = await batchCreateTripleStatements(
  { walletClient, publicClient, address },
  tripleData,
  1000000000000000000n // Optional: 1 ETH deposit
)

console.log('Created triples:', result.state)
```

### Batch Deposit

Deposit on multiple vaults (atoms or triples) in a single transaction:

```typescript
import { batchDepositStatement } from '@0xintuition/sdk'

// Deposit on multiple vaults at once
const depositData = [
  [vaultId1, vaultId2, vaultId3], // Vault IDs
  [amount1, amount2, amount3], // Amounts in wei
  [receiverAddress, receiverAddress, receiverAddress], // Receiver addresses
]

const result = await batchDepositStatement(
  { walletClient, publicClient, address },
  depositData
)

console.log('Batch deposit completed:', result.transactionHash)
```

:::tip Gas Optimization
Batch operations significantly reduce gas costs when working with multiple atoms or triples. Instead of paying gas fees for each individual transaction, you pay once for the entire batch.
:::

## Use Cases

Now that you know the basics, explore what you can build:

- **[List Curation & Ranking](/docs/use-cases#list-curation--ranking-systems)** - Create curated lists and reputation systems
- **[Verification & Fraud Protection](/docs/use-cases#verification-and-fraud-protection)** - Build trust and safety mechanisms
- **[Social Platforms](/docs/use-cases#community-owned-social-platforms)** - Portable identities and attestations
- **[Reputation Scores](/docs/use-cases#reputation-scores)** - Context-aware trust scoring
- **[Q&A Platforms](/docs/use-cases#qa-platforms)** - Knowledge sharing with proof
- **[Oracles](/docs/use-cases#oracles)** - Decentralized data feeds

[View all use cases ‚Üí](/docs/use-cases)

## Next Steps

- **[Explore the SDK](/docs/developer-tools/sdks/overview)** - Deep dive into SDK capabilities
- **[Smart Contracts](/docs/developer-tools/contracts/contract-architecture)** - Contract architecture and ABIs
- **[GraphQL API](/docs/developer-tools/graphql-api/overview)** - Query the knowledge graph
- **[Join the Community](/docs/resources/community-and-support)** - Get help and share ideas

---

### File: docs/guides/quickstart/intuition-kits.md


# Intuition Kits

Jump-start your development with our official Intuition kits and resources. These pre-configured templates and official tools provide everything you need to build Intuition-powered applications.

## Official Kits

### Core Development Tools

| Resource | Description | Primary Use |
|----------|-------------|-------------|
| **[intuition-ts](https://github.com/0xIntuition/intuition-ts)** | TypeScript SDK and tools | Main SDK for application development |
| **[intuition-contracts-v2](https://github.com/0xIntuition/intuition-contracts-v2)** | Smart contracts and protocol implementation | Core protocol and contract development |
| **[intuition-rs](https://github.com/0xIntuition/intuition-rs)** | Rust implementation | High-performance applications and services |

### Integration Tools

| Resource | Description | Primary Use |
|----------|-------------|-------------|
| **[intuition-mcp-server](https://github.com/0xIntuition/intuition-mcp-server)** | MCP server implementation | AI integration and model context protocol |

### Documentation & Ecosystem

| Resource | Description |
|----------|-------------|
| **[intuition-docs](https://github.com/0xIntuition/intuition-docs)** | Documentation and guides |

## Getting Started with Official Resources

### TypeScript SDK (intuition-ts)
The official TypeScript SDK provides the core functionality for interacting with the Intuition protocol:

```bash
# Install the SDK
npm install @0xintuition/sdk

# Basic usage
import { createAtomFromString } from '@0xintuition/sdk'

const config = {
  walletClient,
  publicClient,
  ethMultiVaultAddress
}

const result = await createAtomFromString(config, 'Hello World')
```

### Smart Contracts (intuition-contracts-v2)
The protocol implementation includes all necessary smart contracts:

```bash
# Clone the contracts repository
git clone https://github.com/0xIntuition/intuition-contracts-v2.git
cd intuition-contracts-v2

# Install dependencies
npm install

# Compile contracts
npm run compile
```


## Community Kits

### Coming Soon

Community-built kits and templates will be available here soon. We're working on creating a platform for the Intuition community to share their starter kits, templates, and specialized solutions.

Stay tuned for:
- Community-contributed starter kits
- Industry-specific templates
- Specialized use case solutions
- Community showcase and reviews

## Development Workflow

1. **Choose your starting point**: SDK, contracts, or ecosystem tools
2. **Set up your environment**: Configure wallet connections and network settings
3. **Build your application**: Use the SDK to create atoms, triples, and relationships
4. **Test and deploy**: Use the provided testing frameworks and deployment scripts

## Next Steps

- Learn about [Smart Contracts](/docs/developer-tools/contracts) for advanced features
- Check out the [GraphQL API](/docs/developer-tools/graphql-api) for data integration
- Explore the [SDK Guide](/docs/developer-tools/sdks) for application development

Start building with the official Intuition resources and join the community!

---

### File: docs/guides/resources/community-and-support.md


# Community & Support

Connect with the Intuition community, get help, and stay updated with the latest developments.

## Official Channels

<div className="uniform-card-grid">

<a href="https://x.com/0xintuition" target="\_blank" rel="noopener noreferrer" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', justifyContent: 'center', marginBottom: '1.5rem' }}>
<div style={{ width: '60px', height: '60px', borderRadius: '12px', backgroundColor: '#1DA1F2', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
<svg width="32" height="32" viewBox="0 0 24 24" fill="white">
<path d="M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"/>
</svg>
</div>
</div>
<p className="uniform-card-content">
Follow us on X for real-time updates, announcements, and community highlights.
</p>
</div>
</a>

<a href="https://discord.com/invite/0xintuition" target="\_blank" rel="noopener noreferrer" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', justifyContent: 'center', marginBottom: '1.5rem' }}>
<div style={{ width: '60px', height: '60px', borderRadius: '12px', backgroundColor: '#5865F2', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
<svg width="32" height="32" viewBox="0 0 24 24" fill="white">
<path d="M20.317 4.37a19.791 19.791 0 0 0-4.885-1.515a.074.074 0 0 0-.079.037c-.21.375-.444.864-.608 1.25a18.27 18.27 0 0 0-5.487 0a12.64 12.64 0 0 0-.617-1.25a.077.077 0 0 0-.079-.037A19.736 19.736 0 0 0 3.677 4.37a.07.07 0 0 0-.032.027C.533 9.046-.32 13.58.099 18.057a.082.082 0 0 0 .031.057a19.9 19.9 0 0 0 5.993 3.03a.078.078 0 0 0 .084-.028a14.09 14.09 0 0 0 1.226-1.994a.076.076 0 0 0-.041-.106a13.107 13.107 0 0 1-1.872-.892a.077.077 0 0 1-.008-.128a10.2 10.2 0 0 0 .372-.292a.074.074 0 0 1 .077-.01c3.928 1.793 8.18 1.793 12.062 0a.074.074 0 0 1 .078.01c.12.098.246.198.373.292a.077.077 0 0 1-.006.127a12.299 12.299 0 0 1-1.873.892a.077.077 0 0 0-.041.107c.36.698.772 1.362 1.225 1.993a.076.076 0 0 0 .084.028a19.839 19.839 0 0 0 6.002-3.03a.077.077 0 0 0 .032-.054c.5-5.177-.838-9.674-3.549-13.66a.061.061 0 0 0-.031-.03zM8.02 15.33c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.956-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.956 2.418-2.157 2.418zm7.975 0c-1.183 0-2.157-1.085-2.157-2.419c0-1.333.955-2.419 2.157-2.419c1.21 0 2.176 1.096 2.157 2.42c0 1.333-.946 2.418-2.157 2.418z"/>
</svg>
</div>
</div>
<p className="uniform-card-content">
Join our Discord community for discussions, support, and real-time collaboration.
</p>
</div>
</a>

<a href="https://www.youtube.com/@0xIntuition" target="\_blank" rel="noopener noreferrer" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', justifyContent: 'center', marginBottom: '1.5rem' }}>
<div style={{ width: '60px', height: '60px', borderRadius: '12px', backgroundColor: '#FF0000', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
<svg width="32" height="32" viewBox="0 0 24 24" fill="white">
<path d="M23.498 6.186a3.016 3.016 0 0 0-2.122-2.136C19.505 3.545 12 3.545 12 3.545s-7.505 0-9.377.505A3.017 3.017 0 0 0 .502 6.186C0 8.07 0 12 0 12s0 3.93.502 5.814a3.016 3.016 0 0 0 2.122 2.136c1.871.505 9.376.505 9.376.505s7.505 0 9.377-.505a3.015 3.015 0 0 0 2.122-2.136C24 15.93 24 12 24 12s0-3.93-.502-5.814zM9.545 15.568V8.432L15.818 12l-6.273 3.568z"/>
</svg>
</div>
</div>
<p className="uniform-card-content">
Watch video recordings, tutorials, and community content on our YouTube channel.
</p>
</div>
</a>

<a href="https://medium.com/0xintuition" target="\_blank" rel="noopener noreferrer" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', justifyContent: 'center', marginBottom: '1.5rem' }}>
<div style={{ width: '60px', height: '60px', borderRadius: '12px', backgroundColor: '#00AB6C', display: 'flex', alignItems: 'center', justifyContent: 'center' }}>
<svg width="32" height="32" viewBox="0 0 24 24" fill="white">
<path d="M13.54 12a6.8 6.8 0 01-6.77 6.82A6.8 6.8 0 010 12a6.8 6.8 0 016.77-6.82A6.8 6.8 0 0113.54 12zM20.96 12c0 3.54-1.51 6.42-3.38 6.42-1.87 0-3.39-2.88-3.39-6.42s1.52-6.42 3.39-6.42 3.38 2.88 3.38 6.42M24 12c0 3.17-.53 5.75-1.19 5.75-.66 0-1.19-2.58-1.19-5.75s.53-5.75 1.19-5.75C23.47 6.25 24 8.83 24 12z"/>
</svg>
</div>
</div>
<p className="uniform-card-content">
Read our latest articles, insights, and technical deep-dives on Medium.
</p>
</div>
</a>

</div>

## Support Channels

<div className="uniform-card-grid-small">

<a href="mailto:support@intuition.systems" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', alignItems: 'center', marginBottom: '1rem' }}>
<div style={{ width: '40px', height: '40px', borderRadius: '8px', backgroundColor: '#6366F1', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '1rem' }}>
<svg width="20" height="20" viewBox="0 0 24 24" fill="white">
<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"/>
</svg>
</div>
<h3 style={{ margin: 0 }}>General Support</h3>
</div>
<p className="uniform-card-content">
Get general support and assistance for questions about Intuition.
</p>
</div>
</a>

<a href="https://www.intuition.systems" target="\_blank" rel="noopener noreferrer" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', alignItems: 'center', marginBottom: '1rem' }}>
<div style={{ width: '40px', height: '40px', borderRadius: '8px', backgroundColor: '#F59E0B', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '1rem' }}>
<svg width="20" height="20" viewBox="0 0 24 24" fill="white">
<path d="M12 2l3.09 6.26L22 9.27l-5 4.87 1.18 6.88L12 17.77l-6.18 3.25L7 14.14 2 9.27l6.91-1.01L12 2z"/>
</svg>
</div>
<h3 style={{ margin: 0 }}>Website</h3>
</div>
<p className="uniform-card-content">
Visit our official website for the latest updates, information, and resources.
</p>
</div>
</a>

</div>

## Feedback & Improvement

<div className="uniform-card-grid-small">

<a href="https://github.com/0xintuition" target="\_blank" rel="noopener noreferrer" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', alignItems: 'center', marginBottom: '1rem' }}>
<div style={{ width: '40px', height: '40px', borderRadius: '8px', backgroundColor: '#333', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '1rem' }}>
<svg width="20" height="20" viewBox="0 0 24 24" fill="white">
<path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
</svg>
</div>
<h3 style={{ margin: 0 }}>GitHub</h3>
</div>
<p className="uniform-card-content">
Contribute to our open-source projects, report issues, and suggest improvements.
</p>
</div>
</a>

<a href="mailto:feedback@intuition.systems" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>

<div className="uniform-card clickable-card">
<div style={{ display: 'flex', alignItems: 'center', marginBottom: '1rem' }}>
<div style={{ width: '40px', height: '40px', borderRadius: '8px', backgroundColor: '#8B5CF6', display: 'flex', alignItems: 'center', justifyContent: 'center', marginRight: '1rem' }}>
<svg width="20" height="20" viewBox="0 0 24 24" fill="white">
<path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/>
</svg>
</div>
<h3 style={{ margin: 0 }}>Feedback</h3>
</div>
<p className="uniform-card-content">
Share your feedback, suggestions, and ideas to help improve Intuition.
</p>
</div>
</a>

</div>

---

### File: docs/guides/resources/faq.md


# FAQ

This page is organized into expandable sections for easy navigation. Click on any section below to explore the questions within that category.

<details>
<summary><strong>Getting Started</strong> - Basic information about Intuition and how to begin</summary>

## Getting Started

### What is Intuition?

Intuition is a decentralized protocol that enables the creation of trustful interactions through atomic primitives. It provides a foundation for building decentralized applications that can establish and maintain trust between parties without centralized intermediaries.

The protocol uses atomic primitives (atoms, triples, signals, and bonding curves) to create trustful interactions. These primitives can be combined to build complex decentralized applications that maintain trust through cryptographic proofs and economic incentives.

### How do I get started with Intuition?

**Step 1: Read the Documentation**  
Start with the [Introduction](/docs/introduction) and [Overview](/docs/introduction/overview) guides to understand the core concepts.

**Step 2: Connect to Testnet**  
Visit the [Intuition Hub](/docs/hub) to access the testnet and get your development environment set up.

**Step 3: Set up Development Environment**  
Install the necessary SDKs and tools for your preferred programming language.

**Step 4: Build Your First App**  
Follow the tutorials to create a simple application using Intuition primitives.

**Step 5: Join the Community**  
Connect with other developers and get support through our community channels.

### What are the main components of Intuition?

**Atoms**: The basic units of trust and reputation - unique identifiers for any entity (people, concepts, products)

**Triples**: Relationships between atoms that encode trust - structured as Subject ‚Üí Predicate ‚Üí Object

**Signals**: Mechanisms for updating trust relationships - actions that express intent, belief, or support

**Bonding Curves**: Economic models for token pricing and liquidity - automated market making for application tokens

</details>

<details>
<summary><strong>Development & Integration</strong> - Programming languages, integration, and deployment</summary>

## Development & Integration

### What programming languages are supported?

Intuition supports multiple programming languages through various SDKs:

- **JavaScript/TypeScript**: Official SDK with full feature support
- **Python**: Python SDK for backend development
- **Rust**: Low-level SDK for performance-critical applications
- **Go**: Go SDK for server-side applications

### How do I connect to the Intuition testnet?

**Step 1: Access the Hub**  
Visit the [Intuition Hub](/docs/hub) at [intuition-testnet.hub.caldera.xyz](https://intuition-testnet.hub.caldera.xyz/) for centralized access to all Intuition L3 network services.

**Step 2: Configure Your Wallet**  
Add the Intuition testnet to your wallet using the network details provided in the hub dashboard. The hub will display the current Chain ID and RPC URL.

**Step 3: Get Test Tokens**  
Use the built-in faucet available in the hub to obtain test tokens for development and testing.

**Step 4: Explore Services**  
Access the [Bridge](/docs/hub/bridge) for cross-chain transfers, [Explorer](/docs/hub/explorer) for blockchain exploration, and monitor network status through the status page.

### How do I integrate Intuition into my existing app?

**Step 1: Install SDK**  
Add the appropriate Intuition SDK to your project using your package manager.

**Step 2: Configure Connection**  
Set up connection to the Intuition testnet first using the network details from the [Hub](/docs/hub).

**Step 3: Implement Primitives**  
Use atoms, triples, signals, and bonding curves in your application logic.

**Step 4: Test Integration**  
Thoroughly test your integration on testnet before production deployment.

### How do I deploy an application?

**Step 1: Develop Your App**  
Build your application using Intuition primitives and follow best practices.

**Step 2: Test on Testnet**  
Use the [Intuition testnet](/docs/hub) to thoroughly test your application before mainnet deployment. Access all testnet services through the hub.

**Step 3: Deploy Contracts**  
Deploy your smart contracts to the network using the appropriate deployment tools. Start with testnet deployment first.

**Step 4: Launch Application**  
Make your application available to users and monitor its performance using the network monitoring tools.

### What are the best practices for building with Intuition?

**Start Simple**: Begin with basic primitives before building complex systems to understand the fundamentals.

**Test Extensively**: Use the [Intuition testnet](/docs/hub) for all development and testing to avoid costly mistakes. Access the full testing infrastructure through the hub.

**Follow Security Guidelines**: Implement proper security measures and follow established patterns. Review our [security audits](/docs/resources/audits) for best practices.

**Document Your Code**: Maintain clear documentation for your applications to help other developers.

**Monitor Applications**: Use the network monitoring tools to track your application's performance and catch issues early.

</details>

<details>
<summary><strong>Economics & Rewards</strong> - Token economics, bonding curves, and earning rewards</summary>

## Economics & Rewards

### How does the token economics work?

Intuition uses a dual-token system:

**INTUITION**: The main network token used for staking, governance, and network security.

**Application Tokens**: Specific to individual applications for their economic models and bonding curves.

The system provides automated market making and liquidity for application tokens, enabling dynamic pricing and efficient token distribution through bonding curves.

### How can I earn rewards?

**Staking**: Stake INTUITION tokens to earn rewards and participate in network security.

**Running Nodes**: Operate network nodes to earn block rewards and contribute to decentralization.

**Building Applications**: Create successful applications that generate fees and provide value to users.

**Contributing**: Participate in governance and development to help shape the protocol's future.

### What are bonding curves?

Bonding curves are mathematical functions that determine token pricing based on supply and demand. They provide:

- **Automated Market Making**: Continuous liquidity without traditional market makers
- **Dynamic Pricing**: Token prices that automatically adjust based on supply and demand
- **Efficient Distribution**: Fair token distribution through mathematical models
- **Liquidity Provision**: Built-in liquidity for application tokens

</details>

<details>
<summary><strong>Troubleshooting & Support</strong> - Common issues and getting help</summary>

## Troubleshooting & Support

### How do I handle errors and edge cases?

**Implement Error Handling**: Add comprehensive error handling to your applications to gracefully handle failures.

**Use Fallback Mechanisms**: Implement fallbacks for critical operations to ensure reliability.

**Monitor Applications**: Set up monitoring and alerting for your applications to catch issues early.

**Plan for Upgrades**: Design your applications to be upgradeable as the protocol evolves.

### What if I can't connect to the testnet?

If you're having trouble connecting to the Intuition testnet, try these troubleshooting steps:

**Check Network Configuration**  
Verify that your wallet is configured with the correct network details from the [Hub dashboard](/docs/hub). The Chain ID and RPC URL should match exactly.

**Check Network Status**  
Visit the network status page to see if there are any ongoing issues with the testnet services.

**Clear Wallet Cache**  
Try clearing your wallet's cache or switching to a different RPC endpoint if multiple are available in the hub.

**Check Firewall/VPN**  
Ensure your firewall or VPN isn't blocking connections to the testnet endpoints.

### What if my transaction fails?

If your transaction fails, check your wallet to confirm whether your tokens have been returned. In most cases, failed transactions automatically result in the tokens being returned to your wallet.

Common causes of transaction failures:

- **Insufficient Gas**: Ensure you have enough gas for the transaction
- **Network Congestion**: Try again during less busy periods
- **Incorrect Parameters**: Double-check all transaction parameters before signing
- **Network Issues**: Check the Hub for any ongoing L3 network problems

### How do I get help and support?

**Community Support**: Join our [Discord](https://discord.com/invite/0xintuition) for real-time help from the community.

**Documentation**: Check our comprehensive [documentation](/docs) for detailed guides and tutorials.

**GitHub**: Report issues and contribute to the project on [GitHub](https://github.com/0xintuition).

**Email Support**: Contact us directly at [support@intuition.systems](mailto:support@intuition.systems) for technical assistance.

</details>

<details>
<summary><strong>Use Cases & Contributing</strong> - Applications and ecosystem participation</summary>

## Use Cases & Contributing

### What are the main use cases for Intuition?

**Knowledge Curation**: Build applications that help users discover and verify information through community consensus.

**Social Platforms**: Create decentralized social networks with built-in reputation and trust systems.

**Trust & Reputation**: Develop verifiable reputation systems that work across platforms and applications.

**Verification & QA**: Use collective intelligence to verify and validate any type of information or claim.

**Prediction Markets**: Build prediction markets with built-in verification and community consensus.

**Business & Professional Platforms**: Create platforms that verify professional credentials and facilitate trusted business relationships.

### How do I contribute to the Intuition ecosystem?

**Develop Applications**: Build applications that leverage Intuition's primitives and contribute to the ecosystem.

**Improve Documentation**: Help improve our documentation by suggesting edits or contributing new guides.

**Participate in Governance**: Stake tokens and participate in protocol governance decisions.

**Report Issues**: Help improve the protocol by reporting bugs and suggesting improvements.

**Community Building**: Help grow the community by answering questions and mentoring new developers.

</details>

## Need More Help?

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '2rem', borderRadius: '12px', marginTop: '2rem', textAlign: 'center' }}>
<h3 style={{ marginTop: 0, marginBottom: '1rem' }}>Can't find what you're looking for?</h3>
<p style={{ margin: '0 0 1.5rem 0', color: 'var(--ifm-color-emphasis-700)' }}>
We're here to help! Reach out to our community or support team for assistance.
</p>
<div style={{ display: 'flex', gap: '1rem', justifyContent: 'center', flexWrap: 'wrap' }}>
<a href="/docs/resources/community-and-support" style={{ 
  backgroundColor: 'transparent', 
  color: 'var(--ifm-color-primary)', 
  padding: '0.75rem 1.5rem', 
  borderRadius: '6px', 
  textDecoration: 'none', 
  fontWeight: '500',
  border: '1px solid var(--ifm-color-primary)',
  display: 'inline-flex',
  alignItems: 'center',
  transition: 'all 0.2s ease'
}}>
Join Community
</a>
<a href="mailto:support@intuition.systems" style={{ 
  backgroundColor: 'transparent', 
  color: 'var(--ifm-color-primary)', 
  padding: '0.75rem 1.5rem', 
  borderRadius: '6px', 
  textDecoration: 'none', 
  fontWeight: '500',
  border: '1px solid var(--ifm-color-primary)',
  display: 'inline-flex',
  alignItems: 'center',
  transition: 'all 0.2s ease'
}}>
Contact Support
</a>
</div>
</div> 

---

### File: docs/guides/resources/index.mdx


# Resources

Essential resources for working with Intuition, including key terminology, frequently asked questions, community support, utilities, and audit reports.

## What's Inside

Our resources provide comprehensive support for developers and users working with Intuition:

<div className="uniform-card-grid">

<a href="/docs/resources/key-terms" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>
<div className="uniform-card clickable-card">
<h3 className="uniform-card-title">Key Terms</h3>
<p className="uniform-card-content">
Master the essential terminology and concepts that form the foundation of the Intuition ecosystem. Understanding these terms is crucial for working effectively with Intuition.
</p>
</div>
</a>

<a href="/docs/resources/faq" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>
<div className="uniform-card clickable-card">
<h3 className="uniform-card-title">FAQ</h3>
<p className="uniform-card-content">
Find answers to frequently asked questions about Intuition. From basic concepts to advanced implementation details, get quick answers to common questions.
</p>
</div>
</a>

<a href="/docs/resources/network-health" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>
<div className="uniform-card clickable-card">
<h3 className="uniform-card-title">Network Health</h3>
<p className="uniform-card-content">
Monitor real-time network status, uptime statistics, and service availability. Stay informed about maintenance windows and incident notifications.
</p>
</div>
</a>

<a href="/docs/resources/community-and-support" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>
<div className="uniform-card clickable-card">
<h3 className="uniform-card-title">Community & Support</h3>
<p className="uniform-card-content">
Connect with the Intuition community and get help when you need it. Join discussions, get support, and collaborate with other developers.
</p>
</div>
</a>

<a href="/docs/resources/utilities" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>
<div className="uniform-card clickable-card">
<h3 className="uniform-card-title">Utilities</h3>
<p className="uniform-card-content">
Useful tools and utilities for working with Intuition. Discover helpful resources, tools, and scripts to enhance your development workflow.
</p>
</div>
</a>

<a href="/docs/resources/audits" style={{ textDecoration: 'none', color: 'inherit', display: 'block' }}>
<div className="uniform-card clickable-card">
<h3 className="uniform-card-title">Security Audits</h3>
<p className="uniform-card-content">
Security audits and best practices for Intuition. Review audit reports and learn about security considerations for building on Intuition.
</p>
</div>
</a>

</div>

---

### File: docs/guides/resources/key-terms.mdx


# Key Terms

This page defines the essential terminology and concepts you need to understand the Intuition protocol. Terms are organized by category to help you quickly find what you're looking for.

## Quick Navigation

This page is organized into expandable sections for easy navigation. Click on any section below to explore the terms within that category.

<div style={{
  display: 'flex',
  flexDirection: 'column',
  gap: '1rem'
}}>

<details style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '8px',
  overflow: 'hidden'
}}>
<summary style={{
  padding: '1rem',
  cursor: 'pointer',
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem',
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: 'none',
  outline: 'none',
  fontSize: '1rem',
  fontWeight: '600',
  color: 'var(--ifm-color-emphasis-900)'
}}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="#3B82F6" style={{ flexShrink: 0 }}>
<path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/>
</svg>
<strong>Core Primitives</strong> - Fundamental building blocks of the Intuition protocol
</summary>

<div style={{ padding: '1.5rem' }}>

## Core Primitives

### **Atoms**

**Atoms** are the fundamental building blocks of the Intuition knowledge graph. Each atom represents a unique entity or concept and points to arbitrary data via a URI.

**Key Characteristics:**
- **Universal Identifiers**: Each atom has a unique identifier across the entire system
- **URI References**: Atoms point to any arbitrary URI (web pages, IPFS hashes, etc.)
- **Economic Units**: Atoms can have economic value through bonding curves
- **Composable**: Atoms can be combined to create more complex structures

**Examples:**
- A person's profile (points to their social media or personal website)
- A smart contract address (points to the contract's metadata)
- A piece of content (points to the actual content file)
- An organization (points to their official website)

### **Triples**

**Triples** represent relationships between atoms, forming the edges of the knowledge graph. Each triple consists of three atoms: a subject, predicate, and object.

**Structure:**
```
Subject ‚Üí Predicate ‚Üí Object
```

**Key Characteristics:**
- **Semantic Relationships**: Express meaningful connections between entities
- **Economic Value**: Triples can have economic value through bonding curves
- **Verifiable**: All relationships are cryptographically verifiable
- **Composable**: Triples can be combined to create complex knowledge structures

**Examples:**
- **Subject**: Alice (atom)
- **Predicate**: "works for" (atom)
- **Object**: Intuition Systems (atom)

This creates the statement: "Alice works for Intuition Systems"

### **Signals**

**Signals** represent user attestations or endorsements of atoms and triples. They indicate the strength of belief or support for a particular piece of information.

**Key Characteristics:**
- **Economic Weight**: Signals have economic value and can be traded
- **Subjective**: Represent personal beliefs and opinions
- **Aggregatable**: Multiple signals can be combined to show collective sentiment
- **Time-Bound**: Signals can change over time as opinions evolve

**Types of Signals:**
- **Positive Signals**: Endorsements or agreements
- **Negative Signals**: Disagreements or refutations
- **Neutral Signals**: Acknowledgment without taking a position

</div>
</details>

<details style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '8px',
  overflow: 'hidden'
}}>
<summary style={{
  padding: '1rem',
  cursor: 'pointer',
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem',
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: 'none',
  outline: 'none',
  fontSize: '1rem',
  fontWeight: '600',
  color: 'var(--ifm-color-emphasis-900)'
}}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="#3B82F6" style={{ flexShrink: 0 }}>
<path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/>
</svg>
<strong>Economic Components</strong> - Financial and incentive mechanisms
</summary>

<div style={{ padding: '1.5rem' }}>

## Economic Components

### **Bonding Curves**

**Bonding curves** are mathematical functions that determine the price of shares in atoms and triples based on supply and demand. They create economic incentives for information quality.

**Key Functions:**
- **Price Discovery**: Automatically determine fair market value
- **Incentive Alignment**: Reward early adopters of valuable information
- **Liquidity**: Provide continuous trading opportunities
- **Anti-Speculation**: Prevent manipulation through mathematical constraints

**Curve Types:**
- **Pro-Rata Curves**: Linear pricing for stable assets
- **Bonding Curves**: Dynamic pricing that rewards early adopters
- **Custom Curves**: Specialized functions for specific use cases

### **Vaults**

**Vaults** are smart contracts that hold the economic value associated with atoms and triples. They manage deposits, redemptions, and share distribution.

**Key Functions:**
- **Asset Management**: Safely store and manage user deposits
- **Share Distribution**: Mint and burn shares based on economic activity
- **Fee Collection**: Collect small fees to maintain the system
- **Liquidity Provision**: Enable users to enter and exit positions

**Vault Types:**
- **Pro-Rata Vaults**: Traditional vaults with stable pricing
- **Bonding Curve Vaults**: Dynamic vaults with variable pricing
- **Multi-Curve Vaults**: Vaults supporting multiple pricing models

### **Terms**

**Terms** are the conceptual representations of atoms and triples that contain multiple vaults. They represent the underlying semantic meaning regardless of economic implementation.

**Key Characteristics:**
- **Semantic Identity**: Maintains the core meaning across different vaults
- **Economic Flexibility**: Can have multiple vaults with different curves
- **Market Cap Aggregation**: Combines value across all associated vaults
- **Universal Reference**: Provides a stable identifier for the concept

</div>
</details>

<details style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '8px',
  overflow: 'hidden'
}}>
<summary style={{
  padding: '1rem',
  cursor: 'pointer',
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem',
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: 'none',
  outline: 'none',
  fontSize: '1rem',
  fontWeight: '600',
  color: 'var(--ifm-color-emphasis-900)'
}}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="#3B82F6" style={{ flexShrink: 0 }}>
<path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/>
</svg>
<strong>Network Components</strong> - Protocol infrastructure and governance
</summary>

<div style={{ padding: '1.5rem' }}>

## Network Components

### **Trust Protocol**

The **Trust Protocol** is the foundational mechanism that enables trustful interactions through cryptoeconomic incentives. It rewards users for contributing valuable information.

**Core Principles:**
- **Economic Incentives**: Users are rewarded for valuable contributions
- **Quality Signals**: Economic activity indicates information quality
- **Decentralized Curation**: No central authority controls information
- **Transparent Rules**: All mechanisms are open and verifiable

### **Knowledge Graph**

The **Knowledge Graph** is the collective network of atoms, triples, and signals that represents humanity's shared knowledge. It grows organically through user contributions.

**Key Features:**
- **Permissionless**: Anyone can contribute information
- **Verifiable**: All contributions are cryptographically verifiable
- **Composable**: Information can be combined and reused
- **Economic**: Valuable information is economically rewarded

### **Attestations**

**Attestations** are user statements about atoms and triples that contribute to the collective knowledge. They can be positive, negative, or neutral.

**Types of Attestations:**
- **Factual Claims**: Statements about objective reality
- **Opinions**: Subjective beliefs and preferences
- **Endorsements**: Support for existing information
- **Refutations**: Disagreements with existing information

</div>
</details>

<details style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '8px',
  overflow: 'hidden'
}}>
<summary style={{
  padding: '1rem',
  cursor: 'pointer',
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem',
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: 'none',
  outline: 'none',
  fontSize: '1rem',
  fontWeight: '600',
  color: 'var(--ifm-color-emphasis-900)'
}}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="#3B82F6" style={{ flexShrink: 0 }}>
<path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/>
</svg>
<strong>Technical Components</strong> - Developer tools and APIs
</summary>

<div style={{ padding: '1.5rem' }}>

## Technical Components

### **GraphQL API**

The **GraphQL API** provides a unified interface for querying and interacting with the Intuition knowledge graph. It enables efficient data retrieval and real-time updates.

**Key Features:**
- **Real-Time Queries**: Get live data from the knowledge graph
- **Flexible Schema**: Query exactly the data you need
- **Subscription Support**: Receive updates as data changes
- **Batch Operations**: Efficiently process multiple requests

### **SDKs**

**Software Development Kits (SDKs)** provide pre-built tools and libraries for integrating with the Intuition protocol. They simplify common development tasks.

**Available SDKs:**
- **JavaScript/TypeScript SDK**: For web applications
- **React Components**: Pre-built UI components
- **GraphQL Client**: Optimized for Intuition's GraphQL API
- **Smart Contract Interfaces**: For direct blockchain interaction

### **Smart Contracts**

**Smart contracts** are the on-chain components that handle the economic and governance aspects of the Intuition protocol. They ensure transparency and immutability.

**Core Contracts:**
- **EthMultiVault**: Manages deposits, redemptions, and share distribution
- **AtomWallet**: Handles atom and triple creation
- **BondingCurveRegistry**: Manages different curve implementations
- **TrustBonding**: Implements trust-based economic mechanisms

</div>
</details>

<details style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '8px',
  overflow: 'hidden'
}}>
<summary style={{
  padding: '1rem',
  cursor: 'pointer',
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem',
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: 'none',
  outline: 'none',
  fontSize: '1rem',
  fontWeight: '600',
  color: 'var(--ifm-color-emphasis-900)'
}}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="#3B82F6" style={{ flexShrink: 0 }}>
<path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/>
</svg>
<strong>User Roles</strong> - Different ways to participate in the ecosystem
</summary>

<div style={{ padding: '1.5rem' }}>

## User Roles

### **Attestors**

**Attestors** are users who contribute information to the knowledge graph by creating atoms, triples, and signals. They are rewarded for valuable contributions.

**Responsibilities:**
- **Information Creation**: Add new atoms and triples to the graph
- **Quality Assurance**: Provide signals to indicate information quality
- **Community Building**: Participate in knowledge curation
- **Economic Participation**: Engage with bonding curves and vaults

### **Curators**

**Curators** are users who specialize in organizing and validating information within the knowledge graph. They help maintain quality and coherence.

**Activities:**
- **Signal Provision**: Provide economic signals for information quality
- **Relationship Mapping**: Create meaningful triples between atoms
- **Quality Assessment**: Evaluate and endorse valuable information
- **Community Leadership**: Guide discussions and resolve disputes

### **Developers**

**Developers** build applications and tools that interact with the Intuition protocol. They create the interfaces and experiences that make the knowledge graph accessible.

**Development Areas:**
- **Frontend Applications**: User interfaces for interacting with the graph
- **Data Analytics**: Tools for analyzing knowledge graph data
- **Integration Services**: APIs and services that connect to Intuition
- **Mobile Applications**: Native mobile experiences

</div>
</details>

<details style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '8px',
  overflow: 'hidden'
}}>
<summary style={{
  padding: '1rem',
  cursor: 'pointer',
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem',
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: 'none',
  outline: 'none',
  fontSize: '1rem',
  fontWeight: '600',
  color: 'var(--ifm-color-emphasis-900)'
}}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="#3B82F6" style={{ flexShrink: 0 }}>
<path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/>
</svg>
<strong>Economic Terms</strong> - Financial metrics and market concepts
</summary>

<div style={{ padding: '1.5rem' }}>

## Economic Terms

### **Market Cap**

**Market cap** represents the total theoretical value of all shares in a term (atom or triple). It is calculated as the product of total shares and current share price.

**Calculation:**
```
Market Cap = Total Shares √ó Current Share Price
```

**Significance:**
- **Value Indicator**: Shows the perceived value of information
- **Comparison Metric**: Allows comparison between different terms
- **Investment Guide**: Helps users make informed decisions
- **Quality Signal**: Higher market caps often indicate higher quality

### **Share Price**

**Share price** is the current cost to purchase one share of a term. It is determined by the bonding curve function based on supply and demand.

**Factors Affecting Price:**
- **Supply**: Number of shares currently in circulation
- **Demand**: User interest and willingness to pay
- **Curve Function**: Mathematical relationship between supply and price
- **Market Activity**: Recent trading volume and patterns

### **Liquidity**

**Liquidity** refers to the ease with which shares can be bought or sold without significantly affecting the price. High liquidity enables efficient trading.

**Liquidity Factors:**
- **Trading Volume**: Amount of shares traded regularly
- **Market Depth**: Number of buy and sell orders
- **Price Stability**: How much price changes with large trades
- **Accessibility**: How easy it is for users to participate

</div>
</details>

<details style={{
  border: '1px solid var(--ifm-color-emphasis-200)',
  borderRadius: '8px',
  overflow: 'hidden'
}}>
<summary style={{
  padding: '1rem',
  cursor: 'pointer',
  display: 'flex',
  alignItems: 'center',
  gap: '0.75rem',
  backgroundColor: 'var(--ifm-color-emphasis-50)',
  border: 'none',
  outline: 'none',
  fontSize: '1rem',
  fontWeight: '600',
  color: 'var(--ifm-color-emphasis-900)'
}}>
<svg width="12" height="12" viewBox="0 0 24 24" fill="#3B82F6" style={{ flexShrink: 0 }}>
<path d="M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z"/>
</svg>
<strong>Governance Terms</strong> - Protocol governance and decision-making
</summary>

<div style={{ padding: '1.5rem' }}>

## Governance Terms

### **Proposals**

**Proposals** are suggested changes to the Intuition protocol that are voted on by the community. They can include parameter changes, new features, or governance updates.

**Proposal Types:**
- **Parameter Changes**: Adjusting bonding curve parameters
- **Feature Additions**: Adding new functionality to the protocol
- **Governance Updates**: Changing how decisions are made
- **Emergency Actions**: Responding to critical issues

### **Voting**

**Voting** is the process by which the community makes decisions about the protocol. Votes are weighted by economic stake and participation.

**Voting Mechanisms:**
- **Token Weighted**: Votes are proportional to token holdings
- **Time Locked**: Some proposals require time delays
- **Multi-Sig**: Critical decisions require multiple approvals
- **Emergency Powers**: Special procedures for urgent situations

</div>
</details>

</div>


---

### File: docs/guides/use-cases/index.md


![Use Cases](/img/use-cases.png)

This article outlines use cases that take advantage of Intuition's unique knowledge graph and claim infrastructure. There are many more ways to use Intuition (and we would love to see what you come up with!), but here are some ideas to get you started.

## List Curation & Ranking Systems

Intuition can be used to create permissionless, community-curated ranked lists and registries. Anyone can create a list that groups together identities with a common claim about them (such as sharing a common tag, use case, purpose, etc). The list can then be curated by the original uploader and anyone else on the platform by adding additional identities or supporting/opposing each item with a financial stake to change it‚Äôs ranking. Users can filter and sort results from that list to find what matters to them. They can see the global list of everything added by anyone, just their own contributions, or items vetted by people they follow or trust.

- Web3 Ecosystem: Curate trusted smart contracts, addresses, DeFi protocols, memecoins, NFT communities, and Web3 games based on reputation formed by on-chain metadata and user attestations
- AI resources: Find and orchestrate trusted AI agents based on rich metadata and on-chain reputation, know the best models based on community feedback, and train AI with validated data sources and efficiently structured knowledge
- Entertainment and media: Rank top and emerging music, movies, news sources, podcasts, sports teams, and more based on staked TRUST ‚Äúsupport‚Äù positions and attestations from users you follow who share your taste
- Data and Research: Find the most reliable data sources and reports based on peer review attestations and supporting positions from trusted colleagues
- Consumer Products: Find and help rank top-rated consumer products, applications, and more
- Product improvements: Have your community share their top feature requests and bugs to fix so you can prioritize which to tackle first
- Travel: Uncover popular travel destinations through collective recommendations

## Verification and Fraud Protection

Intuition helps trusted experts flag potentially dangerous websites, smart contracts, products, and more using structure claims to help everyday consumers stay safe.

- Decentralized Information Validation: Engage a distributed community to verify and endorse the accuracy and authenticity of any data (e.g. smart contracts, information, packaged good supply chains, images, news, etc)
- Fraud Detection and Alerts: Engage a worldwide team of incentivized auditors and moderators to report potentially dangerous or fraudulent activities, including crypto scams and malicious AI agents, and alert users when they are about to engage with a threat on the Web.
- Curator & Auditor Recognition: Rank individuals‚Äîwhether they're auditing contracts or curating news‚Äîbased on their proficiency, accuracy, and community credibility. This ensures a transparent trajectory in both contract auditing and news curation.

## Community-Owned Social Platforms

Intuition creates on-chain decentralized identities for people and concepts, and allows any account to make verifiable claims about themselves and others. These primitives can form the basis of powerful social networks, driven by publicly visible and searchable graphs of verified connections and attestations.

- Portable On-Chain Identity: Each person on the social network gets a self-sovereign identity, allowing them to own their verifiable data (claims by and about them) and make it portable to any other system, instead of being locked into keeping their data with a single platform.
- Advanced Signaling and Verification: Transform traditional up-vote/down-vote and/or likes/dislikes into attestations, offering richer feedback and community insights for debates, conversations, and more.
- Member Credibility: Promote trust between distributed community members by highlighting verifiable achievements and certifications, providing community reputation attestations and scores, and more.

## Incentivized Ratings and Referrals

Using claims, Intuition can provide on-chain ratings and referrals for media, software, travel destinations, and more. Tastemakers can earn money by being early to place support or oppose financial positions to rate promising items they know their communities will find relevant, capturing fees when subsequent reviewers follow suite.

- Attestation-Backed Ratings: Transition from simplistic star ratings to attestations, ensuring each review reflects a more comprehensive and verified experience
- Transparent Reviewer Profiles: Utilize attestations to validate reviewer authenticity, experience, and expertise, giving more weight to trusted community members' feedback
- Community-Driven Trustworthiness: Allow community members to vouch for or against reviews, enhancing the credibility of feedback and reducing the impact of fraudulent reviews.
- Simple Referrals: Businesses can request referrals for their offerings from tastemakers, rewarding those tastemakers financially when others catch on, place their own support position, and make the offering go viral.
- Review Aggregation & Insights: Harness the power of structured attestation data to generate summary insights from reviews, helping customers make informed decisions faster and helping businesses understand their strengths and areas of improvement.

## Q&A Platforms

Question and answer platforms can yield results from structured knowledge sharing, support/oppose positions on claims, and in-depth identity and reputation for each participant.

- Claiming Expertise: Users self-attest areas of knowledge, setting the stage for their contributions and peer review.
- Community Attestations: Peer validation of answers allows for real-time quality & sentiment checks.
- Verification: Answer validation is reinforced by the wisdom of the crowd, balancing answer credibility.
- Reputation Building: Continuous positive attestations lead to a trustworthy reputation score, distinguishing genuine experts from the crowd.

## Reputation scores

Intuition facilitates both financial and social signals about identities and claims to help people construct their own sense of reputation for things they encounter. From these primitives, third-party developers can construct reputation scores that make this contextual trust easy to interpret.

- Trustworthiness Index: Evaluate entities based on their past track record and overarching  conduct within different contexts.
- Platform Credibility: Prioritize platforms known for specific things - such as undercollateralized lending - spotlighting those with a track record for precise credit evaluations.
- Credit Scoring: Harness the transparency of blockchain for decentralized credit scores, presenting a holistic and immutable snapshot of an individual's or entity's lending history.
- Lending Confidence: Empower lenders to confidently engage in undercollateralized loans, underpinned by clear and transparent Web3 credit reputation metrics.

## Oracles

Decentralized applications can use on-chain claims made by trusted accounts managed by people or secure bots (or a combination of these entities and their collective opinions) in Intuition to trigger other on-chain events.

- Consensus Result Extraction: Derive a data beacon or collective answer based on the weight and credibility of aggregated attestations, and use it to provide triggers for smart contract logic.
- Censorship Resistance: Define trust so that any entity that fits the criteria can support dApps with reliable information to guide actions, free of censorship.

## Business, Employment & Consulting Platforms

Companies and consultancies, as well as the people who work for them, can use decentralized identifiers and claims made by those that have done business with them to determine whether their potential collaborators are trustworthy and fit for the task at hand.

- Professional Credibility: Evaluate the authenticity of individuals, organizations, and services based on proven credentials.
- Expertise Showcase: Verify the skills, experiences, and specializations of consultants to match with appropriate projects or clients.
- Credential-Based Products: Incorporate platforms enhanced with reputation systems to assess credibility and reliability in the consulting domain.
- Collaborative Experiences: Attest to the quality and outcome of consulting projects and share insights from fruitful partnerships.
- Consultation Metrics: Utilize advanced tools and analytics to measure the impact and effectiveness of consulting services offered.
- Transparent Feedback Loop: Allow clients to provide feedback on consulting services, ensuring continual improvement and trust-building in the community.

## Verified Voting

Verified community members can create proposals as identities, then allow other community members to make claims about those proposals with evidence, support or oppose the proposals, or rank the proposals in a list to signal what the community should handle next.

- Identity Assurance: Implement mechanisms to ensure that each vote is tied to a verified identity, eliminating duplicate votes and ensuring transparency.
- Hackathon Judging: Accurately capture and reflect community votes to determine hackathon winners and associated projects, fostering a fair competitive environment.
- DAO Proposal Voting: Promote permissionless executions grounded in community consensus and sentiment, enabling decentralized decisions with integrity.
- Vote Attestation: Allow members to vouch for or challenge voting results, adding an additional layer of community-backed verification to the process.
- Reputation-Based Voting Power: Adjust the weight of votes based on the track record and credibility of members, ensuring experienced voices have a significant say.

## Trading Knowledge

Intuition can help surface knowledgable market voices, and even gather intelligence on bullish opportunities through curated lists of assets with support or oppose positions to signal their attractiveness as an investment.

- Evaluate and ascertain the credibility of traders or investors based on historical decisions, profitability, and ethical behavior.
- Assess and rank trading/investment platforms using community-driven reviews, transaction success rates, and security protocols.
- Determine the trustworthiness of diverse investment assets through community ratings, feedback, and historical performance benchmarks.

## Verifiable Predictions, Claims & Forecasting

Intuition can help people signal what they believe will happen next or be advantageous in the future, making early verifiable claims about events or opportunities and putting financial positions behind them to communicate their certainty. These claims and commitments can be used by others who need to decide what‚Äôs most likely to happen in the future, like a perpetual, non-resolving prediction market.

- Know Your Futurist: Elevate trusted voices whose foresight consistently aligns with events and who posses domain knowledge, emphasizing their expertise within the community.
- Provable Track Records: Assess past predictions in the form of claims from thought leaders in Intuition, including any financial stake they placed on the prediction, to determine their likelihood of correctly predicting future events.

---

### File: docs/partials/_product-section.mdx


---

