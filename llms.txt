# Intuition Protocol Documentation

This file contains essential documentation for the Intuition protocol - a system for building context-aware, human-readable blockchain applications through semantic triples.

## Overview

Intuition is a permissionless protocol that enables users to create claims (atoms), make connections between concepts (triples), and signal agreement or disagreement through staking mechanisms. The protocol creates a knowledge graph of validated information that can be queried and used by applications.

## Core Concepts

### Atoms
Atoms are the fundamental building blocks - individual claims or pieces of information stored on-chain. They can represent anything: identities, statements, data, or concepts.

### Triples
Triples connect atoms in subject-predicate-object relationships, creating meaningful connections between concepts. For example: "Alice - works at - Company" where each element is an atom.

### Signal
Users can signal agreement (staking) or disagreement with atoms and triples, creating economic incentives for accurate information through bonding curves.


## Essential Documentation

### Overview.md
.md
.mdx


# Overview

## Intuition at a Glance

<div style={{ backgroundColor: 'var(--ifm-color-emphasis-50)', padding: '2rem', borderRadius: '12px', marginBottom: '2rem' }}>
<p style={{ fontSize: '1.25rem', lineHeight: '1.8', margin: '0 0 1rem 0', color: 'var(--ifm-color-emphasis-800)', fontWeight: '500' }}>
Intuition is a decentralized system that makes attestations viable as a meta for digital expression. 

A universal language for signed data.

Instead of information living as unstructured, siloed, minimally-attributable data in Web2 platforms, Intuition turns information into verifiable, tokenized, and portable objects that can flow across apps, chains, and agents.
</p>
<p style={{ fontSize: '1.1rem', lineHeight: '1.7', margin: 0, color: 'var(--ifm-color-emphasis-900)' }}>
<strong>The result is a Semantic Web of Trust, powered the world's first token-curated knowledge graph</strong> — a network where information isn't just stored, but structured, incentivized, and made usable for developers and AI systems alike — all while maintaining verifiable provenance and attribution.
</p>
</div>


### Why Intuition.md
.md
.mdx


# Why Intuition?

> **Every interaction online is an attestation.**
> A review or a purchase on Amazon, a comment on Reddit, the watching of a show on Netflix, a retweet, a LinkedIn endorsement, a 'follow', a bookmark, the ordering of an Uber, even a "like" — all are forms of attestations: claims made by things about things.

But attestations today are fragmented, unverifiable, and platform-locked. They don't move with you. They don't carry weight. They aren't semantically structured and unambiguously consumable by machines.

**Intuition changes that.** We've rebuilt attestations as first-class, tokenized primitives — structured, portable, and economically backed. _Attestations on steroids._

## Decentralizing Information with Attestations

**Blockchains decentralized money.
Intuition decentralizes information — by offering next-generation attestation infrastructure.**

An attestation in Intuition isn't just a line of text. It's:

- **Verifiable** — signed and attributable
- **Ownable** — belongs to the creator, not a platform
- **Discoverable** — structured as a Triple (subject → predicate → object)
- **Valuable** — backed by economic incentives through bonding curves

This turns the messy stream of human expression into a global knowledge substrate that's actually useful to developers, communities, and AI agents.

## Information Finance: Attestations as Assets

Intuition pioneers **Information Finance (InfoFi)**: the idea that information can be valued and exchanged just like money.

- **Ideas become assets** — an attestation isn't just data, it's collateralized
- **Reputation becomes capital** — your attestations are your portfolio of credibility
- **Knowledge flows freely** — attestations aren't siloed; they're cross-platform and composable

Attestations are no longer passive byproducts of online activity — they're programmable building blocks for apps and agents.

## The $200 Trillion Problem

The global knowledge economy is worth over **$200 trillion**, yet:

- Most of its value is created by individuals
- Less than 1% of that value flows back to the creators
- Instead, tech monopolies capture and silo it

**The result:** broken rails, misinformation, and AI systems consuming oceans of low-quality data without provenance.

Attestations are the missing rails. When data becomes signed, tokenized, and portable, it allows value to flow back to contributors and trust to flow into the systems that need it most.

## Rebuilding the Rails of Knowledge

Intuition makes attestations first-class protocol objects. That means:

- **Facts, claims, and perspectives** are all structured as attestations
- **Credibility is collateralized** — good attestations earn rewards; bad ones cost you stake
- **Distribution is programmatic** — attestations move frictionlessly across apps, chains, and agents

Think of it as the Ethereum moment for knowledge: where attestations flow as freely as tokens, powering new classes of decentralized infrastructure.

## Programmatic Monetization and Distribution

Attestations aren't just portable — they're **monetizable**.

With Intuition, every attestation can plug into programmatic distribution rails:

- Censorship-resistant search and discovery
- Verifiable knowledge bases
- Open data marketplaces
- Training sets for AI agents

Each attestation carries weight, liquidity, and discoverability, ensuring no single platform can gate what's visible or valuable.

## From Information → Intuition

Why does this matter? Because **raw information without provenance is noise.**

Attestations, structured and economically backed, create a higher-resolution understanding of the world. They transform scattered data into collective intuition — fueling smarter AI, safer markets, and more confident human decision-making.

## Reviving the Semantic Web with Crypto-Economic Consensus

The Semantic Web failed because it required global consensus on standards without incentives to achieve it. Different organizations created competing schemas, vocabularies fragmented, and there was no mechanism to converge on shared identifiers.

**Intuition solves this with crypto-economics** — the same force that achieves distributed consensus in blockchains now drives semantic standardization:

- **Incentivized identifiers** — stake on canonical IDs for entities, creating economic pressure toward convergence
- **Market-driven standards** — the most useful data structures attract the most stake and become de facto standards
- **Emergent interoperability** — economic incentives naturally align participants toward compatible schemas
- **Consensus through collateralization** — disagreements resolve through staking, not committees

Where the Semantic Web asked the world to voluntarily agree on standards, Intuition makes consensus profitable. Attestations become the economic glue that binds distributed actors to shared semantic structures.

## How It Works: Skin in the Game

On Intuition, every attestation has consequences:

- **Publish a useful attestation** → earn reputation and rewards
- **Publish misinformation** → lose your stake and credibility
- **Signal strong conviction** → stake more on your attestation
- **Build trust** → accumulate a reputation that travels with you
- **Use consensus identifiers** → earn more by aligning with the network
- **Fork data structures** → lose money by fragmenting liquidity

This flips today's internet incentives: no longer "reward the loudest," but reward the most credible and interoperable attestations.

### The Fork Choice Rule for Data

Just like blockchains have fork choice rules that determine the canonical chain, Intuition creates economic pressure toward canonical identifiers and data structures. **When you use consensus identifiers, you tap into existing liquidity pools and network effects. When you create competing forks, you isolate yourself economically.**

**Example:** Imagine two identifiers for "Ethereum":
- **Identifier A**: Used by 10,000 attestations with $1M total stake
- **Identifier B**: Used by 50 attestations with $5K total stake

If you make an attestation about Ethereum:
- Using **Identifier A** → Your attestation joins a liquid market, benefits from network effects, earns higher rewards
- Using **Identifier B** → Your attestation is isolated, has minimal visibility, earns negligible rewards

The economic incentive is clear: converge on consensus or pay the price. This same dynamic applies to data structures, schemas, and semantic relationships. The network naturally evolves toward maximum interoperability because **consensus literally pays.**

## Digital Sovereignty and Data Ownership

**Your attestations are yours.** Not Facebook's, not LinkedIn's, not OpenAI's.

- You **own** them
- You **control** who can access them
- You **capture** the value they generate
- They **travel** with you across every app, chain, or agent

Attestations become the backbone of digital sovereignty.

## The Trust Layer for AI

AI doesn't just need more data — it needs **verifiable attestations about data**:

- Who said it
- With what reputation
- With what conviction

Intuition provides the trust graph of attestations. AI systems can finally ground themselves in data with provenance, weights, and economic signals — not just raw text.

This makes AI more reliable while ensuring humans share in the value of the knowledge they produce.

## What You Can Build

By treating attestations as programmable primitives, you can create:

- **Verifiable identity systems**
- **Reputation networks** powered by attestations
- **Decentralized fact-checking** with stakes
- **AI agents** that reason over attestations as context
- **Information markets** where attestations themselves are the assets

## Join the Movement

Intuition is about reclaiming the internet by giving attestations real weight.

Whether you're a developer, researcher, or community builder, your contributions aren't just ephemeral posts — they're portable, valuable attestations that strengthen the global knowledge graph.

**Together, we can rebuild the web around truth, attribution, and trust.**

### Overview.md
.md
.mdx


import BrowserOnly from '@docusaurus/BrowserOnly';
import ExcalidrawViewer from '@site/src/components/ExcalidrawViewer';

# Primitives Overview

Intuition's data model is built on three fundamental primitives that work together to create a rich, self-regulating knowledge graph:

<div className="uniform-card-grid">

<div className="uniform-card">
<h2 className="uniform-card-title">Atoms</h2>
<p className="uniform-card-content">
The basic entities or identifiers - unique decentralized identifiers for everything in existence. Think of them as the <strong>nodes</strong> in the knowledge graph, or the <strong>words</strong> in the dictionary.
</p>
</div>

<div className="uniform-card">
<h2 className="uniform-card-title">Triples</h2>
<p className="uniform-card-content">
Structured relationships or claims linking entities together in Subject-Predicate-Object format. These are the <strong>edges</strong> in the knowledge graph / the <strong>sentences</strong> in the language of Intuition.
</p>
</div>

<div className="uniform-card">
<h2 className="uniform-card-title">Signals</h2>
<p className="uniform-card-content">
The weight of trust or consensus behind each entity or claim, determined by community staking. These represent the <strong>edge weights</strong> in the graph, or 'who is saying what about what, with what level of conviction'.
</p>
</div>

</div>


### Atoms.md
.md
.mdx


import BrowserOnly from '@docusaurus/BrowserOnly';
import ExcalidrawViewer from '@site/src/components/ExcalidrawViewer';

# Atoms

Atoms are the foundational building blocks of Intuition's knowledge graph – the words in our global dictionary. Think of Intuition as a vast, collaborative dictionary where anyone can create a new word, and each word has its own globally persistent, unique digital identifier that can be used to reference it across the entire internet!

## Understanding Atoms

In the spirit of the Semantic Web and linked data, an Atom can correspond to virtually anything:

- **People**: User identities, profiles, public figures
- **Organizations**: Companies, DAOs, institutions, projects
- **Addresses**: Cryptocurrency wallets, smart contracts, validators
- **Documents**: Files, articles, research papers, certificates
- **Temporal markers**: Dates, timestamps, time periods
- **Categories**: Tags, classifications, taxonomies
- **Concepts**: Ideas, words, phrases, abstract notions

Each Atom's unique ID is deterministically generated based on its `atomData` field – meaning the same data will always produce the same Atom ID. This ensures that duplicate Atoms cannot be created for identical data, and anyone can independently verify an Atom's ID by hashing its data. This design makes Atoms act as a bridge between on-chain identifiers and the rich context of off-chain data – similar to how an NFT token ID might reference metadata stored elsewhere.

## Technical Architecture

### Core Structure

Under the hood, creating a new Atom mints a tokenized record using the ERC-1155 multi-token standard that includes:

1. **Unique Atom ID**: A permanent, immutable identifier deterministically derived from the atomData
2. **Atom Data**: Can contain any arbitrary data (URIs, text, JSON, references to external resources)
3. **Associated Smart Contract Wallet**: Enabling the Atom itself to own assets and interact with contracts

Every Atom carries `atomData` which can contain any arbitrary information relevant to that entity. For example:
- An Atom for "Solar Energy" might contain a link to a Wikipedia page about solar power
- An Atom for a user's identity might contain a DID document reference or profile JSON
- An Atom for a document might contain an IPFS content hash
- An Atom for a concept might contain a simple text string or structured JSON data

### Staking Vaults and Bonding Curves

Each Atom has one or more Vaults attached to it for staking. These vaults operate on a bonding curve, meaning:

- The cost to acquire a stake (or "share") in an Atom increases as more is already staked
- Early stakers get a larger stake for their investment
- Latecomers pay a premium for popular Atoms

This mechanism incentivizes early discovery of important Atoms and creates a form of priority signaling – the community collectively "bids up" the Atoms deemed valuable or relevant by risking capital in their vaults.

### Atom Creation Process

<BrowserOnly fallback={<p>Loading diagram...</p>}>
  {() => <ExcalidrawViewer src="/excalidraw/atom-creation-diagram.excalidraw.json" zoom={0.3} scrollX={-150} scrollY={650} />}
</BrowserOnly>

## The Problem Atoms Solve


### Universal Reference Standardization

Today's web is siloed – the same entity might be referred to in dozens of different ways across different platforms. Consider how many separate user accounts or content IDs one person might have across various sites.

Intuition's Atoms provide:
- A single, canonical identifier for each real-world thing
- Universal reusability across any application or user
- Easy reconciliation and trust of data from disparate sources
- Automatic deduplication through deterministic ID generation

By converging on a universal set of Atoms, every piece of data about Alice can point to the same Atom `[Alice]`, rather than being scattered across unlinked profiles. Since Atom IDs are deterministically generated from their data, if two users try to create an Atom with identical data, they'll generate the same ID – preventing duplicates at the protocol level.

### Market-Driven Ontology Management

While deterministic IDs prevent exact duplicates, similar concepts might still be represented with slightly different data (e.g., "DeFi" vs "Decentralized Finance"). The protocol employs Token Curated Registry (TCR) logic for these cases:

1. **Competition**: Users tend to stake on the Atom that others find more useful or legitimate
2. **Signal Accumulation**: One variant accrues more Signal and usage over time
3. **Natural Selection**: The preferred Atom wins out as the standard
4. **Economic Incentives**: Early backers of the "winning" Atom are rewarded through vault fees and token emissions

This market-driven approach, combined with deterministic ID generation, ensures the knowledge base converges on canonical representations while preventing exact duplicates.

## Design Principles: Atomic Granularity

### The Power of Flat Data

A crucial best practice is keeping information modular and atomic. You are economically incentivized to create "flatter" Atoms – each representing a single, minimal concept – rather than packing composite information into one Atom.

#### Why Granularity Matters

Consider representing the statement: **"Tiger Research was founded in 2021"**

**❌ Monolithic Approach** (Not Recommended):
```javascript
// One Atom containing all information
const statementAtom = {
  data: "Tiger Research was founded in 2021"
}
```

Problems with this approach:
- Hard to verify which part might be incorrect if disputed
- Cannot reuse individual components
- Difficult to update or correct specific elements
- Less composable with other data

**✅ Atomic Approach** (Best Practice):
```javascript
// Three separate Atoms
const tigerResearchAtom = { data: "Tiger Research" }
const foundedInAtom = { data: "founded in" }
const year2021Atom = { data: "2021" }

// Connected via a Triple
const foundingTriple = {
  subject: tigerResearchAtom,
  predicate: foundedInAtom,
  object: year2021Atom
}
```

Benefits of this approach:
- Each piece can be independently verified and traced
- Individual components are reusable (the `[2021]` Atom can be used in countless other triples)
- Corrections can be made to specific elements without discarding everything
- Trust accrued by each Atom benefits all its usages

### Economic Incentives for Granularity

Intuition's economic model naturally guides users toward optimal granularity:

- **Reusable Atoms** accumulate more Signal as they're referenced in multiple Triples
- **High-Signal Atoms** attract more $TRUST stakes, increasing their network gravity
- **Composite Atoms** with embedded data are less likely to be reused or staked
- **Modular Design** maximizes potential for community adoption and value accrual

## Flexibility and Scope

Atoms are not limited to static concepts. They can represent:

- **Dynamic entities**: User-generated content, evolving documents
- **Abstract concepts**: Tags, categories, classifications
- **Data structures**: JSON schemas, configuration templates
- **Content chunks**: Text snippets, code fragments (via IPFS CID)

Regardless of what an Atom represents, the principles remain consistent:
1. Give it a clear, unique identity
2. Include relevant data in the atomData field
3. Keep its scope narrow for maximum verifiability and reusability

## Best Practices

### Creating Effective Atoms

1. **Leverage Deterministic IDs**: Remember that identical atomData will always produce the same Atom ID
2. **Check for Similar Atoms**: Search for canonical Atoms before creating variations
3. **Use Clear Data**: Choose descriptive, unambiguous data values
4. **Maintain Single Purpose**: Each Atom should represent one thing
5. **Consider Reusability**: Design Atoms others will want to reference

### Atom Design Patterns

Think of Atoms as **words in the Intuition dictionary**:
- They are the lego-like pieces that snap into many contexts
- Community Signal concentrates on the words that matter most
- Triples form the "sentences" that connect these dictionary words together

### Integration with Triples

Atoms gain their true power when connected via Triples:
- **Subject Atoms**: The entity being described
- **Predicate Atoms**: The relationship or property
- **Object Atoms**: The value or target of the relationship

This separation allows each component to be independently verified, updated, and trusted.

## Practical Examples

### Identity Atom
```javascript
const aliceAtom = {
  atomData: "https://alice.id/profile.json",
  id: "atom_0x123...", // Deterministically generated from atomData
  vault: "0xabc...",
  signal: 1500
}
```

### Concept Atom
```javascript
const defiAtom = {
  atomData: {
    name: "DeFi",
    definition: "Decentralized Finance",
    reference: "ipfs://QmX.../defi-definition.json"
  },
  id: "atom_0x456...", // Deterministically generated from atomData
  vault: "0xdef...",
  signal: 8500
}
```

### Relationship Atom (Predicate)
```javascript
const expertInAtom = {
  atomData: "expertIn",
  id: "atom_0x789...", // Deterministically generated from "expertIn"
  vault: "0xghi...",
  signal: 3200
}
```

## Next Steps

With Atoms as your foundation, you can:
- Learn about [Triples](./triples) to create meaningful relationships between Atoms
- Explore [Signals](./signals) to understand attestation and trust mechanics
- Review [Vaults](./vaults) for staking and economic participation
- Check the [SDK Documentation](/docs/developer-tools/sdks/overview) for implementation details

### Triples.md
.md
.mdx


# Triples

If Atoms are the words in Intuition's global dictionary, Triples are the sentences we create from those words. A Triple connects three Atoms to assert a relationship or fact in the form **[Subject] – [Predicate] – [Object]**. You can string these sentences together to express any arbitrarily-complex concept, all while retaining a discrete, referenceable structure!

## Understanding Triples

A Triple is a fundamental data structure that expresses relationships between Atoms, following the classic RDF triple format used in semantic web technologies. This makes Intuition's data inherently machine-readable and structured.

Every Triple represents a claim—it asserts that a Subject has some relationship (Predicate) to an Object. For example:

```
[Alice] -- [livesIn] --> [Paris]
```

This Triple asserts a fact about Alice's location, where:
- **Alice** is the subject Atom
- **livesIn** is the predicate Atom (describing the type of relationship)
- **Paris** is the object Atom

Each component of a Triple is an Atom ID under the hood. The system doesn't store free-form text "Alice" or "Paris" but rather pointers to those Atom records, which might contain rich data, alternate labels, and additional metadata.

## The Graph Structure

Triples naturally form a graph of nodes and links. You can visualize:
- **Atoms as nodes** in the graph
- **Triples as directed edges** from subject to object, labeled by the predicate

This graph structure enables powerful capabilities:
- Deterministic queries like "find all objects that Alice is connected to via livesIn"
- Traversal of relationships to discover indirect connections
- Pattern matching across the knowledge graph

## Why Triples Matter

### Semantic Clarity
By expressing data in Triple format, Intuition ensures relationships are explicit and standardized. Instead of loose text statements like "Alice lives in Paris" (which computers struggle to parse), we have typed links that machines understand: `Alice —livesIn→ Paris`.

### Reconciliation & Interoperability
The clarity of Triples means different data sources referencing the same predicate can be merged or compared easily. This semantic structure makes data immediately useful to other systems—knowledge graphs and AI systems can ingest these subject-predicate-object triples without guessing their meaning.

### Extensibility
Triples are infinitely extensible. New information can be attached in graph form without altering the original nodes. If we later learn "Alice lives in Paris since 2015", we can introduce new Atoms and predicates to capture this additional context through supplementary Triples.

### Composability
The data model is open-ended—you can always extend the graph by adding another Triple rather than modifying existing ones. This is analogous to how one can keep adding facts to Wikipedia.

## Nested Triples: Meta-Claims & Context

One of Intuition's most powerful features is that Triples can reference other Triples, effectively nesting statements to provide context or provenance. Intuition supports using a Triple itself as a Subject or Object in another Triple.

### Example: Disputing a Claim
Consider an initial Triple:
```
[Bob] -- [isFriendOf] --> [Alice]
```

If Alice disagrees with this claim, we can create a nested Triple:
```
[Alice] -- [disproves] --> (Bob isFriendOf Alice)
```

Here, the Object of the second Triple is not an Atom but a reference to the first Triple (identified by its Triple ID). Alice is essentially asserting that the friendship claim is false.

### Adding Evidence & Sources
You can link Triples to evidence or citations:
```
[Triple X] -- [basedOn] --> [Document Y]
```

This ability to compose Triples into higher-order statements gives the graph a fractal quality—small facts build into bigger facts, and complex relationships can be broken down into simpler ones.

## Positive and Negative Claims

Unlike traditional databases that store only "the one truth," Intuition allows multiple competing Triples and uses Signals (stakes) to gauge their validity.

### Two-Sided Staking Vaults
Every Triple has two logical versions:
- **YES vault**: Supporting the claim (affirmative)
- **NO vault**: Denying the claim (negative)

Users can stake on either side, effectively casting weighted votes about the truth of that Triple. This design means a Triple object encapsulates both the claim and its counter-claim within one structure.

### Example: Contested Relationships
For the Triple `[Bob] -- [isFriendOf] --> [Alice]`:
- The affirmative vault contains stakes from those who agree Bob and Alice are friends
- The negative vault contains stakes from those who disagree (potentially including Alice herself!)

### Consensus Evaluation
The network evaluates consensus by:
- Comparing signals on both sides
- Factoring in attestor reputation
- Considering the number of attestors
- Calculating confidence scores that adjust over time

Importantly, Intuition doesn't force a single authoritative truth—it records the spectrum of belief. Multiple "canonical" Triples can compete, and the TCR mechanism with staking tends to favor the most accurate representations.

## Best Practices for Structuring Triples

### Use Precise Predicates
The Predicate Atom is crucial for clarity. Guidelines:
- **Search first**: Check if a canonical predicate already exists
- **Reuse standards**: Don't create `[worksFor]` if `[employeeOf]` is widely used
- **Converge on conventions**: Using common predicates helps data link up instead of fragmenting

The Intuition community and token mechanics organically push toward standard predicates through signal accumulation.

### One Fact Per Triple
Each Triple should capture a single discrete claim:
- ❌ "Alice isFriendOf Bob and coworker at CompanyX"
- ✅ Two separate Triples: one for friendship, another for workplace

Keeping to one relation makes staking and validation straightforward—people can agree with one link and not the other.

### Leverage Nesting for Context
When statements need qualification:
- Create auxiliary Triples rather than complicating the original
- Attach timeframes or sources through supporting Triples
- Use nested Triples for meta-information

Example: Time-bound relationships
```
Main Triple: [Alice] -- [isFriendOf] --> [Bob]
Context Triple: [Triple ID] -- [validSince] --> [2023]
```

### Handle Counter-Claims Wisely
Generally, you don't need to manually create "not X" Triples—the negative staking vault handles disagreement. However, sometimes a negation has specific meaning that deserves its own predicate (e.g., `[isNotFriendOf]` as a distinct relation type).

The "Counter Triple" concept is more about how the UI and indexing organize the negative vault signal than about separate data objects.

## Core Benefits

### Semantic Clarity and Interoperability
Each Triple makes a small, clear statement that can be understood in isolation or as part of larger datasets. This semantic structure means data from Intuition is immediately useful to other systems—knowledge graphs and AI can ingest these triples without guessing their meaning.

### Flexibility & Composability
Triples can represent simple facts or be combined into complex graphs. You can always extend the graph by adding another Triple rather than modifying existing ones. Because Triples can reference other Triples, you get composability in assertions—building evidence chains, tracking consensus over time, and more.

### Built-In Conflict Resolution
Triples come with a native way to handle conflicting views through the two-vault mechanism. This keeps contradictory information tethered to the original claim, improving data organization. Rather than disjointed claims floating around, everything is anchored—a false claim isn't simply deleted but gets counter-staked and remains in the graph with a low trust score.

### Context and Evolution
Knowledge in Intuition is not static. When statements become outdated or need context, you don't replace old data—you supplement it. For example, if Alice moves from Paris to London:
1. Mark the Paris Triple as no longer current (stake against it or add an "endDate" context triple)
2. Add `[Alice] -- [livesIn] --> [London]` as a new Triple with current timestamp

The history is preserved, and queries can be time-scoped or context-aware thanks to the graph structure.

## Practical Implementation

### Creating Triples
```javascript
// Basic Triple creation
const triple = await createTriple({
  subjectId: aliceAtom.id,
  predicateId: livesInAtom.id,
  objectId: parisAtom.id
});

// With temporal context
const employmentTriple = await createTriple({
  subjectId: person.id,
  predicateId: "employed-by",
  objectId: company.id,
  metadata: {
    startDate: "2024-01-01",
    department: "Engineering"
  }
});
```

### Nested Triple Example
```javascript
// Create the base claim
const friendshipClaim = await createTriple({
  subjectId: bob.id,
  predicateId: isFriendOf.id,
  objectId: alice.id
});

// Alice disputes the claim
const dispute = await createTriple({
  subjectId: alice.id,
  predicateId: disproves.id,
  objectId: friendshipClaim.id  // Reference to the Triple itself
});
```

### Building Evidence Chains
```javascript
// Create a research finding
const researchClaim = await createTriple({
  subjectId: study.id,
  predicateId: concludes.id,
  objectId: result.id
});

// Link to supporting document
const evidence = await createTriple({
  subjectId: researchClaim.id,  // Triple as subject
  predicateId: basedOn.id,
  objectId: peerReviewedPaper.id
});
```

## Use Cases

### Knowledge Graphs
Build comprehensive knowledge networks for:
- Academic citations and research connections
- Information hierarchies and taxonomies
- Cross-referenced documentation systems

### Identity & Reputation
Create verifiable identity systems with:
- Professional credentials and certifications
- Social connections and endorsements
- Achievement records and skill attestations

### Supply Chain
Track product journeys through:
- Origin verification and authenticity
- Ownership transfers and custody chains
- Quality attestations and compliance records

### DeFi & Finance
Express financial relationships including:
- Asset ownership and portfolio composition
- Lending positions and collateralization
- Liquidity provisions and yield farming positions

## Querying Triples

### Basic Queries
```graphql
# Find all facts about Alice
query {
  triples(where: { subjectId: "alice_atom_id" }) {
    predicate
    object {
      data
    }
  }
}

# Find all friendship relationships
query {
  triples(where: { predicate: "isFriendOf" }) {
    subject { data }
    object { data }
  }
}
```

### Traversing the Graph
```graphql
# Find where Alice's friends live
query {
  triples(where: {
    subjectId: "alice_atom_id",
    predicate: "isFriendOf"
  }) {
    object {
      triples(where: { predicate: "livesIn" }) {
        object { data }
      }
    }
  }
}
```

## Integration with Other Primitives

### With Atoms
- Triples connect Atoms into meaningful relationships
- Atoms gain context through Triple connections
- Triple predicates can themselves be Atoms for maximum flexibility

### With Signals
- Signals add weight to Triple claims through staking
- Community validates Triples through Signal attestations
- Signal strength directly affects Triple credibility and consensus

## Summary

Triples allow Intuition to form a living, searchable web of knowledge. When adding Triples, the goal is to make each claim as clear and verifiable as possible, selecting the right words (Atoms) from the global dictionary, and then letting the network of users and their Signals determine validity.

With Atoms as the words in our global dictionary and Triples as the sentences we construct from them, we can express any arbitrarily-complex concept while maintaining discrete, referenceable structure. Here's where it becomes powerful: each Triple receives its own unique ID, effectively becoming a new "word" in the system that encapsulates an entire concept. This ID can then be referenced by other Triples, allowing you to build increasingly sophisticated expressions.

Think of it as linguistic compression—instead of repeatedly expressing complex relationships, you create them once and reference them by ID. A Triple about "Alice's employment at a specific company with particular conditions" becomes a single referenceable unit. That unit can then be used in higher-order statements about employment trends, verification claims, or temporal changes. This creates a hierarchy of meaning where complex ideas are built from simpler ones, yet each level remains independently addressable and verifiable.

The result is an extraordinarily efficient knowledge transmission system. Rather than sending verbose descriptions, systems can exchange compact Triple IDs that expand into rich, contextual information. Each ID carries with it not just data, but the entire graph of relationships, evidence, and community consensus that supports it. The addition of Signals completes the picture by measuring which sentences (facts) are trusted by the community.

### Overview.mdx
.md
.mdx


# Intuition SDK Guide

The Intuition SDK is your toolkit for building with the Intuition Protocol. Think of it as a friendly bridge between your application and Intuition's powerful knowledge graph system.

## What does the SDK do?

The SDK makes it easy to:

- **Create and manage semantic data** - Build atoms (individual pieces of information) and triples (relationships between atoms)
- **Interact with the blockchain** - Handle deposits, withdrawals, and smart contract interactions seamlessly
- **Query the knowledge graph** - Search and retrieve data from Intuition's decentralized database
- **Build user-friendly apps** - Focus on your app's features while the SDK handles the complex protocol interactions

Whether you're building a social platform, a data verification tool, or any application that needs to work with verifiable, decentralized information, the SDK provides the building blocks you need.

The Intuition SDK simplifies development with the Intuition backend systems, providing a clean TypeScript interface for creating and managing Atoms and Triples with ease.

## Installation

### From NPM Registry

Install the SDK using your preferred package manager:

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

<Tabs>
<TabItem value="npm" label="npm" default>

```bash
npm install @0xintuition/sdk
```

</TabItem>
<TabItem value="pnpm" label="pnpm">

```bash
pnpm install @0xintuition/sdk
```

</TabItem>
<TabItem value="bun" label="bun">

```bash
bun install @0xintuition/sdk
```

</TabItem>
</Tabs>

### Local Development

For local development or testing with a custom build:

<Tabs>
<TabItem value="npm-local" label="npm" default>

```bash
# Clone the repository
git clone https://github.com/0xIntuition/intuition-ts.git
cd intuition-ts/packages/sdk

# Install dependencies
npm install

# Build the package
npm run build

# Link locally
npm link

# In your project
npm link @0xintuition/sdk
```

</TabItem>
<TabItem value="pnpm-local" label="pnpm">

```bash
# Clone the repository
git clone https://github.com/0xIntuition/intuition-ts.git
cd intuition-ts/packages/sdk

# Install dependencies
pnpm install

# Build the package
pnpm build

# Link locally
pnpm link --global

# In your project
pnpm link --global @0xintuition/sdk
```

</TabItem>
<TabItem value="bun-local" label="bun">

```bash
# Clone the repository
git clone https://github.com/0xIntuition/intuition-ts.git
cd intuition-ts/packages/sdk

# Install dependencies
bun install

# Build the package
bun run build

# Link locally
bun link

# In your project
bun link @0xintuition/sdk
```

</TabItem>
</Tabs>

## Prerequisites

The SDK requires **viem@2.x.x** to execute reads and writes. Make sure you have it installed:

```bash
npm install viem@^2.0.0
```

## Setup

### Basic Client Configuration

Set up your viem clients for interacting with the Intuition protocol:

```typescript
import {
  getMultiVaultAddressFromChainId,
  intuitionTestnet,
} from '@0xintuition/protocol'

import {
  createPublicClient,
  createWalletClient,
  http,
  privateKeyToAccount,
} from 'viem'

export const address = getMultiVaultAddressFromChainId(intuitionTestnet.id)

export const publicClient = createPublicClient({
  chain: intuitionTestnet,
  transport: http(),
})

const account = privateKeyToAccount(
  '0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80',
)
export const walletClient = createWalletClient({
  chain: intuitionTestnet,
  transport: http(),
  account: account,
})
```

## Supported Networks

The Intuition SDK supports multiple networks:

| Network | Chain ID | Type | Status |
|---------|----------|------|--------|
| Intuition Network | 1155 | Mainnet | ✅ Production |
| Intuition Network Testnet | 13579 | Testnet | ✅ Development |
| Base Mainnet | 8453 | Mainnet | ✅ Production |
| Base Sepolia | 84532 | Testnet | ✅ Development |
| Ethereum Mainnet | 1 | Mainnet | ✅ Production |
| Sepolia | 11155111 | Testnet | ✅ Development |
| Arbitrum One | 42161 | Mainnet | ✅ Production |
| Arbitrum Sepolia | 421614 | Testnet | ✅ Development |

The SDK automatically detects the network and uses the appropriate contract addresses via `getEthMultiVaultAddressFromChainId()`.

**Note**: The Intuition L3 network (Caldera rollup) is currently in development. Access the [Hub](https://intuition-testnet.hub.caldera.xyz/) for L3 network development tools and testing.

## Reading Data

### Fetching Atoms and Triples

```typescript
import { getAtomDetails, getTripleDetails } from '@0xintuition/sdk'

// Get atom data by ID
const atomData = await getAtomDetails(
  '0x57d94c116a33bb460428eced262b7ae2ec6f865e7aceef6357cec3d034e8ea21',
)

// Get triple data by ID
const tripleData = await getTripleDetails(
  '0x4957d3f442acc301ad71e73f26efd6af78647f57dacf2b3a686d91fa773fe0b6',
)

## Creating Triples

Triples connect three atoms in a subject-predicate-object relationship:

```typescript
import { createAtomFromString, createTripleStatement } from '@0xintuition/sdk'

// Create three atoms first
const atom1 = await createAtomFromString(
  { walletClient, publicClient, address },
  'atom1',
)
const atom2 = await createAtomFromString(
  { walletClient, publicClient, address },
  'atom2',
)
const atom3 = await createAtomFromString(
  { walletClient, publicClient, address },
  'atom3',
)

// Create a triple statement connecting the three atoms
const triple = await createTripleStatement(
  { walletClient, publicClient, address },
  {
    args: [atom1.state.termId, atom2.state.termId, atom3.state.termId],
    value: 1000000000000000000n, // 1 ETH in wei for deposit
  },
)
```

## Creating Atoms

### Create Atom from String

The simplest way to create an atom with a text label:

```typescript
import { createAtomFromString } from '@0xintuition/sdk'

const data = await createAtomFromString(
  { walletClient, publicClient, address },
  'is great',
)
```

### Create Atom from IPFS Upload

Create an atom by uploading metadata to IPFS:

```typescript
import { createAtomFromIpfsUpload } from '@0xintuition/sdk'

const data = await createAtomFromIpfsUpload(
  {
    walletClient,
    publicClient,
    address,
    pinataApiKey: 'your-pinata-api-key',
  },
  {
    url: 'https://www.intuition.systems/',
    name: 'Intuition',
    description: 'A decentralized trust protocol',
    image: 'https://example.com/image.png',
    tags: ['decentralized', 'trust', 'protocol'],
    twitter: 'https://twitter.com/intuition_systems',
    github: 'github.com/intuition-systems',
  },
)
```

### Create a Thing

Create an atom representing a structured object:

```typescript
import { createAtomFromThing } from '@0xintuition/sdk'

const data = await createAtomFromThing(
  { walletClient, publicClient, address },
  {
    url: 'https://www.intuition.systems/',
    name: 'Intuition',
    description: 'A decentralized trust protocol',
    image: 'https://example.com/image.png',
  },
)
```

### Create an Ethereum Account

Create an atom representing an Ethereum account:

```typescript
import { createAtomFromEthereumAccount } from '@0xintuition/sdk'

const data = await createAtomFromEthereumAccount(
  { walletClient, publicClient, address },
  {
    address: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045',
    chainId: 1, // Mainnet
  },
)
```

### Batch Operations

The SDK provides efficient batch operations for creating multiple atoms at once:

#### Batch Create Atoms from IPFS URIs

```typescript
import {
  batchCreateAtomsFromIpfsUris,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromIpfsUris(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    'ipfs://bafkreib7534cszxn2c6qwoviv43sqh244yfrxomjbealjdwntd6a7atq6u',
    'ipfs://bafkreicq2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q2d5q',
  ],
)
```

#### Batch Create Atoms from Smart Contracts

```typescript
import {
  batchCreateAtomsFromSmartContracts,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromSmartContracts(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    '0xA0b86a33E6441b8c4C8C8C8C8C8C8C8C8C8C8C8C',
    '0xB1c97a44E7551b9d5C8C8C8C8C8C8C8C8C8C8C8C8C',
  ],
)
```

#### Batch Create Atoms from Ethereum Accounts

```typescript
import {
  batchCreateAtomsFromEthereumAccounts,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromEthereumAccounts(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    { address: '0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045', chainId: 1 },
    { address: '0x742d35Cc6634C0532925a3b8D4C9db96C4b4d8b6', chainId: 1 },
  ],
)
```

#### Batch Create Atoms from Things

```typescript
import {
  batchCreateAtomsFromThings,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateAtomsFromThings(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    {
      url: 'https://www.intuition.systems/',
      name: 'Intuition',
      description: 'A decentralized trust protocol.',
      image: 'https://example.com/image.png',
    },
    {
      url: 'https://example.com/',
      name: 'Example',
      description: 'An example thing.',
      image: 'https://example.com/example.png',
    },
  ],
)
```

#### Batch Create Triple Statements

```typescript
import {
  batchCreateTripleStatements,
  getEthMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

const ethMultiVaultAddress = getEthMultiVaultAddressFromChainId(walletClient.chain.id)
const data = await batchCreateTripleStatements(
  { walletClient, publicClient, address: ethMultiVaultAddress },
  [
    { args: [atom1.state.vaultId, atom2.state.vaultId, atom3.state.vaultId] },
    { args: [atom4.state.vaultId, atom5.state.vaultId, atom6.state.vaultId] },
  ],
)
```

## Response Data Structure

After successfully creating a new Atom, the SDK returns a data object containing:

```typescript
const data: {
    uri: string
    transactionHash: `0x${string}`;
    state: {
        creator: Address,
        termId: Hex,
        atomData: Hex,
        atomWallet: Address
    };
}
```

## React Integration Example

Here's a complete React component that creates an atom from structured metadata:

```tsx
import * as React from 'react'

import {
  createAtomFromThing,
  getMultiVaultAddressFromChainId,
} from '@0xintuition/sdk'

import { useChainId, usePublicClient, useWalletClient } from 'wagmi'

type IntuitionButton = React.HTMLAttributes<HTMLElement>

const IntuitionButton = ({ children, className }: IntuitionButton) => {
  const chainId = useChainId()
  const publicClient = usePublicClient()
  const { data: walletClient } = useWalletClient()

  const handleClick = async () => {
    const multiVaultAddress = getMultiVaultAddressFromChainId(chainId)
    const data = await createAtomFromThing(
      { walletClient, publicClient, address: multiVaultAddress },
      {
        url: 'https://www.intuition.systems/',
        name: 'Intuition',
        description: 'A decentralized trust protocol.',
        image: 'https://example.com/image.png',
      },
    )
  }

  return <button onClick={handleClick}>Create Thing</button>
}

export { IntuitionButton }
```

## Development

### Building the SDK

<Tabs>
<TabItem value="npm-build" label="npm" default>

```bash
npm run build
```

</TabItem>
<TabItem value="pnpm-build" label="pnpm">

```bash
pnpm build
```

</TabItem>
<TabItem value="bun-build" label="bun">

```bash
bun run build
```

</TabItem>
</Tabs>

### Running Tests

<Tabs>
<TabItem value="npm-test" label="npm" default>

```bash
npm test
```

</TabItem>
<TabItem value="pnpm-test" label="pnpm">

```bash
pnpm test
```

</TabItem>
<TabItem value="bun-test" label="bun">

```bash
bun test
```

</TabItem>
</Tabs>



## Resources

- [NPMJS/Intuition](https://www.npmjs.com/package/@0xintuition/sdk)
- [Github Repo](https://github.com/0xIntuition/intuition-ts/tree/main/packages/sdk)
- [Intuition Discord](https://discord.gg/intuition)

## Contributing

Contributions are welcome! Please see the main repository for more information on how to contribute.

### Overview.mdx
.md
.mdx


import GraphQLPlayground from '@site/src/components/GraphQLPlayground';
import BrowserOnly from '@docusaurus/BrowserOnly';
import ExcalidrawViewer from '@site/src/components/ExcalidrawViewer';

# GraphQL API Overview

<BrowserOnly fallback={<p>Loading diagram...</p>}>
  {() => (
    <ExcalidrawViewer src="/excalidraw/architecture-diagram.excalidraw.json" />
  )}
</BrowserOnly>

Intuition provides a GraphQL API for querying its knowledge graph in a convenient and versatile way. There are a few ways to get started with this GraphQL API, depending on the level of abstraction and customization you require.

If this is your first time using GraphQL, you can learn more at [graphql.org](https://graphql.org/).

Until mainnet launch, the Intuition team hosts an open GraphQL API powered by Hasura, which may be accessed at [https://testnet.intuition.sh/v1/graphql](https://testnet.intuition.sh/v1/graphql). For more information about running the backend yourself, visit [Run an Intuition node](/docs/run-node/run-an-intuition-node).

<div className="uniform-card-grid">

  <a
    href="/docs/developer-tools/sdks/overview"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <SdkIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      SDK
    </h3>
    <p className="uniform-card-content">
      Integrate with Intuition smart contracts using our TypeScript SDK.
    </p>
  </a>

  <a
    href="/docs/developer-tools/graphql-api/custom-queries"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <QueriesIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Custom Queries
    </h3>
    <p className="uniform-card-content">
      Create bespoke GraphQL queries for your specific use case.
    </p>
  </a>

</div>

### GraphQL Package

<div className="uniform-card-grid-small">
  <a
    href="/docs/developer-tools/graphql-api/npm-package"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <NpmIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Install it with NPM
    </h3>
    <p className="uniform-card-content">
      Install and use the NPM package with ready-made React Query hooks.
    </p>
  </a>

  <a
    href="/docs/developer-tools/graphql-api/npm-package"
    className="clickable-card uniform-card vision-card items-center justify-center text-center"
  >
    <span className="mb-4 relative flex h-14 w-14 items-center justify-center rounded-full bg-gradient-to-br from-primary/10 to-primary/5">
      <GraphQlGeneratorIcon className="text-primary" />
    </span>
    <h3 className="uniform-card-title">
      Use it as a GraphQL Generator
    </h3>
    <p className="uniform-card-content">
      Use the GraphQL package to generate your own queries and mutations.
    </p>
  </a>
</div>

## Interactive Playground

Try the Intuition GraphQL API straight from your browser!  The playground below connects to the live testnet endpoint and allows you to explore the knowledge graph in real time.

<GraphQLPlayground />

